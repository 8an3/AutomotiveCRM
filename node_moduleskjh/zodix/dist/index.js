"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/cookie/index.js
var require_cookie = __commonJS({
  "node_modules/cookie/index.js"(exports) {
    "use strict";
    exports.parse = parse;
    exports.serialize = serialize;
    var decode = decodeURIComponent;
    var encode = encodeURIComponent;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var pairs = str.split(";");
      var dec = opt.decode || decode;
      for (var i = 0; i < pairs.length; i++) {
        var pair = pairs[i];
        var index = pair.indexOf("=");
        if (index < 0) {
          continue;
        }
        var key = pair.substring(0, index).trim();
        if (void 0 == obj[key]) {
          var val = pair.substring(index + 1, pair.length).trim();
          if (val[0] === '"') {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
      }
      return obj;
    }
    function serialize(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        if (typeof opt.expires.toUTCString !== "function") {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + opt.expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// node_modules/@remix-run/server-runtime/dist/warnings.js
var require_warnings = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/warnings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var alreadyWarned = {};
    function warnOnce(condition, message) {
      if (!condition && !alreadyWarned[message]) {
        alreadyWarned[message] = true;
        console.warn(message);
      }
    }
    exports.warnOnce = warnOnce;
  }
});

// node_modules/@remix-run/server-runtime/dist/cookies.js
var require_cookies = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/cookies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var cookie = require_cookie();
    var warnings = require_warnings();
    var createCookieFactory = ({
      sign,
      unsign
    }) => (name, cookieOptions = {}) => {
      let {
        secrets,
        ...options
      } = {
        secrets: [],
        path: "/",
        sameSite: "lax",
        ...cookieOptions
      };
      warnOnceAboutExpiresCookie(name, options.expires);
      return {
        get name() {
          return name;
        },
        get isSigned() {
          return secrets.length > 0;
        },
        get expires() {
          return typeof options.maxAge !== "undefined" ? new Date(Date.now() + options.maxAge * 1e3) : options.expires;
        },
        async parse(cookieHeader, parseOptions) {
          if (!cookieHeader)
            return null;
          let cookies = cookie.parse(cookieHeader, {
            ...options,
            ...parseOptions
          });
          return name in cookies ? cookies[name] === "" ? "" : await decodeCookieValue(unsign, cookies[name], secrets) : null;
        },
        async serialize(value, serializeOptions) {
          return cookie.serialize(name, value === "" ? "" : await encodeCookieValue(sign, value, secrets), {
            ...options,
            ...serializeOptions
          });
        }
      };
    };
    var isCookie = (object) => {
      return object != null && typeof object.name === "string" && typeof object.isSigned === "boolean" && typeof object.parse === "function" && typeof object.serialize === "function";
    };
    async function encodeCookieValue(sign, value, secrets) {
      let encoded = encodeData(value);
      if (secrets.length > 0) {
        encoded = await sign(encoded, secrets[0]);
      }
      return encoded;
    }
    async function decodeCookieValue(unsign, value, secrets) {
      if (secrets.length > 0) {
        for (let secret of secrets) {
          let unsignedValue = await unsign(value, secret);
          if (unsignedValue !== false) {
            return decodeData(unsignedValue);
          }
        }
        return null;
      }
      return decodeData(value);
    }
    function encodeData(value) {
      return btoa(myUnescape(encodeURIComponent(JSON.stringify(value))));
    }
    function decodeData(value) {
      try {
        return JSON.parse(decodeURIComponent(myEscape(atob(value))));
      } catch (error) {
        return {};
      }
    }
    function myEscape(value) {
      let str = value.toString();
      let result = "";
      let index = 0;
      let chr, code;
      while (index < str.length) {
        chr = str.charAt(index++);
        if (/[\w*+\-./@]/.exec(chr)) {
          result += chr;
        } else {
          code = chr.charCodeAt(0);
          if (code < 256) {
            result += "%" + hex(code, 2);
          } else {
            result += "%u" + hex(code, 4).toUpperCase();
          }
        }
      }
      return result;
    }
    function hex(code, length) {
      let result = code.toString(16);
      while (result.length < length)
        result = "0" + result;
      return result;
    }
    function myUnescape(value) {
      let str = value.toString();
      let result = "";
      let index = 0;
      let chr, part;
      while (index < str.length) {
        chr = str.charAt(index++);
        if (chr === "%") {
          if (str.charAt(index) === "u") {
            part = str.slice(index + 1, index + 5);
            if (/^[\da-f]{4}$/i.exec(part)) {
              result += String.fromCharCode(parseInt(part, 16));
              index += 5;
              continue;
            }
          } else {
            part = str.slice(index, index + 2);
            if (/^[\da-f]{2}$/i.exec(part)) {
              result += String.fromCharCode(parseInt(part, 16));
              index += 2;
              continue;
            }
          }
        }
        result += chr;
      }
      return result;
    }
    function warnOnceAboutExpiresCookie(name, expires) {
      warnings.warnOnce(!expires, `The "${name}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`);
    }
    exports.createCookieFactory = createCookieFactory;
    exports.isCookie = isCookie;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/utils.js
var require_utils = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function stringToArray(s) {
      const utf8 = unescape(encodeURIComponent(s));
      return Uint8Array.from(utf8, (_, i) => utf8.charCodeAt(i));
    }
    function arrayToString(a) {
      const utf8 = String.fromCharCode.apply(null, a);
      return decodeURIComponent(escape(utf8));
    }
    function mergeArrays(...arrays) {
      const out = new Uint8Array(arrays.reduce((total, arr) => total + arr.length, 0));
      let offset = 0;
      for (const arr of arrays) {
        out.set(arr, offset);
        offset += arr.length;
      }
      return out;
    }
    function arraysEqual(a, b) {
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    exports.arrayToString = arrayToString;
    exports.arraysEqual = arraysEqual;
    exports.mergeArrays = mergeArrays;
    exports.stringToArray = stringToArray;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/search.js
var require_search = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/search.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils = require_utils();
    function coerce(a) {
      if (a instanceof Uint8Array) {
        return (index) => a[index];
      }
      return a;
    }
    function jsmemcmp(buf1, pos1, buf2, pos2, len) {
      const fn1 = coerce(buf1);
      const fn2 = coerce(buf2);
      for (let i = 0; i < len; ++i) {
        if (fn1(pos1 + i) !== fn2(pos2 + i)) {
          return false;
        }
      }
      return true;
    }
    function createOccurenceTable(s) {
      const table = new Array(256).fill(s.length);
      if (s.length > 1) {
        for (let i = 0; i < s.length - 1; i++) {
          table[s[i]] = s.length - 1 - i;
        }
      }
      return table;
    }
    var MATCH = Symbol("Match");
    var StreamSearch = class {
      constructor(needle) {
        this._lookbehind = new Uint8Array();
        if (typeof needle === "string") {
          this._needle = needle = utils.stringToArray(needle);
        } else {
          this._needle = needle;
        }
        this._lastChar = needle[needle.length - 1];
        this._occ = createOccurenceTable(needle);
      }
      feed(chunk) {
        let pos = 0;
        let tokens;
        const allTokens = [];
        while (pos !== chunk.length) {
          ;
          [pos, ...tokens] = this._feed(chunk, pos);
          allTokens.push(...tokens);
        }
        return allTokens;
      }
      end() {
        const tail = this._lookbehind;
        this._lookbehind = new Uint8Array();
        return tail;
      }
      _feed(data, bufPos) {
        const tokens = [];
        let pos = -this._lookbehind.length;
        if (pos < 0) {
          while (pos < 0 && pos <= data.length - this._needle.length) {
            const ch = this._charAt(data, pos + this._needle.length - 1);
            if (ch === this._lastChar && this._memcmp(data, pos, this._needle.length - 1)) {
              if (pos > -this._lookbehind.length) {
                tokens.push(this._lookbehind.slice(0, this._lookbehind.length + pos));
              }
              tokens.push(MATCH);
              this._lookbehind = new Uint8Array();
              return [
                pos + this._needle.length,
                ...tokens
              ];
            } else {
              pos += this._occ[ch];
            }
          }
          if (pos < 0) {
            while (pos < 0 && !this._memcmp(data, pos, data.length - pos)) {
              pos++;
            }
          }
          if (pos >= 0) {
            tokens.push(this._lookbehind);
            this._lookbehind = new Uint8Array();
          } else {
            const bytesToCutOff = this._lookbehind.length + pos;
            if (bytesToCutOff > 0) {
              tokens.push(this._lookbehind.slice(0, bytesToCutOff));
              this._lookbehind = this._lookbehind.slice(bytesToCutOff);
            }
            this._lookbehind = Uint8Array.from(new Array(this._lookbehind.length + data.length), (_, i) => this._charAt(data, i - this._lookbehind.length));
            return [
              data.length,
              ...tokens
            ];
          }
        }
        pos += bufPos;
        while (pos <= data.length - this._needle.length) {
          const ch = data[pos + this._needle.length - 1];
          if (ch === this._lastChar && data[pos] === this._needle[0] && jsmemcmp(this._needle, 0, data, pos, this._needle.length - 1)) {
            if (pos > bufPos) {
              tokens.push(data.slice(bufPos, pos));
            }
            tokens.push(MATCH);
            return [
              pos + this._needle.length,
              ...tokens
            ];
          } else {
            pos += this._occ[ch];
          }
        }
        if (pos < data.length) {
          while (pos < data.length && (data[pos] !== this._needle[0] || !jsmemcmp(data, pos, this._needle, 0, data.length - pos))) {
            ++pos;
          }
          if (pos < data.length) {
            this._lookbehind = data.slice(pos);
          }
        }
        if (pos > 0) {
          tokens.push(data.slice(bufPos, pos < data.length ? pos : data.length));
        }
        return [
          data.length,
          ...tokens
        ];
      }
      _charAt(data, pos) {
        if (pos < 0) {
          return this._lookbehind[this._lookbehind.length + pos];
        }
        return data[pos];
      }
      _memcmp(data, pos, len) {
        return jsmemcmp(this._charAt.bind(this, data), pos, this._needle, 0, len);
      }
    };
    var ReadableStreamSearch = class {
      constructor(needle, _readableStream) {
        this._readableStream = _readableStream;
        this._search = new StreamSearch(needle);
      }
      async *[Symbol.asyncIterator]() {
        const reader = this._readableStream.getReader();
        try {
          while (true) {
            const result = await reader.read();
            if (result.done) {
              break;
            }
            yield* this._search.feed(result.value);
          }
          const tail = this._search.end();
          if (tail.length) {
            yield tail;
          }
        } finally {
          reader.releaseLock();
        }
      }
    };
    var EOQ = Symbol("End of Queue");
    var QueueableStreamSearch = class {
      constructor(needle) {
        this._chunksQueue = [];
        this._closed = false;
        this._search = new StreamSearch(needle);
      }
      push(...chunks) {
        if (this._closed) {
          throw new Error("cannot call push after close");
        }
        this._chunksQueue.push(...chunks);
        if (this._notify) {
          this._notify();
        }
      }
      close() {
        if (this._closed) {
          throw new Error("close was already called");
        }
        this._closed = true;
        this._chunksQueue.push(EOQ);
        if (this._notify) {
          this._notify();
        }
      }
      async *[Symbol.asyncIterator]() {
        while (true) {
          let chunk;
          while (!(chunk = this._chunksQueue.shift())) {
            await new Promise((resolve) => this._notify = resolve);
            this._notify = void 0;
          }
          if (chunk === EOQ) {
            break;
          }
          yield* this._search.feed(chunk);
        }
        const tail = this._search.end();
        if (tail.length) {
          yield tail;
        }
      }
    };
    function splitChunks(chunks, needle) {
      const search = new StreamSearch(needle);
      const outchunks = [[]];
      for (const chunk of chunks) {
        for (const token of search.feed(chunk)) {
          if (token === MATCH) {
            outchunks.push([]);
          } else {
            outchunks[outchunks.length - 1].push(token);
          }
        }
      }
      const end = search.end();
      outchunks[outchunks.length - 1].push(end);
      return outchunks.map((chunks2) => utils.mergeArrays(...chunks2));
    }
    function split(buf, needle) {
      return splitChunks([buf], needle);
    }
    async function* chunksIterator(iter) {
      let chunks = [];
      for await (const value of iter) {
        if (value === MATCH) {
          yield chunks;
          chunks = [];
        } else {
          chunks.push(value);
        }
      }
      yield chunks;
    }
    async function* stringIterator(iter) {
      for await (const chunk of chunksIterator(iter)) {
        yield chunk.map(utils.arrayToString).join("");
      }
    }
    async function allStrings(iter) {
      const segments = [];
      for await (const value of stringIterator(iter)) {
        segments.push(value);
      }
      return segments;
    }
    async function* arrayIterator(iter) {
      for await (const chunk of chunksIterator(iter)) {
        yield utils.mergeArrays(...chunk);
      }
    }
    exports.MATCH = MATCH;
    exports.QueueableStreamSearch = QueueableStreamSearch;
    exports.ReadableStreamSearch = ReadableStreamSearch;
    exports.StreamSearch = StreamSearch;
    exports.allStrings = allStrings;
    exports.arrayIterator = arrayIterator;
    exports.chunksIterator = chunksIterator;
    exports.split = split;
    exports.splitChunks = splitChunks;
    exports.stringIterator = stringIterator;
  }
});

// node_modules/@web3-storage/multipart-parser/cjs/src/index.js
var require_src = __commonJS({
  "node_modules/@web3-storage/multipart-parser/cjs/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var search = require_search();
    var utils = require_utils();
    var mergeArrays2 = Function.prototype.apply.bind(utils.mergeArrays, void 0);
    var dash = utils.stringToArray("--");
    var CRLF = utils.stringToArray("\r\n");
    function parseContentDisposition(header) {
      const parts = header.split(";").map((part) => part.trim());
      if (parts.shift() !== "form-data") {
        throw new Error('malformed content-disposition header: missing "form-data" in `' + JSON.stringify(parts) + "`");
      }
      const out = {};
      for (const part of parts) {
        const kv = part.split("=", 2);
        if (kv.length !== 2) {
          throw new Error("malformed content-disposition header: key-value pair not found - " + part + " in `" + header + "`");
        }
        const [name, value] = kv;
        if (value[0] === '"' && value[value.length - 1] === '"') {
          out[name] = value.slice(1, -1).replace(/\\"/g, '"');
        } else if (value[0] !== '"' && value[value.length - 1] !== '"') {
          out[name] = value;
        } else if (value[0] === '"' && value[value.length - 1] !== '"' || value[0] !== '"' && value[value.length - 1] === '"') {
          throw new Error("malformed content-disposition header: mismatched quotations in `" + header + "`");
        }
      }
      if (!out.name) {
        throw new Error("malformed content-disposition header: missing field name in `" + header + "`");
      }
      return out;
    }
    function parsePartHeaders(lines) {
      const entries = [];
      let disposition = false;
      let line;
      while (typeof (line = lines.shift()) !== "undefined") {
        const colon = line.indexOf(":");
        if (colon === -1) {
          throw new Error("malformed multipart-form header: missing colon");
        }
        const header = line.slice(0, colon).trim().toLowerCase();
        const value = line.slice(colon + 1).trim();
        switch (header) {
          case "content-disposition":
            disposition = true;
            entries.push(...Object.entries(parseContentDisposition(value)));
            break;
          case "content-type":
            entries.push([
              "contentType",
              value
            ]);
        }
      }
      if (!disposition) {
        throw new Error("malformed multipart-form header: missing content-disposition");
      }
      return Object.fromEntries(entries);
    }
    async function readHeaderLines(it, needle) {
      let firstChunk = true;
      let lastTokenWasMatch = false;
      const headerLines = [[]];
      const crlfSearch = new search.StreamSearch(CRLF);
      for (; ; ) {
        const result = await it.next();
        if (result.done) {
          throw new Error("malformed multipart-form data: unexpected end of stream");
        }
        if (firstChunk && result.value !== search.MATCH && utils.arraysEqual(result.value.slice(0, 2), dash)) {
          return [
            void 0,
            new Uint8Array()
          ];
        }
        let chunk;
        if (result.value !== search.MATCH) {
          chunk = result.value;
        } else if (!lastTokenWasMatch) {
          chunk = needle;
        } else {
          throw new Error("malformed multipart-form data: unexpected boundary");
        }
        if (!chunk.length) {
          continue;
        }
        if (firstChunk) {
          firstChunk = false;
        }
        const tokens = crlfSearch.feed(chunk);
        for (const [i, token] of tokens.entries()) {
          const isMatch = token === search.MATCH;
          if (!isMatch && !token.length) {
            continue;
          }
          if (lastTokenWasMatch && isMatch) {
            tokens.push(crlfSearch.end());
            return [
              headerLines.filter((chunks) => chunks.length).map(mergeArrays2).map(utils.arrayToString),
              utils.mergeArrays(...tokens.slice(i + 1).map((token2) => token2 === search.MATCH ? CRLF : token2))
            ];
          }
          if (lastTokenWasMatch = isMatch) {
            headerLines.push([]);
          } else {
            headerLines[headerLines.length - 1].push(token);
          }
        }
      }
    }
    async function* streamMultipart(body, boundary) {
      const needle = utils.mergeArrays(dash, utils.stringToArray(boundary));
      const it = new search.ReadableStreamSearch(needle, body)[Symbol.asyncIterator]();
      for (; ; ) {
        const result = await it.next();
        if (result.done) {
          return;
        }
        if (result.value === search.MATCH) {
          break;
        }
      }
      const crlfSearch = new search.StreamSearch(CRLF);
      for (; ; ) {
        let feedChunk = function(chunk) {
          const chunks = [];
          for (const token of crlfSearch.feed(chunk)) {
            if (trailingCRLF) {
              chunks.push(CRLF);
            }
            if (!(trailingCRLF = token === search.MATCH)) {
              chunks.push(token);
            }
          }
          return utils.mergeArrays(...chunks);
        };
        const [headerLines, tail] = await readHeaderLines(it, needle);
        if (!headerLines) {
          return;
        }
        async function nextToken() {
          const result = await it.next();
          if (result.done) {
            throw new Error("malformed multipart-form data: unexpected end of stream");
          }
          return result;
        }
        let trailingCRLF = false;
        let done = false;
        async function nextChunk() {
          const result = await nextToken();
          let chunk;
          if (result.value !== search.MATCH) {
            chunk = result.value;
          } else if (!trailingCRLF) {
            chunk = CRLF;
          } else {
            done = true;
            return { value: crlfSearch.end() };
          }
          return { value: feedChunk(chunk) };
        }
        const bufferedChunks = [{ value: feedChunk(tail) }];
        yield {
          ...parsePartHeaders(headerLines),
          data: {
            [Symbol.asyncIterator]() {
              return this;
            },
            async next() {
              for (; ; ) {
                const result = bufferedChunks.shift();
                if (!result) {
                  break;
                }
                if (result.value.length > 0) {
                  return result;
                }
              }
              for (; ; ) {
                if (done) {
                  return {
                    done,
                    value: void 0
                  };
                }
                const result = await nextChunk();
                if (result.value.length > 0) {
                  return result;
                }
              }
            }
          }
        };
        while (!done) {
          bufferedChunks.push(await nextChunk());
        }
      }
    }
    async function* iterateMultipart(body, boundary) {
      for await (const part of streamMultipart(body, boundary)) {
        const chunks = [];
        for await (const chunk of part.data) {
          chunks.push(chunk);
        }
        yield {
          ...part,
          data: utils.mergeArrays(...chunks)
        };
      }
    }
    exports.iterateMultipart = iterateMultipart;
    exports.streamMultipart = streamMultipart;
  }
});

// node_modules/@remix-run/server-runtime/dist/formData.js
var require_formData = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/formData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var multipartParser = require_src();
    function composeUploadHandlers(...handlers) {
      return async (part) => {
        for (let handler of handlers) {
          let value = await handler(part);
          if (typeof value !== "undefined" && value !== null) {
            return value;
          }
        }
        return void 0;
      };
    }
    async function parseMultipartFormData(request, uploadHandler) {
      let contentType = request.headers.get("Content-Type") || "";
      let [type, boundary] = contentType.split(/\s*;\s*boundary=/);
      if (!request.body || !boundary || type !== "multipart/form-data") {
        throw new TypeError("Could not parse content as FormData.");
      }
      let formData = new FormData();
      let parts = multipartParser.streamMultipart(request.body, boundary);
      for await (let part of parts) {
        if (part.done)
          break;
        if (typeof part.filename === "string") {
          part.filename = part.filename.split(/[/\\]/).pop();
        }
        let value = await uploadHandler(part);
        if (typeof value !== "undefined" && value !== null) {
          formData.append(part.name, value);
        }
      }
      return formData;
    }
    exports.composeUploadHandlers = composeUploadHandlers;
    exports.parseMultipartFormData = parseMultipartFormData;
  }
});

// node_modules/@remix-run/server-runtime/dist/responses.js
var require_responses = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/responses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var json2 = (data, init = {}) => {
      let responseInit = typeof init === "number" ? {
        status: init
      } : init;
      let headers = new Headers(responseInit.headers);
      if (!headers.has("Content-Type")) {
        headers.set("Content-Type", "application/json; charset=utf-8");
      }
      return new Response(JSON.stringify(data), {
        ...responseInit,
        headers
      });
    };
    var redirect = (url, init = 302) => {
      let responseInit = init;
      if (typeof responseInit === "number") {
        responseInit = {
          status: responseInit
        };
      } else if (typeof responseInit.status === "undefined") {
        responseInit.status = 302;
      }
      let headers = new Headers(responseInit.headers);
      headers.set("Location", url);
      return new Response(null, {
        ...responseInit,
        headers
      });
    };
    function isResponse(value) {
      return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
    }
    var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
    function isRedirectResponse(response) {
      return redirectStatusCodes.has(response.status);
    }
    function isCatchResponse(response) {
      return response.headers.get("X-Remix-Catch") != null;
    }
    exports.isCatchResponse = isCatchResponse;
    exports.isRedirectResponse = isRedirectResponse;
    exports.isResponse = isResponse;
    exports.json = json2;
    exports.redirect = redirect;
  }
});

// node_modules/@remix-run/server-runtime/dist/data.js
var require_data = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var responses = require_responses();
    async function callRouteAction({
      loadContext,
      match,
      request
    }) {
      let action = match.route.module.action;
      if (!action) {
        let response = new Response(null, {
          status: 405
        });
        response.headers.set("X-Remix-Catch", "yes");
        return response;
      }
      let result;
      try {
        result = await action({
          request: stripDataParam(stripIndexParam(request)),
          context: loadContext,
          params: match.params
        });
      } catch (error) {
        if (!responses.isResponse(error)) {
          throw error;
        }
        if (!responses.isRedirectResponse(error)) {
          error.headers.set("X-Remix-Catch", "yes");
        }
        result = error;
      }
      if (result === void 0) {
        throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
      }
      return responses.isResponse(result) ? result : responses.json(result);
    }
    async function callRouteLoader({
      loadContext,
      match,
      request
    }) {
      let loader = match.route.module.loader;
      if (!loader) {
        throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a default component or \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
      }
      let result;
      try {
        result = await loader({
          request: stripDataParam(stripIndexParam(request)),
          context: loadContext,
          params: match.params
        });
      } catch (error) {
        if (!responses.isResponse(error)) {
          throw error;
        }
        if (!responses.isRedirectResponse(error)) {
          error.headers.set("X-Remix-Catch", "yes");
        }
        result = error;
      }
      if (result === void 0) {
        throw new Error(`You defined a loader for route "${match.route.id}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
      }
      return responses.isResponse(result) ? result : responses.json(result);
    }
    function stripIndexParam(request) {
      let url = new URL(request.url);
      let indexValues = url.searchParams.getAll("index");
      url.searchParams.delete("index");
      let indexValuesToKeep = [];
      for (let indexValue of indexValues) {
        if (indexValue) {
          indexValuesToKeep.push(indexValue);
        }
      }
      for (let toKeep of indexValuesToKeep) {
        url.searchParams.append("index", toKeep);
      }
      return new Request(url.href, request);
    }
    function stripDataParam(request) {
      let url = new URL(request.url);
      url.searchParams.delete("_data");
      return new Request(url.href, request);
    }
    function extractData(response) {
      let contentType = response.headers.get("Content-Type");
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        return response.json();
      }
      return response.text();
    }
    exports.callRouteAction = callRouteAction;
    exports.callRouteLoader = callRouteLoader;
    exports.extractData = extractData;
  }
});

// node_modules/@remix-run/server-runtime/dist/entry.js
var require_entry = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/entry.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createEntryMatches(matches, routes) {
      return matches.map((match) => ({
        params: match.params,
        pathname: match.pathname,
        route: routes[match.route.id]
      }));
    }
    function createEntryRouteModules(manifest) {
      return Object.keys(manifest).reduce((memo, routeId) => {
        memo[routeId] = manifest[routeId].module;
        return memo;
      }, {});
    }
    exports.createEntryMatches = createEntryMatches;
    exports.createEntryRouteModules = createEntryRouteModules;
  }
});

// node_modules/@remix-run/server-runtime/dist/errors.js
var require_errors = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    async function serializeError(error) {
      return {
        message: error.message,
        stack: error.stack
      };
    }
    exports.serializeError = serializeError;
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module2) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error(
          "set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.",
          e
        );
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers && input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn(
            "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
          );
        }
        input = sch;
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module2.exports = parse;
    module2.exports.parse = parse;
    module2.exports.parseString = parseString;
    module2.exports.splitCookiesString = splitCookiesString;
  }
});

// node_modules/@remix-run/server-runtime/dist/headers.js
var require_headers = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var setCookieParser = require_set_cookie();
    function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
      return matches.reduce((parentHeaders, match, index) => {
        let routeModule = build.routes[match.route.id].module;
        let routeLoaderResponse = routeLoaderResponses[match.route.id];
        let loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers();
        let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
        let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
          loaderHeaders,
          parentHeaders,
          actionHeaders
        }) : routeModule.headers : void 0);
        prependCookies(actionHeaders, headers);
        prependCookies(loaderHeaders, headers);
        prependCookies(parentHeaders, headers);
        return headers;
      }, new Headers());
    }
    function prependCookies(parentHeaders, childHeaders) {
      let parentSetCookieString = parentHeaders.get("Set-Cookie");
      if (parentSetCookieString) {
        let cookies = setCookieParser.splitCookiesString(parentSetCookieString);
        cookies.forEach((cookie) => {
          childHeaders.append("Set-Cookie", cookie);
        });
      }
    }
    exports.getDocumentHeaders = getDocumentHeaders;
  }
});

// node_modules/@remix-run/server-runtime/dist/mode.js
var require_mode = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ServerMode = void 0;
    (function(ServerMode) {
      ServerMode["Development"] = "development";
      ServerMode["Production"] = "production";
      ServerMode["Test"] = "test";
    })(exports.ServerMode || (exports.ServerMode = {}));
    function isServerMode(value) {
      return value === exports.ServerMode.Development || value === exports.ServerMode.Production || value === exports.ServerMode.Test;
    }
    exports.isServerMode = isServerMode;
  }
});

// node_modules/react/cjs/react.production.min.js
var require_react_production_min = __commonJS({
  "node_modules/react/cjs/react.production.min.js"(exports) {
    "use strict";
    var l = Symbol.for("react.element");
    var n = Symbol.for("react.portal");
    var p = Symbol.for("react.fragment");
    var q = Symbol.for("react.strict_mode");
    var r = Symbol.for("react.profiler");
    var t = Symbol.for("react.provider");
    var u = Symbol.for("react.context");
    var v = Symbol.for("react.forward_ref");
    var w = Symbol.for("react.suspense");
    var x = Symbol.for("react.memo");
    var y = Symbol.for("react.lazy");
    var z3 = Symbol.iterator;
    function A(a) {
      if (null === a || "object" !== typeof a)
        return null;
      a = z3 && a[z3] || a["@@iterator"];
      return "function" === typeof a ? a : null;
    }
    var B = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } };
    var C = Object.assign;
    var D = {};
    function E(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    E.prototype.isReactComponent = {};
    E.prototype.setState = function(a, b) {
      if ("object" !== typeof a && "function" !== typeof a && null != a)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a, b, "setState");
    };
    E.prototype.forceUpdate = function(a) {
      this.updater.enqueueForceUpdate(this, a, "forceUpdate");
    };
    function F() {
    }
    F.prototype = E.prototype;
    function G(a, b, e) {
      this.props = a;
      this.context = b;
      this.refs = D;
      this.updater = e || B;
    }
    var H = G.prototype = new F();
    H.constructor = G;
    C(H, E.prototype);
    H.isPureReactComponent = true;
    var I = Array.isArray;
    var J = Object.prototype.hasOwnProperty;
    var K = { current: null };
    var L = { key: true, ref: true, __self: true, __source: true };
    function M(a, b, e) {
      var d, c = {}, k = null, h = null;
      if (null != b)
        for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b)
          J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
      var g = arguments.length - 2;
      if (1 === g)
        c.children = e;
      else if (1 < g) {
        for (var f = Array(g), m = 0; m < g; m++)
          f[m] = arguments[m + 2];
        c.children = f;
      }
      if (a && a.defaultProps)
        for (d in g = a.defaultProps, g)
          void 0 === c[d] && (c[d] = g[d]);
      return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
    }
    function N(a, b) {
      return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
    }
    function O(a) {
      return "object" === typeof a && null !== a && a.$$typeof === l;
    }
    function escape2(a) {
      var b = { "=": "=0", ":": "=2" };
      return "$" + a.replace(/[=:]/g, function(a2) {
        return b[a2];
      });
    }
    var P = /\/+/g;
    function Q(a, b) {
      return "object" === typeof a && null !== a && null != a.key ? escape2("" + a.key) : b.toString(36);
    }
    function R(a, b, e, d, c) {
      var k = typeof a;
      if ("undefined" === k || "boolean" === k)
        a = null;
      var h = false;
      if (null === a)
        h = true;
      else
        switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
      if (h)
        return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
      h = 0;
      d = "" === d ? "." : d + ":";
      if (I(a))
        for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
      else if (f = A(a), "function" === typeof f)
        for (a = f.call(a), g = 0; !(k = a.next()).done; )
          k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
      else if ("object" === k)
        throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
      return h;
    }
    function S(a, b, e) {
      if (null == a)
        return a;
      var d = [], c = 0;
      R(a, d, "", "", function(a2) {
        return b.call(e, a2, c++);
      });
      return d;
    }
    function T(a) {
      if (-1 === a._status) {
        var b = a._result;
        b = b();
        b.then(function(b2) {
          if (0 === a._status || -1 === a._status)
            a._status = 1, a._result = b2;
        }, function(b2) {
          if (0 === a._status || -1 === a._status)
            a._status = 2, a._result = b2;
        });
        -1 === a._status && (a._status = 0, a._result = b);
      }
      if (1 === a._status)
        return a._result.default;
      throw a._result;
    }
    var U = { current: null };
    var V = { transition: null };
    var W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
    exports.Children = { map: S, forEach: function(a, b, e) {
      S(a, function() {
        b.apply(this, arguments);
      }, e);
    }, count: function(a) {
      var b = 0;
      S(a, function() {
        b++;
      });
      return b;
    }, toArray: function(a) {
      return S(a, function(a2) {
        return a2;
      }) || [];
    }, only: function(a) {
      if (!O(a))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a;
    } };
    exports.Component = E;
    exports.Fragment = p;
    exports.Profiler = r;
    exports.PureComponent = G;
    exports.StrictMode = q;
    exports.Suspense = w;
    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
    exports.cloneElement = function(a, b, e) {
      if (null === a || void 0 === a)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
      var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
      if (null != b) {
        void 0 !== b.ref && (k = b.ref, h = K.current);
        void 0 !== b.key && (c = "" + b.key);
        if (a.type && a.type.defaultProps)
          var g = a.type.defaultProps;
        for (f in b)
          J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
      }
      var f = arguments.length - 2;
      if (1 === f)
        d.children = e;
      else if (1 < f) {
        g = Array(f);
        for (var m = 0; m < f; m++)
          g[m] = arguments[m + 2];
        d.children = g;
      }
      return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
    };
    exports.createContext = function(a) {
      a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a.Provider = { $$typeof: t, _context: a };
      return a.Consumer = a;
    };
    exports.createElement = M;
    exports.createFactory = function(a) {
      var b = M.bind(null, a);
      b.type = a;
      return b;
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(a) {
      return { $$typeof: v, render: a };
    };
    exports.isValidElement = O;
    exports.lazy = function(a) {
      return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
    };
    exports.memo = function(a, b) {
      return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
    };
    exports.startTransition = function(a) {
      var b = V.transition;
      V.transition = {};
      try {
        a();
      } finally {
        V.transition = b;
      }
    };
    exports.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports.useCallback = function(a, b) {
      return U.current.useCallback(a, b);
    };
    exports.useContext = function(a) {
      return U.current.useContext(a);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(a) {
      return U.current.useDeferredValue(a);
    };
    exports.useEffect = function(a, b) {
      return U.current.useEffect(a, b);
    };
    exports.useId = function() {
      return U.current.useId();
    };
    exports.useImperativeHandle = function(a, b, e) {
      return U.current.useImperativeHandle(a, b, e);
    };
    exports.useInsertionEffect = function(a, b) {
      return U.current.useInsertionEffect(a, b);
    };
    exports.useLayoutEffect = function(a, b) {
      return U.current.useLayoutEffect(a, b);
    };
    exports.useMemo = function(a, b) {
      return U.current.useMemo(a, b);
    };
    exports.useReducer = function(a, b, e) {
      return U.current.useReducer(a, b, e);
    };
    exports.useRef = function(a) {
      return U.current.useRef(a);
    };
    exports.useState = function(a) {
      return U.current.useState(a);
    };
    exports.useSyncExternalStore = function(a, b, e) {
      return U.current.useSyncExternalStore(a, b, e);
    };
    exports.useTransition = function() {
      return U.current.useTransition();
    };
    exports.version = "18.2.0";
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV !== "production") {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var ReactVersion = "18.2.0";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: null
        };
        var ReactCurrentActQueue = {
          current: null,
          isBatchingLegacy: false,
          didScheduleLegacyUpdate: false
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
        }
        function warn(format) {
          {
            {
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              printWarning("warn", format, args);
            }
          }
        }
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var assign = Object.assign;
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component.prototype.isReactComponent = {};
        Component.prototype.setState = function(partialState, callback) {
          if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
            throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        assign(pureComponentPrototype, Component.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        var isArrayImpl = Array.isArray;
        function isArray(a) {
          return isArrayImpl(a);
        }
        function typeName(value) {
          {
            var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            return type;
          }
        }
        function willCoercionThrow(value) {
          {
            try {
              testStringCoercion(value);
              return false;
            } catch (e) {
              return true;
            }
          }
        }
        function testStringCoercion(value) {
          return "" + value;
        }
        function checkKeyStringCoercion(value) {
          {
            if (willCoercionThrow(value)) {
              error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
              return testStringCoercion(value);
            }
          }
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var displayName = outerType.displayName;
          if (displayName) {
            return displayName;
          }
          var functionName = innerType.displayName || innerType.name || "";
          return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentNameFromType(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                var outerName = type.displayName || null;
                if (outerName !== null) {
                  return outerName;
                }
                return getComponentNameFromType(type.type) || "Memo";
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentNameFromType(init(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config) {
          {
            if (hasOwnProperty.call(config, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.ref !== void 0;
        }
        function hasValidKey(config) {
          {
            if (hasOwnProperty.call(config, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config) {
          {
            if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement(type, config, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config);
              }
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            self2 = config.__self === void 0 ? null : config.__self;
            source = config.__source === void 0 ? null : config.__source;
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config, children) {
          if (element === null || element === void 0) {
            throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
          }
          var propName;
          var props = assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config != null) {
            if (hasValidRef(config)) {
              ref = config.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config)) {
              {
                checkKeyStringCoercion(config.key);
              }
              key = "" + config.key;
            }
            var defaultProps;
            if (element.type && element.type.defaultProps) {
              defaultProps = element.type.defaultProps;
            }
            for (propName in config) {
              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config[propName] === void 0 && defaultProps !== void 0) {
                  props[propName] = defaultProps[propName];
                } else {
                  props[propName] = config[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape2(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index) {
          if (typeof element === "object" && element !== null && element.key != null) {
            {
              checkKeyStringCoercion(element.key);
            }
            return escape2("" + element.key);
          }
          return index.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type = typeof children;
          if (type === "undefined" || type === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement(mappedChild)) {
                {
                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                    checkKeyStringCoercion(mappedChild.key);
                  }
                }
                mappedChild = cloneAndReplaceKey(
                  mappedChild,
                  escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
                );
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type === "object") {
              var childrenString = String(children);
              throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement(children)) {
            throw new Error("React.Children.only expected to receive a single React element child.");
          }
          return children;
        }
        function createContext(defaultValue) {
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
            _defaultValue: null,
            _globalName: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context
            };
            Object.defineProperties(Consumer, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            thenable.then(function(moduleObject2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = moduleObject2;
              }
            }, function(error2) {
              if (payload._status === Pending || payload._status === Uninitialized) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
            if (payload._status === Uninitialized) {
              var pending = payload;
              pending._status = Pending;
              pending._result = thenable;
            }
          }
          if (payload._status === Resolved) {
            var moduleObject = payload._result;
            {
              if (moduleObject === void 0) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
              }
            }
            {
              if (!("default" in moduleObject)) {
                error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
              }
            }
            return moduleObject.default;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: Uninitialized,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef(render) {
          {
            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render !== "function") {
              error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
            } else {
              if (render.length !== 0 && render.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render != null) {
              if (render.defaultProps != null || render.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!render.name && !render.displayName) {
                  render.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function memo(type, compare) {
          {
            if (!isValidElementType(type)) {
              error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type,
            compare: compare === void 0 ? null : compare
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (!type.name && !type.displayName) {
                  type.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          {
            if (dispatcher === null) {
              error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext(Context) {
          var dispatcher = resolveDispatcher();
          {
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context);
        }
        function useState(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init);
        }
        function useRef(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useInsertionEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useInsertionEffect(create, deps);
        }
        function useLayoutEffect(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        function useTransition() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useTransition();
        }
        function useDeferredValue(value) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDeferredValue(value);
        }
        function useId() {
          var dispatcher = resolveDispatcher();
          return dispatcher.useId();
        }
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: assign({}, props, {
                  value: prevLog
                }),
                info: assign({}, props, {
                  value: prevInfo
                }),
                warn: assign({}, props, {
                  value: prevWarn
                }),
                error: assign({}, props, {
                  value: prevError
                }),
                group: assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        if (fn.displayName && _frame.includes("<anonymous>")) {
                          _frame = _frame.replace("<anonymous>", fn.displayName);
                        }
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location, componentName, element) {
          {
            var has = Function.call.bind(hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type = element.type;
            if (type === null || type === void 0 || typeof type === "string") {
              return;
            }
            var propTypes;
            if (typeof type === "function") {
              propTypes = type.propTypes;
            } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentNameFromType(type);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentNameFromType(type);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys = Object.keys(fragment.props);
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type, props, children) {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type);
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type) {
          var validatedFactory = createElementWithValidation.bind(null, type);
          validatedFactory.type = type;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type
                });
                return type;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        function startTransition(scope, options) {
          var prevTransition = ReactCurrentBatchConfig.transition;
          ReactCurrentBatchConfig.transition = {};
          var currentTransition = ReactCurrentBatchConfig.transition;
          {
            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
          }
          try {
            scope();
          } finally {
            ReactCurrentBatchConfig.transition = prevTransition;
            {
              if (prevTransition === null && currentTransition._updatedFibers) {
                var updatedFibersCount = currentTransition._updatedFibers.size;
                if (updatedFibersCount > 10) {
                  warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                }
                currentTransition._updatedFibers.clear();
              }
            }
          }
        }
        var didWarnAboutMessageChannel = false;
        var enqueueTaskImpl = null;
        function enqueueTask(task) {
          if (enqueueTaskImpl === null) {
            try {
              var requireString = ("require" + Math.random()).slice(0, 7);
              var nodeRequire = module2 && module2[requireString];
              enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
            } catch (_err) {
              enqueueTaskImpl = function(callback) {
                {
                  if (didWarnAboutMessageChannel === false) {
                    didWarnAboutMessageChannel = true;
                    if (typeof MessageChannel === "undefined") {
                      error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                    }
                  }
                }
                var channel = new MessageChannel();
                channel.port1.onmessage = callback;
                channel.port2.postMessage(void 0);
              };
            }
          }
          return enqueueTaskImpl(task);
        }
        var actScopeDepth = 0;
        var didWarnNoAwaitAct = false;
        function act(callback) {
          {
            var prevActScopeDepth = actScopeDepth;
            actScopeDepth++;
            if (ReactCurrentActQueue.current === null) {
              ReactCurrentActQueue.current = [];
            }
            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
            var result;
            try {
              ReactCurrentActQueue.isBatchingLegacy = true;
              result = callback();
              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                var queue = ReactCurrentActQueue.current;
                if (queue !== null) {
                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                  flushActQueue(queue);
                }
              }
            } catch (error2) {
              popActScope(prevActScopeDepth);
              throw error2;
            } finally {
              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
            }
            if (result !== null && typeof result === "object" && typeof result.then === "function") {
              var thenableResult = result;
              var wasAwaited = false;
              var thenable = {
                then: function(resolve, reject) {
                  wasAwaited = true;
                  thenableResult.then(function(returnValue2) {
                    popActScope(prevActScopeDepth);
                    if (actScopeDepth === 0) {
                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                    } else {
                      resolve(returnValue2);
                    }
                  }, function(error2) {
                    popActScope(prevActScopeDepth);
                    reject(error2);
                  });
                }
              };
              {
                if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                  Promise.resolve().then(function() {
                  }).then(function() {
                    if (!wasAwaited) {
                      didWarnNoAwaitAct = true;
                      error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                    }
                  });
                }
              }
              return thenable;
            } else {
              var returnValue = result;
              popActScope(prevActScopeDepth);
              if (actScopeDepth === 0) {
                var _queue = ReactCurrentActQueue.current;
                if (_queue !== null) {
                  flushActQueue(_queue);
                  ReactCurrentActQueue.current = null;
                }
                var _thenable = {
                  then: function(resolve, reject) {
                    if (ReactCurrentActQueue.current === null) {
                      ReactCurrentActQueue.current = [];
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    } else {
                      resolve(returnValue);
                    }
                  }
                };
                return _thenable;
              } else {
                var _thenable2 = {
                  then: function(resolve, reject) {
                    resolve(returnValue);
                  }
                };
                return _thenable2;
              }
            }
          }
        }
        function popActScope(prevActScopeDepth) {
          {
            if (prevActScopeDepth !== actScopeDepth - 1) {
              error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
            }
            actScopeDepth = prevActScopeDepth;
          }
        }
        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
          {
            var queue = ReactCurrentActQueue.current;
            if (queue !== null) {
              try {
                flushActQueue(queue);
                enqueueTask(function() {
                  if (queue.length === 0) {
                    ReactCurrentActQueue.current = null;
                    resolve(returnValue);
                  } else {
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  }
                });
              } catch (error2) {
                reject(error2);
              }
            } else {
              resolve(returnValue);
            }
          }
        }
        var isFlushing = false;
        function flushActQueue(queue) {
          {
            if (!isFlushing) {
              isFlushing = true;
              var i = 0;
              try {
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(true);
                  } while (callback !== null);
                }
                queue.length = 0;
              } catch (error2) {
                queue = queue.slice(i + 1);
                throw error2;
              } finally {
                isFlushing = false;
              }
            }
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children;
        exports.Component = Component;
        exports.Fragment = REACT_FRAGMENT_TYPE;
        exports.Profiler = REACT_PROFILER_TYPE;
        exports.PureComponent = PureComponent;
        exports.StrictMode = REACT_STRICT_MODE_TYPE;
        exports.Suspense = REACT_SUSPENSE_TYPE;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef;
        exports.isValidElement = isValidElement;
        exports.lazy = lazy;
        exports.memo = memo;
        exports.startTransition = startTransition;
        exports.unstable_act = act;
        exports.useCallback = useCallback;
        exports.useContext = useContext;
        exports.useDebugValue = useDebugValue;
        exports.useDeferredValue = useDeferredValue;
        exports.useEffect = useEffect;
        exports.useId = useId;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useInsertionEffect = useInsertionEffect;
        exports.useLayoutEffect = useLayoutEffect;
        exports.useMemo = useMemo;
        exports.useReducer = useReducer;
        exports.useRef = useRef;
        exports.useState = useState;
        exports.useSyncExternalStore = useSyncExternalStore;
        exports.useTransition = useTransition;
        exports.version = ReactVersion;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_production_min();
    } else {
      module2.exports = require_react_development();
    }
  }
});

// node_modules/history/umd/history.production.min.js
var require_history_production_min = __commonJS({
  "node_modules/history/umd/history.production.min.js"(exports, module2) {
    !function(t, n) {
      "object" == typeof exports && "undefined" != typeof module2 ? n(exports) : "function" == typeof define && define.amd ? define(["exports"], n) : n((t = "undefined" != typeof globalThis ? globalThis : t || self).HistoryLibrary = {});
    }(exports, function(t) {
      "use strict";
      function n() {
        return (n = Object.assign || function(t2) {
          for (var n2 = 1; n2 < arguments.length; n2++) {
            var e2 = arguments[n2];
            for (var r2 in e2)
              Object.prototype.hasOwnProperty.call(e2, r2) && (t2[r2] = e2[r2]);
          }
          return t2;
        }).apply(this, arguments);
      }
      var e;
      t.Action = void 0, (e = t.Action || (t.Action = {})).Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE";
      var r = "beforeunload", o = "popstate";
      function a(t2, n2, e2) {
        return Math.min(Math.max(t2, n2), e2);
      }
      function i(t2) {
        t2.preventDefault(), t2.returnValue = "";
      }
      function c() {
        var t2 = [];
        return { get length() {
          return t2.length;
        }, push: function(n2) {
          return t2.push(n2), function() {
            t2 = t2.filter(function(t3) {
              return t3 !== n2;
            });
          };
        }, call: function(n2) {
          t2.forEach(function(t3) {
            return t3 && t3(n2);
          });
        } };
      }
      function u() {
        return Math.random().toString(36).substr(2, 8);
      }
      function l(t2) {
        var n2 = t2.pathname, e2 = void 0 === n2 ? "/" : n2, r2 = t2.search, o2 = void 0 === r2 ? "" : r2, a2 = t2.hash, i2 = void 0 === a2 ? "" : a2;
        return o2 && "?" !== o2 && (e2 += "?" === o2.charAt(0) ? o2 : "?" + o2), i2 && "#" !== i2 && (e2 += "#" === i2.charAt(0) ? i2 : "#" + i2), e2;
      }
      function f(t2) {
        var n2 = {};
        if (t2) {
          var e2 = t2.indexOf("#");
          e2 >= 0 && (n2.hash = t2.substr(e2), t2 = t2.substr(0, e2));
          var r2 = t2.indexOf("?");
          r2 >= 0 && (n2.search = t2.substr(r2), t2 = t2.substr(0, r2)), t2 && (n2.pathname = t2);
        }
        return n2;
      }
      t.createBrowserHistory = function(e2) {
        void 0 === e2 && (e2 = {});
        var a2 = e2.window, s = void 0 === a2 ? document.defaultView : a2, h = s.history;
        function p() {
          var t2 = s.location, n2 = t2.pathname, e3 = t2.search, r2 = t2.hash, o2 = h.state || {};
          return [o2.idx, { pathname: n2, search: e3, hash: r2, state: o2.usr || null, key: o2.key || "default" }];
        }
        var v = null;
        s.addEventListener(o, function() {
          if (v)
            A.call(v), v = null;
          else {
            var n2 = t.Action.Pop, e3 = p(), r2 = e3[0], o2 = e3[1];
            if (A.length) {
              if (null != r2) {
                var a3 = y - r2;
                a3 && (v = { action: n2, location: o2, retry: function() {
                  H(-1 * a3);
                } }, H(a3));
              }
            } else
              E(n2);
          }
        });
        var d = t.Action.Pop, g = p(), y = g[0], m = g[1], b = c(), A = c();
        function P(t2) {
          return "string" == typeof t2 ? t2 : l(t2);
        }
        function k(t2, e3) {
          return void 0 === e3 && (e3 = null), n({ pathname: m.pathname, hash: "", search: "" }, "string" == typeof t2 ? f(t2) : t2, { state: e3, key: u() });
        }
        function x(t2, n2) {
          return [{ usr: t2.state, key: t2.key, idx: n2 }, P(t2)];
        }
        function w(t2, n2, e3) {
          return !A.length || (A.call({ action: t2, location: n2, retry: e3 }), false);
        }
        function E(t2) {
          d = t2;
          var n2 = p();
          y = n2[0], m = n2[1], b.call({ action: d, location: m });
        }
        function H(t2) {
          h.go(t2);
        }
        return null == y && (y = 0, h.replaceState(n({}, h.state, { idx: y }), "")), { get action() {
          return d;
        }, get location() {
          return m;
        }, createHref: P, push: function n2(e3, r2) {
          var o2 = t.Action.Push, a3 = k(e3, r2);
          if (w(o2, a3, function() {
            n2(e3, r2);
          })) {
            var i2 = x(a3, y + 1), c2 = i2[0], u2 = i2[1];
            try {
              h.pushState(c2, "", u2);
            } catch (t2) {
              s.location.assign(u2);
            }
            E(o2);
          }
        }, replace: function n2(e3, r2) {
          var o2 = t.Action.Replace, a3 = k(e3, r2);
          if (w(o2, a3, function() {
            n2(e3, r2);
          })) {
            var i2 = x(a3, y), c2 = i2[0], u2 = i2[1];
            h.replaceState(c2, "", u2), E(o2);
          }
        }, go: H, back: function() {
          H(-1);
        }, forward: function() {
          H(1);
        }, listen: function(t2) {
          return b.push(t2);
        }, block: function(t2) {
          var n2 = A.push(t2);
          return 1 === A.length && s.addEventListener(r, i), function() {
            n2(), A.length || s.removeEventListener(r, i);
          };
        } };
      }, t.createHashHistory = function(e2) {
        void 0 === e2 && (e2 = {});
        var a2 = e2.window, s = void 0 === a2 ? document.defaultView : a2, h = s.history;
        function p() {
          var t2 = f(s.location.hash.substr(1)), n2 = t2.pathname, e3 = void 0 === n2 ? "/" : n2, r2 = t2.search, o2 = void 0 === r2 ? "" : r2, a3 = t2.hash, i2 = void 0 === a3 ? "" : a3, c2 = h.state || {};
          return [c2.idx, { pathname: e3, search: o2, hash: i2, state: c2.usr || null, key: c2.key || "default" }];
        }
        var v = null;
        function d() {
          if (v)
            P.call(v), v = null;
          else {
            var n2 = t.Action.Pop, e3 = p(), r2 = e3[0], o2 = e3[1];
            if (P.length) {
              if (null != r2) {
                var a3 = m - r2;
                a3 && (v = { action: n2, location: o2, retry: function() {
                  L(-1 * a3);
                } }, L(a3));
              }
            } else
              H(n2);
          }
        }
        s.addEventListener(o, d), s.addEventListener("hashchange", function() {
          l(p()[1]) !== l(b) && d();
        });
        var g = t.Action.Pop, y = p(), m = y[0], b = y[1], A = c(), P = c();
        function k(t2) {
          return function() {
            var t3 = document.querySelector("base"), n2 = "";
            if (t3 && t3.getAttribute("href")) {
              var e3 = s.location.href, r2 = e3.indexOf("#");
              n2 = -1 === r2 ? e3 : e3.slice(0, r2);
            }
            return n2;
          }() + "#" + ("string" == typeof t2 ? t2 : l(t2));
        }
        function x(t2, e3) {
          return void 0 === e3 && (e3 = null), n({ pathname: b.pathname, hash: "", search: "" }, "string" == typeof t2 ? f(t2) : t2, { state: e3, key: u() });
        }
        function w(t2, n2) {
          return [{ usr: t2.state, key: t2.key, idx: n2 }, k(t2)];
        }
        function E(t2, n2, e3) {
          return !P.length || (P.call({ action: t2, location: n2, retry: e3 }), false);
        }
        function H(t2) {
          g = t2;
          var n2 = p();
          m = n2[0], b = n2[1], A.call({ action: g, location: b });
        }
        function L(t2) {
          h.go(t2);
        }
        return null == m && (m = 0, h.replaceState(n({}, h.state, { idx: m }), "")), { get action() {
          return g;
        }, get location() {
          return b;
        }, createHref: k, push: function n2(e3, r2) {
          var o2 = t.Action.Push, a3 = x(e3, r2);
          if (E(o2, a3, function() {
            n2(e3, r2);
          })) {
            var i2 = w(a3, m + 1), c2 = i2[0], u2 = i2[1];
            try {
              h.pushState(c2, "", u2);
            } catch (t2) {
              s.location.assign(u2);
            }
            H(o2);
          }
        }, replace: function n2(e3, r2) {
          var o2 = t.Action.Replace, a3 = x(e3, r2);
          if (E(o2, a3, function() {
            n2(e3, r2);
          })) {
            var i2 = w(a3, m), c2 = i2[0], u2 = i2[1];
            h.replaceState(c2, "", u2), H(o2);
          }
        }, go: L, back: function() {
          L(-1);
        }, forward: function() {
          L(1);
        }, listen: function(t2) {
          return A.push(t2);
        }, block: function(t2) {
          var n2 = P.push(t2);
          return 1 === P.length && s.addEventListener(r, i), function() {
            n2(), P.length || s.removeEventListener(r, i);
          };
        } };
      }, t.createMemoryHistory = function(e2) {
        void 0 === e2 && (e2 = {});
        var r2 = e2, o2 = r2.initialEntries, i2 = void 0 === o2 ? ["/"] : o2, s = r2.initialIndex, h = i2.map(function(t2) {
          return n({ pathname: "/", search: "", hash: "", state: null, key: u() }, "string" == typeof t2 ? f(t2) : t2);
        }), p = a(null == s ? h.length - 1 : s, 0, h.length - 1), v = t.Action.Pop, d = h[p], g = c(), y = c();
        function m(t2, e3) {
          return void 0 === e3 && (e3 = null), n({ pathname: d.pathname, search: "", hash: "" }, "string" == typeof t2 ? f(t2) : t2, { state: e3, key: u() });
        }
        function b(t2, n2, e3) {
          return !y.length || (y.call({ action: t2, location: n2, retry: e3 }), false);
        }
        function A(t2, n2) {
          v = t2, d = n2, g.call({ action: v, location: d });
        }
        function P(n2) {
          var e3 = a(p + n2, 0, h.length - 1), r3 = t.Action.Pop, o3 = h[e3];
          b(r3, o3, function() {
            P(n2);
          }) && (p = e3, A(r3, o3));
        }
        return { get index() {
          return p;
        }, get action() {
          return v;
        }, get location() {
          return d;
        }, createHref: function(t2) {
          return "string" == typeof t2 ? t2 : l(t2);
        }, push: function n2(e3, r3) {
          var o3 = t.Action.Push, a2 = m(e3, r3);
          b(o3, a2, function() {
            n2(e3, r3);
          }) && (p += 1, h.splice(p, h.length, a2), A(o3, a2));
        }, replace: function n2(e3, r3) {
          var o3 = t.Action.Replace, a2 = m(e3, r3);
          b(o3, a2, function() {
            n2(e3, r3);
          }) && (h[p] = a2, A(o3, a2));
        }, go: P, back: function() {
          P(-1);
        }, forward: function() {
          P(1);
        }, listen: function(t2) {
          return g.push(t2);
        }, block: function(t2) {
          return y.push(t2);
        } };
      }, t.createPath = l, t.parsePath = f, Object.defineProperty(t, "__esModule", { value: true });
    });
  }
});

// node_modules/history/umd/history.development.js
var require_history_development = __commonJS({
  "node_modules/history/umd/history.development.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.HistoryLibrary = {}));
    })(exports, function(exports2) {
      "use strict";
      function _extends() {
        _extends = Object.assign || function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      exports2.Action = void 0;
      (function(Action) {
        Action["Pop"] = "POP";
        Action["Push"] = "PUSH";
        Action["Replace"] = "REPLACE";
      })(exports2.Action || (exports2.Action = {}));
      var readOnly = function(obj) {
        return Object.freeze(obj);
      };
      function warning(cond, message) {
        if (!cond) {
          if (typeof console !== "undefined")
            console.warn(message);
          try {
            throw new Error(message);
          } catch (e) {
          }
        }
      }
      var BeforeUnloadEventType = "beforeunload";
      var HashChangeEventType = "hashchange";
      var PopStateEventType = "popstate";
      function createBrowserHistory(options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$window = _options.window, window = _options$window === void 0 ? document.defaultView : _options$window;
        var globalHistory = window.history;
        function getIndexAndLocation() {
          var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
          var state = globalHistory.state || {};
          return [state.idx, readOnly({
            pathname,
            search,
            hash,
            state: state.usr || null,
            key: state.key || "default"
          })];
        }
        var blockedPopTx = null;
        function handlePop() {
          if (blockedPopTx) {
            blockers.call(blockedPopTx);
            blockedPopTx = null;
          } else {
            var nextAction = exports2.Action.Pop;
            var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
            if (blockers.length) {
              if (nextIndex != null) {
                var delta = index - nextIndex;
                if (delta) {
                  blockedPopTx = {
                    action: nextAction,
                    location: nextLocation,
                    retry: function retry() {
                      go(delta * -1);
                    }
                  };
                  go(delta);
                }
              } else {
                warning(
                  false,
                  "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation."
                );
              }
            } else {
              applyTx(nextAction);
            }
          }
        }
        window.addEventListener(PopStateEventType, handlePop);
        var action = exports2.Action.Pop;
        var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location = _getIndexAndLocation2[1];
        var listeners = createEvents();
        var blockers = createEvents();
        if (index == null) {
          index = 0;
          globalHistory.replaceState(_extends({}, globalHistory.state, {
            idx: index
          }), "");
        }
        function createHref(to) {
          return typeof to === "string" ? to : createPath(to);
        }
        function getNextLocation(to, state) {
          if (state === void 0) {
            state = null;
          }
          return readOnly(_extends({
            pathname: location.pathname,
            hash: "",
            search: ""
          }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
          }));
        }
        function getHistoryStateAndUrl(nextLocation, index2) {
          return [{
            usr: nextLocation.state,
            key: nextLocation.key,
            idx: index2
          }, createHref(nextLocation)];
        }
        function allowTx(action2, location2, retry) {
          return !blockers.length || (blockers.call({
            action: action2,
            location: location2,
            retry
          }), false);
        }
        function applyTx(nextAction) {
          action = nextAction;
          var _getIndexAndLocation3 = getIndexAndLocation();
          index = _getIndexAndLocation3[0];
          location = _getIndexAndLocation3[1];
          listeners.call({
            action,
            location
          });
        }
        function push(to, state) {
          var nextAction = exports2.Action.Push;
          var nextLocation = getNextLocation(to, state);
          function retry() {
            push(to, state);
          }
          if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
            try {
              globalHistory.pushState(historyState, "", url);
            } catch (error) {
              window.location.assign(url);
            }
            applyTx(nextAction);
          }
        }
        function replace(to, state) {
          var nextAction = exports2.Action.Replace;
          var nextLocation = getNextLocation(to, state);
          function retry() {
            replace(to, state);
          }
          if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
            globalHistory.replaceState(historyState, "", url);
            applyTx(nextAction);
          }
        }
        function go(delta) {
          globalHistory.go(delta);
        }
        var history = {
          get action() {
            return action;
          },
          get location() {
            return location;
          },
          createHref,
          push,
          replace,
          go,
          back: function back() {
            go(-1);
          },
          forward: function forward() {
            go(1);
          },
          listen: function listen(listener) {
            return listeners.push(listener);
          },
          block: function block(blocker) {
            var unblock = blockers.push(blocker);
            if (blockers.length === 1) {
              window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
            return function() {
              unblock();
              if (!blockers.length) {
                window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
              }
            };
          }
        };
        return history;
      }
      function createHashHistory(options) {
        if (options === void 0) {
          options = {};
        }
        var _options2 = options, _options2$window = _options2.window, window = _options2$window === void 0 ? document.defaultView : _options2$window;
        var globalHistory = window.history;
        function getIndexAndLocation() {
          var _parsePath = parsePath(window.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;
          var state = globalHistory.state || {};
          return [state.idx, readOnly({
            pathname,
            search,
            hash,
            state: state.usr || null,
            key: state.key || "default"
          })];
        }
        var blockedPopTx = null;
        function handlePop() {
          if (blockedPopTx) {
            blockers.call(blockedPopTx);
            blockedPopTx = null;
          } else {
            var nextAction = exports2.Action.Pop;
            var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
            if (blockers.length) {
              if (nextIndex != null) {
                var delta = index - nextIndex;
                if (delta) {
                  blockedPopTx = {
                    action: nextAction,
                    location: nextLocation,
                    retry: function retry() {
                      go(delta * -1);
                    }
                  };
                  go(delta);
                }
              } else {
                warning(
                  false,
                  "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation."
                );
              }
            } else {
              applyTx(nextAction);
            }
          }
        }
        window.addEventListener(PopStateEventType, handlePop);
        window.addEventListener(HashChangeEventType, function() {
          var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
          if (createPath(nextLocation) !== createPath(location)) {
            handlePop();
          }
        });
        var action = exports2.Action.Pop;
        var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location = _getIndexAndLocation6[1];
        var listeners = createEvents();
        var blockers = createEvents();
        if (index == null) {
          index = 0;
          globalHistory.replaceState(_extends({}, globalHistory.state, {
            idx: index
          }), "");
        }
        function getBaseHref() {
          var base = document.querySelector("base");
          var href = "";
          if (base && base.getAttribute("href")) {
            var url = window.location.href;
            var hashIndex = url.indexOf("#");
            href = hashIndex === -1 ? url : url.slice(0, hashIndex);
          }
          return href;
        }
        function createHref(to) {
          return getBaseHref() + "#" + (typeof to === "string" ? to : createPath(to));
        }
        function getNextLocation(to, state) {
          if (state === void 0) {
            state = null;
          }
          return readOnly(_extends({
            pathname: location.pathname,
            hash: "",
            search: ""
          }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
          }));
        }
        function getHistoryStateAndUrl(nextLocation, index2) {
          return [{
            usr: nextLocation.state,
            key: nextLocation.key,
            idx: index2
          }, createHref(nextLocation)];
        }
        function allowTx(action2, location2, retry) {
          return !blockers.length || (blockers.call({
            action: action2,
            location: location2,
            retry
          }), false);
        }
        function applyTx(nextAction) {
          action = nextAction;
          var _getIndexAndLocation7 = getIndexAndLocation();
          index = _getIndexAndLocation7[0];
          location = _getIndexAndLocation7[1];
          listeners.call({
            action,
            location
          });
        }
        function push(to, state) {
          var nextAction = exports2.Action.Push;
          var nextLocation = getNextLocation(to, state);
          function retry() {
            push(to, state);
          }
          warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")");
          if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
            try {
              globalHistory.pushState(historyState, "", url);
            } catch (error) {
              window.location.assign(url);
            }
            applyTx(nextAction);
          }
        }
        function replace(to, state) {
          var nextAction = exports2.Action.Replace;
          var nextLocation = getNextLocation(to, state);
          function retry() {
            replace(to, state);
          }
          warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to) + ")");
          if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
            globalHistory.replaceState(historyState, "", url);
            applyTx(nextAction);
          }
        }
        function go(delta) {
          globalHistory.go(delta);
        }
        var history = {
          get action() {
            return action;
          },
          get location() {
            return location;
          },
          createHref,
          push,
          replace,
          go,
          back: function back() {
            go(-1);
          },
          forward: function forward() {
            go(1);
          },
          listen: function listen(listener) {
            return listeners.push(listener);
          },
          block: function block(blocker) {
            var unblock = blockers.push(blocker);
            if (blockers.length === 1) {
              window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
            return function() {
              unblock();
              if (!blockers.length) {
                window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
              }
            };
          }
        };
        return history;
      }
      function createMemoryHistory(options) {
        if (options === void 0) {
          options = {};
        }
        var _options3 = options, _options3$initialEntr = _options3.initialEntries, initialEntries = _options3$initialEntr === void 0 ? ["/"] : _options3$initialEntr, initialIndex = _options3.initialIndex;
        var entries = initialEntries.map(function(entry) {
          var location2 = readOnly(_extends({
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: createKey()
          }, typeof entry === "string" ? parsePath(entry) : entry));
          warning(location2.pathname.charAt(0) === "/", "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(entry) + ")");
          return location2;
        });
        var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);
        var action = exports2.Action.Pop;
        var location = entries[index];
        var listeners = createEvents();
        var blockers = createEvents();
        function createHref(to) {
          return typeof to === "string" ? to : createPath(to);
        }
        function getNextLocation(to, state) {
          if (state === void 0) {
            state = null;
          }
          return readOnly(_extends({
            pathname: location.pathname,
            search: "",
            hash: ""
          }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
          }));
        }
        function allowTx(action2, location2, retry) {
          return !blockers.length || (blockers.call({
            action: action2,
            location: location2,
            retry
          }), false);
        }
        function applyTx(nextAction, nextLocation) {
          action = nextAction;
          location = nextLocation;
          listeners.call({
            action,
            location
          });
        }
        function push(to, state) {
          var nextAction = exports2.Action.Push;
          var nextLocation = getNextLocation(to, state);
          function retry() {
            push(to, state);
          }
          warning(location.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.push(" + JSON.stringify(to) + ")");
          if (allowTx(nextAction, nextLocation, retry)) {
            index += 1;
            entries.splice(index, entries.length, nextLocation);
            applyTx(nextAction, nextLocation);
          }
        }
        function replace(to, state) {
          var nextAction = exports2.Action.Replace;
          var nextLocation = getNextLocation(to, state);
          function retry() {
            replace(to, state);
          }
          warning(location.pathname.charAt(0) === "/", "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(to) + ")");
          if (allowTx(nextAction, nextLocation, retry)) {
            entries[index] = nextLocation;
            applyTx(nextAction, nextLocation);
          }
        }
        function go(delta) {
          var nextIndex = clamp(index + delta, 0, entries.length - 1);
          var nextAction = exports2.Action.Pop;
          var nextLocation = entries[nextIndex];
          function retry() {
            go(delta);
          }
          if (allowTx(nextAction, nextLocation, retry)) {
            index = nextIndex;
            applyTx(nextAction, nextLocation);
          }
        }
        var history = {
          get index() {
            return index;
          },
          get action() {
            return action;
          },
          get location() {
            return location;
          },
          createHref,
          push,
          replace,
          go,
          back: function back() {
            go(-1);
          },
          forward: function forward() {
            go(1);
          },
          listen: function listen(listener) {
            return listeners.push(listener);
          },
          block: function block(blocker) {
            return blockers.push(blocker);
          }
        };
        return history;
      }
      function clamp(n, lowerBound, upperBound) {
        return Math.min(Math.max(n, lowerBound), upperBound);
      }
      function promptBeforeUnload(event) {
        event.preventDefault();
        event.returnValue = "";
      }
      function createEvents() {
        var handlers = [];
        return {
          get length() {
            return handlers.length;
          },
          push: function push(fn) {
            handlers.push(fn);
            return function() {
              handlers = handlers.filter(function(handler) {
                return handler !== fn;
              });
            };
          },
          call: function call(arg) {
            handlers.forEach(function(fn) {
              return fn && fn(arg);
            });
          }
        };
      }
      function createKey() {
        return Math.random().toString(36).substr(2, 8);
      }
      function createPath(_ref) {
        var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
        if (search && search !== "?")
          pathname += search.charAt(0) === "?" ? search : "?" + search;
        if (hash && hash !== "#")
          pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
        return pathname;
      }
      function parsePath(path) {
        var parsedPath = {};
        if (path) {
          var hashIndex = path.indexOf("#");
          if (hashIndex >= 0) {
            parsedPath.hash = path.substr(hashIndex);
            path = path.substr(0, hashIndex);
          }
          var searchIndex = path.indexOf("?");
          if (searchIndex >= 0) {
            parsedPath.search = path.substr(searchIndex);
            path = path.substr(0, searchIndex);
          }
          if (path) {
            parsedPath.pathname = path;
          }
        }
        return parsedPath;
      }
      exports2.createBrowserHistory = createBrowserHistory;
      exports2.createHashHistory = createHashHistory;
      exports2.createMemoryHistory = createMemoryHistory;
      exports2.createPath = createPath;
      exports2.parsePath = parsePath;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/history/main.js
var require_main = __commonJS({
  "node_modules/history/main.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_history_production_min();
    } else {
      module2.exports = require_history_development();
    }
  }
});

// node_modules/react-router/umd/react-router.production.min.js
var require_react_router_production_min = __commonJS({
  "node_modules/react-router/umd/react-router.production.min.js"(exports, module2) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module2 ? t(exports, require_main(), require_react()) : "function" == typeof define && define.amd ? define(["exports", "history", "react"], t) : t((e = e || self).ReactRouter = {}, e.HistoryLibrary, e.React);
    }(exports, function(e, t, n) {
      "use strict";
      const a = n.createContext(null), r = n.createContext(null), i = n.createContext({ outlet: null, matches: [] });
      function l(e2, t2) {
        if (!e2)
          throw new Error(t2);
      }
      function o(e2, n2, a2) {
        void 0 === a2 && (a2 = "/");
        let r2 = g(("string" == typeof n2 ? t.parsePath(n2) : n2).pathname || "/", a2);
        if (null == r2)
          return null;
        let i2 = s(e2);
        !function(e3) {
          e3.sort((e4, t2) => e4.score !== t2.score ? t2.score - e4.score : function(e5, t3) {
            return e5.length === t3.length && e5.slice(0, -1).every((e6, n3) => e6 === t3[n3]) ? e5[e5.length - 1] - t3[t3.length - 1] : 0;
          }(e4.routesMeta.map((e5) => e5.childrenIndex), t2.routesMeta.map((e5) => e5.childrenIndex)));
        }(i2);
        let l2 = null;
        for (let e3 = 0; null == l2 && e3 < i2.length; ++e3)
          l2 = p(i2[e3], r2);
        return l2;
      }
      function s(e2, t2, n2, a2) {
        return void 0 === t2 && (t2 = []), void 0 === n2 && (n2 = []), void 0 === a2 && (a2 = ""), e2.forEach((e3, r2) => {
          let i2 = { relativePath: e3.path || "", caseSensitive: true === e3.caseSensitive, childrenIndex: r2, route: e3 };
          i2.relativePath.startsWith("/") && (i2.relativePath.startsWith(a2) || l(false), i2.relativePath = i2.relativePath.slice(a2.length));
          let o2 = v([a2, i2.relativePath]), u2 = n2.concat(i2);
          e3.children && e3.children.length > 0 && (true === e3.index && l(false), s(e3.children, t2, u2, o2)), (null != e3.path || e3.index) && t2.push({ path: o2, score: h(o2, e3.index), routesMeta: u2 });
        }), t2;
      }
      const u = /^:\w+$/, c = (e2) => "*" === e2;
      function h(e2, t2) {
        let n2 = e2.split("/"), a2 = n2.length;
        return n2.some(c) && (a2 += -2), t2 && (a2 += 2), n2.filter((e3) => !c(e3)).reduce((e3, t3) => e3 + (u.test(t3) ? 3 : "" === t3 ? 1 : 10), a2);
      }
      function p(e2, t2) {
        let { routesMeta: n2 } = e2, a2 = {}, r2 = "/", i2 = [];
        for (let e3 = 0; e3 < n2.length; ++e3) {
          let l2 = n2[e3], o2 = e3 === n2.length - 1, s2 = "/" === r2 ? t2 : t2.slice(r2.length) || "/", u2 = f({ path: l2.relativePath, caseSensitive: l2.caseSensitive, end: o2 }, s2);
          if (!u2)
            return null;
          Object.assign(a2, u2.params);
          let c2 = l2.route;
          i2.push({ params: a2, pathname: v([r2, u2.pathname]), pathnameBase: y(v([r2, u2.pathnameBase])), route: c2 }), "/" !== u2.pathnameBase && (r2 = v([r2, u2.pathnameBase]));
        }
        return i2;
      }
      function f(e2, t2) {
        "string" == typeof e2 && (e2 = { path: e2, caseSensitive: false, end: true });
        let [n2, a2] = function(e3, t3, n3) {
          void 0 === t3 && (t3 = false);
          void 0 === n3 && (n3 = true);
          let a3 = [], r3 = "^" + e3.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (e4, t4) => (a3.push(t4), "([^\\/]+)"));
          e3.endsWith("*") ? (a3.push("*"), r3 += "*" === e3 || "/*" === e3 ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r3 += n3 ? "\\/*$" : "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
          return [new RegExp(r3, t3 ? void 0 : "i"), a3];
        }(e2.path, e2.caseSensitive, e2.end), r2 = t2.match(n2);
        if (!r2)
          return null;
        let i2 = r2[0], l2 = i2.replace(/(.)\/+$/, "$1"), o2 = r2.slice(1);
        return { params: a2.reduce((e3, t3, n3) => {
          if ("*" === t3) {
            let e4 = o2[n3] || "";
            l2 = i2.slice(0, i2.length - e4.length).replace(/(.)\/+$/, "$1");
          }
          return e3[t3] = function(e4, t4) {
            try {
              return decodeURIComponent(e4);
            } catch (t5) {
              return e4;
            }
          }(o2[n3] || ""), e3;
        }, {}), pathname: i2, pathnameBase: l2, pattern: e2 };
      }
      function m(e2, n2) {
        void 0 === n2 && (n2 = "/");
        let { pathname: a2, search: r2 = "", hash: i2 = "" } = "string" == typeof e2 ? t.parsePath(e2) : e2, l2 = a2 ? a2.startsWith("/") ? a2 : function(e3, t2) {
          let n3 = t2.replace(/\/+$/, "").split("/");
          return e3.split("/").forEach((e4) => {
            ".." === e4 ? n3.length > 1 && n3.pop() : "." !== e4 && n3.push(e4);
          }), n3.length > 1 ? n3.join("/") : "/";
        }(a2, n2) : n2;
        return { pathname: l2, search: x(r2), hash: P(i2) };
      }
      function d(e2, n2, a2) {
        let r2, i2 = "string" == typeof e2 ? t.parsePath(e2) : e2, l2 = "" === e2 || "" === i2.pathname ? "/" : i2.pathname;
        if (null == l2)
          r2 = a2;
        else {
          let e3 = n2.length - 1;
          if (l2.startsWith("..")) {
            let t2 = l2.split("/");
            for (; ".." === t2[0]; )
              t2.shift(), e3 -= 1;
            i2.pathname = t2.join("/");
          }
          r2 = e3 >= 0 ? n2[e3] : "/";
        }
        let o2 = m(i2, r2);
        return l2 && "/" !== l2 && l2.endsWith("/") && !o2.pathname.endsWith("/") && (o2.pathname += "/"), o2;
      }
      function g(e2, t2) {
        if ("/" === t2)
          return e2;
        if (!e2.toLowerCase().startsWith(t2.toLowerCase()))
          return null;
        let n2 = e2.charAt(t2.length);
        return n2 && "/" !== n2 ? null : e2.slice(t2.length) || "/";
      }
      const v = (e2) => e2.join("/").replace(/\/\/+/g, "/"), y = (e2) => e2.replace(/\/+$/, "").replace(/^\/*/, "/"), x = (e2) => e2 && "?" !== e2 ? e2.startsWith("?") ? e2 : "?" + e2 : "", P = (e2) => e2 && "#" !== e2 ? e2.startsWith("#") ? e2 : "#" + e2 : "";
      function C() {
        return null != n.useContext(r);
      }
      function b() {
        return C() || l(false), n.useContext(r).location;
      }
      function E() {
        C() || l(false);
        let { basename: e2, navigator: t2 } = n.useContext(a), { matches: r2 } = n.useContext(i), { pathname: o2 } = b(), s2 = JSON.stringify(r2.map((e3) => e3.pathnameBase)), u2 = n.useRef(false);
        return n.useEffect(() => {
          u2.current = true;
        }), n.useCallback(function(n2, a2) {
          if (void 0 === a2 && (a2 = {}), !u2.current)
            return;
          if ("number" == typeof n2)
            return void t2.go(n2);
          let r3 = d(n2, JSON.parse(s2), o2);
          "/" !== e2 && (r3.pathname = v([e2, r3.pathname])), (a2.replace ? t2.replace : t2.push)(r3, a2.state);
        }, [e2, t2, s2, o2]);
      }
      const R = n.createContext(null);
      function S(e2) {
        let t2 = n.useContext(i).outlet;
        return t2 ? n.createElement(R.Provider, { value: e2 }, t2) : t2;
      }
      function $(e2) {
        let { matches: t2 } = n.useContext(i), { pathname: a2 } = b(), r2 = JSON.stringify(t2.map((e3) => e3.pathnameBase));
        return n.useMemo(() => d(e2, JSON.parse(r2), a2), [e2, r2, a2]);
      }
      function O(e2, a2) {
        C() || l(false);
        let r2, { matches: s2 } = n.useContext(i), u2 = s2[s2.length - 1], c2 = u2 ? u2.params : {}, h2 = (u2 && u2.pathname, u2 ? u2.pathnameBase : "/"), p2 = (u2 && u2.route, b());
        if (a2) {
          var f2;
          let e3 = "string" == typeof a2 ? t.parsePath(a2) : a2;
          "/" === h2 || (null == (f2 = e3.pathname) ? void 0 : f2.startsWith(h2)) || l(false), r2 = e3;
        } else
          r2 = p2;
        let m2 = r2.pathname || "/", d2 = o(e2, { pathname: "/" === h2 ? m2 : m2.slice(h2.length) || "/" });
        return M(d2 && d2.map((e3) => Object.assign({}, e3, { params: Object.assign({}, c2, e3.params), pathname: v([h2, e3.pathname]), pathnameBase: "/" === e3.pathnameBase ? h2 : v([h2, e3.pathnameBase]) })), s2);
      }
      function M(e2, t2) {
        return void 0 === t2 && (t2 = []), null == e2 ? null : e2.reduceRight((a2, r2, l2) => n.createElement(i.Provider, { children: void 0 !== r2.route.element ? r2.route.element : a2, value: { outlet: a2, matches: t2.concat(e2.slice(0, l2 + 1)) } }), null);
      }
      function N(e2) {
        l(false);
      }
      function W(e2) {
        let { basename: i2 = "/", children: o2 = null, location: s2, navigationType: u2 = t.Action.Pop, navigator: c2, static: h2 = false } = e2;
        C() && l(false);
        let p2 = y(i2), f2 = n.useMemo(() => ({ basename: p2, navigator: c2, static: h2 }), [p2, c2, h2]);
        "string" == typeof s2 && (s2 = t.parsePath(s2));
        let { pathname: m2 = "/", search: d2 = "", hash: v2 = "", state: x2 = null, key: P2 = "default" } = s2, b2 = n.useMemo(() => {
          let e3 = g(m2, p2);
          return null == e3 ? null : { pathname: e3, search: d2, hash: v2, state: x2, key: P2 };
        }, [p2, m2, d2, v2, x2, P2]);
        return null == b2 ? null : n.createElement(a.Provider, { value: f2 }, n.createElement(r.Provider, { children: o2, value: { location: b2, navigationType: u2 } }));
      }
      function j(e2) {
        let t2 = [];
        return n.Children.forEach(e2, (e3) => {
          if (!n.isValidElement(e3))
            return;
          if (e3.type === n.Fragment)
            return void t2.push.apply(t2, j(e3.props.children));
          e3.type !== N && l(false);
          let a2 = { caseSensitive: e3.props.caseSensitive, element: e3.props.element, index: e3.props.index, path: e3.props.path };
          e3.props.children && (a2.children = j(e3.props.children)), t2.push(a2);
        }), t2;
      }
      Object.defineProperty(e, "NavigationType", { enumerable: true, get: function() {
        return t.Action;
      } }), Object.defineProperty(e, "createPath", { enumerable: true, get: function() {
        return t.createPath;
      } }), Object.defineProperty(e, "parsePath", { enumerable: true, get: function() {
        return t.parsePath;
      } }), e.MemoryRouter = function(e2) {
        let { basename: a2, children: r2, initialEntries: i2, initialIndex: l2 } = e2, o2 = n.useRef();
        null == o2.current && (o2.current = t.createMemoryHistory({ initialEntries: i2, initialIndex: l2 }));
        let s2 = o2.current, [u2, c2] = n.useState({ action: s2.action, location: s2.location });
        return n.useLayoutEffect(() => s2.listen(c2), [s2]), n.createElement(W, { basename: a2, children: r2, location: u2.location, navigationType: u2.action, navigator: s2 });
      }, e.Navigate = function(e2) {
        let { to: t2, replace: a2, state: r2 } = e2;
        C() || l(false);
        let i2 = E();
        return n.useEffect(() => {
          i2(t2, { replace: a2, state: r2 });
        }), null;
      }, e.Outlet = function(e2) {
        return S(e2.context);
      }, e.Route = N, e.Router = W, e.Routes = function(e2) {
        let { children: t2, location: n2 } = e2;
        return O(j(t2), n2);
      }, e.UNSAFE_LocationContext = r, e.UNSAFE_NavigationContext = a, e.UNSAFE_RouteContext = i, e.createRoutesFromChildren = j, e.generatePath = function(e2, t2) {
        return void 0 === t2 && (t2 = {}), e2.replace(/:(\w+)/g, (e3, n2) => (null == t2[n2] && l(false), t2[n2])).replace(/\/*\*$/, (e3) => null == t2["*"] ? "" : t2["*"].replace(/^\/*/, "/"));
      }, e.matchPath = f, e.matchRoutes = o, e.renderMatches = function(e2) {
        return M(e2);
      }, e.resolvePath = m, e.useHref = function(e2) {
        C() || l(false);
        let { basename: r2, navigator: i2 } = n.useContext(a), { hash: o2, pathname: s2, search: u2 } = $(e2), c2 = s2;
        if ("/" !== r2) {
          let n2 = function(e3) {
            return "" === e3 || "" === e3.pathname ? "/" : "string" == typeof e3 ? t.parsePath(e3).pathname : e3.pathname;
          }(e2), a2 = null != n2 && n2.endsWith("/");
          c2 = "/" === s2 ? r2 + (a2 ? "/" : "") : v([r2, s2]);
        }
        return i2.createHref({ pathname: c2, search: u2, hash: o2 });
      }, e.useInRouterContext = C, e.useLocation = b, e.useMatch = function(e2) {
        C() || l(false);
        let { pathname: t2 } = b();
        return n.useMemo(() => f(e2, t2), [t2, e2]);
      }, e.useNavigate = E, e.useNavigationType = function() {
        return n.useContext(r).navigationType;
      }, e.useOutlet = S, e.useOutletContext = function() {
        return n.useContext(R);
      }, e.useParams = function() {
        let { matches: e2 } = n.useContext(i), t2 = e2[e2.length - 1];
        return t2 ? t2.params : {};
      }, e.useResolvedPath = $, e.useRoutes = O, Object.defineProperty(e, "__esModule", { value: true });
    });
  }
});

// node_modules/react-router/umd/react-router.development.js
var require_react_router_development = __commonJS({
  "node_modules/react-router/umd/react-router.development.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_main(), require_react()) : typeof define === "function" && define.amd ? define(["exports", "history", "react"], factory) : (global = global || self, factory(global.ReactRouter = {}, global.HistoryLibrary, global.React));
    })(exports, function(exports2, history, React) {
      "use strict";
      const NavigationContext = /* @__PURE__ */ React.createContext(null);
      {
        NavigationContext.displayName = "Navigation";
      }
      const LocationContext = /* @__PURE__ */ React.createContext(null);
      {
        LocationContext.displayName = "Location";
      }
      const RouteContext = /* @__PURE__ */ React.createContext({
        outlet: null,
        matches: []
      });
      {
        RouteContext.displayName = "Route";
      }
      function invariant(cond, message) {
        if (!cond)
          throw new Error(message);
      }
      function warning(cond, message) {
        if (!cond) {
          if (typeof console !== "undefined")
            console.warn(message);
          try {
            throw new Error(message);
          } catch (e) {
          }
        }
      }
      const alreadyWarned = {};
      function warningOnce(key, cond, message) {
        if (!cond && !alreadyWarned[key]) {
          alreadyWarned[key] = true;
          warning(false, message);
        }
      }
      function generatePath(path, params) {
        if (params === void 0) {
          params = {};
        }
        return path.replace(/:(\w+)/g, (_, key) => {
          !(params[key] != null) ? invariant(false, 'Missing ":' + key + '" param') : void 0;
          return params[key];
        }).replace(/\/*\*$/, (_) => params["*"] == null ? "" : params["*"].replace(/^\/*/, "/"));
      }
      function matchRoutes(routes, locationArg, basename) {
        if (basename === void 0) {
          basename = "/";
        }
        let location = typeof locationArg === "string" ? history.parsePath(locationArg) : locationArg;
        let pathname = stripBasename(location.pathname || "/", basename);
        if (pathname == null) {
          return null;
        }
        let branches = flattenRoutes(routes);
        rankRouteBranches(branches);
        let matches = null;
        for (let i = 0; matches == null && i < branches.length; ++i) {
          matches = matchRouteBranch(branches[i], pathname);
        }
        return matches;
      }
      function flattenRoutes(routes, branches, parentsMeta, parentPath) {
        if (branches === void 0) {
          branches = [];
        }
        if (parentsMeta === void 0) {
          parentsMeta = [];
        }
        if (parentPath === void 0) {
          parentPath = "";
        }
        routes.forEach((route, index) => {
          let meta = {
            relativePath: route.path || "",
            caseSensitive: route.caseSensitive === true,
            childrenIndex: index,
            route
          };
          if (meta.relativePath.startsWith("/")) {
            !meta.relativePath.startsWith(parentPath) ? invariant(false, 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : void 0;
            meta.relativePath = meta.relativePath.slice(parentPath.length);
          }
          let path = joinPaths([parentPath, meta.relativePath]);
          let routesMeta = parentsMeta.concat(meta);
          if (route.children && route.children.length > 0) {
            !(route.index !== true) ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : void 0;
            flattenRoutes(route.children, branches, routesMeta, path);
          }
          if (route.path == null && !route.index) {
            return;
          }
          branches.push({
            path,
            score: computeScore(path, route.index),
            routesMeta
          });
        });
        return branches;
      }
      function rankRouteBranches(branches) {
        branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
      }
      const paramRe = /^:\w+$/;
      const dynamicSegmentValue = 3;
      const indexRouteValue = 2;
      const emptySegmentValue = 1;
      const staticSegmentValue = 10;
      const splatPenalty = -2;
      const isSplat = (s) => s === "*";
      function computeScore(path, index) {
        let segments = path.split("/");
        let initialScore = segments.length;
        if (segments.some(isSplat)) {
          initialScore += splatPenalty;
        }
        if (index) {
          initialScore += indexRouteValue;
        }
        return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
      }
      function compareIndexes(a, b) {
        let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
        return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
      }
      function matchRouteBranch(branch, pathname) {
        let {
          routesMeta
        } = branch;
        let matchedParams = {};
        let matchedPathname = "/";
        let matches = [];
        for (let i = 0; i < routesMeta.length; ++i) {
          let meta = routesMeta[i];
          let end = i === routesMeta.length - 1;
          let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
          let match = matchPath({
            path: meta.relativePath,
            caseSensitive: meta.caseSensitive,
            end
          }, remainingPathname);
          if (!match)
            return null;
          Object.assign(matchedParams, match.params);
          let route = meta.route;
          matches.push({
            params: matchedParams,
            pathname: joinPaths([matchedPathname, match.pathname]),
            pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
            route
          });
          if (match.pathnameBase !== "/") {
            matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
          }
        }
        return matches;
      }
      function matchPath(pattern, pathname) {
        if (typeof pattern === "string") {
          pattern = {
            path: pattern,
            caseSensitive: false,
            end: true
          };
        }
        let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
        let match = pathname.match(matcher);
        if (!match)
          return null;
        let matchedPathname = match[0];
        let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
        let captureGroups = match.slice(1);
        let params = paramNames.reduce((memo, paramName, index) => {
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
          }
          memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
          return memo;
        }, {});
        return {
          params,
          pathname: matchedPathname,
          pathnameBase,
          pattern
        };
      }
      function compilePath(path, caseSensitive, end) {
        if (caseSensitive === void 0) {
          caseSensitive = false;
        }
        if (end === void 0) {
          end = true;
        }
        warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
        let paramNames = [];
        let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
          paramNames.push(paramName);
          return "([^\\/]+)";
        });
        if (path.endsWith("*")) {
          paramNames.push("*");
          regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
        } else {
          regexpSource += end ? "\\/*$" : "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
        }
        let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
        return [matcher, paramNames];
      }
      function safelyDecodeURIComponent(value, paramName) {
        try {
          return decodeURIComponent(value);
        } catch (error) {
          warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
          return value;
        }
      }
      function resolvePath(to, fromPathname) {
        if (fromPathname === void 0) {
          fromPathname = "/";
        }
        let {
          pathname: toPathname,
          search = "",
          hash = ""
        } = typeof to === "string" ? history.parsePath(to) : to;
        let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
        return {
          pathname,
          search: normalizeSearch(search),
          hash: normalizeHash(hash)
        };
      }
      function resolvePathname(relativePath, fromPathname) {
        let segments = fromPathname.replace(/\/+$/, "").split("/");
        let relativeSegments = relativePath.split("/");
        relativeSegments.forEach((segment) => {
          if (segment === "..") {
            if (segments.length > 1)
              segments.pop();
          } else if (segment !== ".") {
            segments.push(segment);
          }
        });
        return segments.length > 1 ? segments.join("/") : "/";
      }
      function resolveTo(toArg, routePathnames, locationPathname) {
        let to = typeof toArg === "string" ? history.parsePath(toArg) : toArg;
        let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
        let from;
        if (toPathname == null) {
          from = locationPathname;
        } else {
          let routePathnameIndex = routePathnames.length - 1;
          if (toPathname.startsWith("..")) {
            let toSegments = toPathname.split("/");
            while (toSegments[0] === "..") {
              toSegments.shift();
              routePathnameIndex -= 1;
            }
            to.pathname = toSegments.join("/");
          }
          from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
        }
        let path = resolvePath(to, from);
        if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
          path.pathname += "/";
        }
        return path;
      }
      function getToPathname(to) {
        return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? history.parsePath(to).pathname : to.pathname;
      }
      function stripBasename(pathname, basename) {
        if (basename === "/")
          return pathname;
        if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
          return null;
        }
        let nextChar = pathname.charAt(basename.length);
        if (nextChar && nextChar !== "/") {
          return null;
        }
        return pathname.slice(basename.length) || "/";
      }
      const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
      const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
      const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
      const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
      function useHref(to) {
        !useInRouterContext() ? invariant(
          false,
          "useHref() may be used only in the context of a <Router> component."
        ) : void 0;
        let {
          basename,
          navigator
        } = React.useContext(NavigationContext);
        let {
          hash,
          pathname,
          search
        } = useResolvedPath(to);
        let joinedPathname = pathname;
        if (basename !== "/") {
          let toPathname = getToPathname(to);
          let endsWithSlash = toPathname != null && toPathname.endsWith("/");
          joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
        }
        return navigator.createHref({
          pathname: joinedPathname,
          search,
          hash
        });
      }
      function useInRouterContext() {
        return React.useContext(LocationContext) != null;
      }
      function useLocation() {
        !useInRouterContext() ? invariant(
          false,
          "useLocation() may be used only in the context of a <Router> component."
        ) : void 0;
        return React.useContext(LocationContext).location;
      }
      function useNavigationType() {
        return React.useContext(LocationContext).navigationType;
      }
      function useMatch(pattern) {
        !useInRouterContext() ? invariant(
          false,
          "useMatch() may be used only in the context of a <Router> component."
        ) : void 0;
        let {
          pathname
        } = useLocation();
        return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);
      }
      function useNavigate() {
        !useInRouterContext() ? invariant(
          false,
          "useNavigate() may be used only in the context of a <Router> component."
        ) : void 0;
        let {
          basename,
          navigator
        } = React.useContext(NavigationContext);
        let {
          matches
        } = React.useContext(RouteContext);
        let {
          pathname: locationPathname
        } = useLocation();
        let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
        let activeRef = React.useRef(false);
        React.useEffect(() => {
          activeRef.current = true;
        });
        let navigate = React.useCallback(function(to, options) {
          if (options === void 0) {
            options = {};
          }
          warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.");
          if (!activeRef.current)
            return;
          if (typeof to === "number") {
            navigator.go(to);
            return;
          }
          let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
          if (basename !== "/") {
            path.pathname = joinPaths([basename, path.pathname]);
          }
          (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
        }, [basename, navigator, routePathnamesJson, locationPathname]);
        return navigate;
      }
      const OutletContext = /* @__PURE__ */ React.createContext(null);
      function useOutletContext() {
        return React.useContext(OutletContext);
      }
      function useOutlet(context) {
        let outlet = React.useContext(RouteContext).outlet;
        if (outlet) {
          return /* @__PURE__ */ React.createElement(OutletContext.Provider, {
            value: context
          }, outlet);
        }
        return outlet;
      }
      function useParams() {
        let {
          matches
        } = React.useContext(RouteContext);
        let routeMatch = matches[matches.length - 1];
        return routeMatch ? routeMatch.params : {};
      }
      function useResolvedPath(to) {
        let {
          matches
        } = React.useContext(RouteContext);
        let {
          pathname: locationPathname
        } = useLocation();
        let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
        return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
      }
      function useRoutes(routes, locationArg) {
        !useInRouterContext() ? invariant(
          false,
          "useRoutes() may be used only in the context of a <Router> component."
        ) : void 0;
        let {
          matches: parentMatches
        } = React.useContext(RouteContext);
        let routeMatch = parentMatches[parentMatches.length - 1];
        let parentParams = routeMatch ? routeMatch.params : {};
        let parentPathname = routeMatch ? routeMatch.pathname : "/";
        let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
        let parentRoute = routeMatch && routeMatch.route;
        {
          let parentPath = parentRoute && parentRoute.path || "";
          warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
        }
        let locationFromContext = useLocation();
        let location;
        if (locationArg) {
          var _parsedLocationArg$pa;
          let parsedLocationArg = typeof locationArg === "string" ? history.parsePath(locationArg) : locationArg;
          !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : void 0;
          location = parsedLocationArg;
        } else {
          location = locationFromContext;
        }
        let pathname = location.pathname || "/";
        let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
        let matches = matchRoutes(routes, {
          pathname: remainingPathname
        });
        {
          warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ');
          warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.');
        }
        return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
          params: Object.assign({}, parentParams, match.params),
          pathname: joinPaths([parentPathnameBase, match.pathname]),
          pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
        })), parentMatches);
      }
      function _renderMatches(matches, parentMatches) {
        if (parentMatches === void 0) {
          parentMatches = [];
        }
        if (matches == null)
          return null;
        return matches.reduceRight((outlet, match, index) => {
          return /* @__PURE__ */ React.createElement(RouteContext.Provider, {
            children: match.route.element !== void 0 ? match.route.element : outlet,
            value: {
              outlet,
              matches: parentMatches.concat(matches.slice(0, index + 1))
            }
          });
        }, null);
      }
      function MemoryRouter(_ref) {
        let {
          basename,
          children,
          initialEntries,
          initialIndex
        } = _ref;
        let historyRef = React.useRef();
        if (historyRef.current == null) {
          historyRef.current = history.createMemoryHistory({
            initialEntries,
            initialIndex
          });
        }
        let history$1 = historyRef.current;
        let [state, setState] = React.useState({
          action: history$1.action,
          location: history$1.location
        });
        React.useLayoutEffect(() => history$1.listen(setState), [history$1]);
        return /* @__PURE__ */ React.createElement(Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history$1
        });
      }
      function Navigate(_ref2) {
        let {
          to,
          replace,
          state
        } = _ref2;
        !useInRouterContext() ? invariant(
          false,
          "<Navigate> may be used only in the context of a <Router> component."
        ) : void 0;
        warning(!React.useContext(NavigationContext).static, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
        let navigate = useNavigate();
        React.useEffect(() => {
          navigate(to, {
            replace,
            state
          });
        });
        return null;
      }
      function Outlet(props) {
        return useOutlet(props.context);
      }
      function Route(_props) {
        invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.");
      }
      function Router(_ref3) {
        let {
          basename: basenameProp = "/",
          children = null,
          location: locationProp,
          navigationType = history.Action.Pop,
          navigator,
          static: staticProp = false
        } = _ref3;
        !!useInRouterContext() ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : void 0;
        let basename = normalizePathname(basenameProp);
        let navigationContext = React.useMemo(() => ({
          basename,
          navigator,
          static: staticProp
        }), [basename, navigator, staticProp]);
        if (typeof locationProp === "string") {
          locationProp = history.parsePath(locationProp);
        }
        let {
          pathname = "/",
          search = "",
          hash = "",
          state = null,
          key = "default"
        } = locationProp;
        let location = React.useMemo(() => {
          let trailingPathname = stripBasename(pathname, basename);
          if (trailingPathname == null) {
            return null;
          }
          return {
            pathname: trailingPathname,
            search,
            hash,
            state,
            key
          };
        }, [basename, pathname, search, hash, state, key]);
        warning(location != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.");
        if (location == null) {
          return null;
        }
        return /* @__PURE__ */ React.createElement(NavigationContext.Provider, {
          value: navigationContext
        }, /* @__PURE__ */ React.createElement(LocationContext.Provider, {
          children,
          value: {
            location,
            navigationType
          }
        }));
      }
      function Routes(_ref4) {
        let {
          children,
          location
        } = _ref4;
        return useRoutes(createRoutesFromChildren(children), location);
      }
      function createRoutesFromChildren(children) {
        let routes = [];
        React.Children.forEach(children, (element) => {
          if (!/* @__PURE__ */ React.isValidElement(element)) {
            return;
          }
          if (element.type === React.Fragment) {
            routes.push.apply(routes, createRoutesFromChildren(element.props.children));
            return;
          }
          !(element.type === Route) ? invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : void 0;
          let route = {
            caseSensitive: element.props.caseSensitive,
            element: element.props.element,
            index: element.props.index,
            path: element.props.path
          };
          if (element.props.children) {
            route.children = createRoutesFromChildren(element.props.children);
          }
          routes.push(route);
        });
        return routes;
      }
      function renderMatches(matches) {
        return _renderMatches(matches);
      }
      Object.defineProperty(exports2, "NavigationType", {
        enumerable: true,
        get: function() {
          return history.Action;
        }
      });
      Object.defineProperty(exports2, "createPath", {
        enumerable: true,
        get: function() {
          return history.createPath;
        }
      });
      Object.defineProperty(exports2, "parsePath", {
        enumerable: true,
        get: function() {
          return history.parsePath;
        }
      });
      exports2.MemoryRouter = MemoryRouter;
      exports2.Navigate = Navigate;
      exports2.Outlet = Outlet;
      exports2.Route = Route;
      exports2.Router = Router;
      exports2.Routes = Routes;
      exports2.UNSAFE_LocationContext = LocationContext;
      exports2.UNSAFE_NavigationContext = NavigationContext;
      exports2.UNSAFE_RouteContext = RouteContext;
      exports2.createRoutesFromChildren = createRoutesFromChildren;
      exports2.generatePath = generatePath;
      exports2.matchPath = matchPath;
      exports2.matchRoutes = matchRoutes;
      exports2.renderMatches = renderMatches;
      exports2.resolvePath = resolvePath;
      exports2.useHref = useHref;
      exports2.useInRouterContext = useInRouterContext;
      exports2.useLocation = useLocation;
      exports2.useMatch = useMatch;
      exports2.useNavigate = useNavigate;
      exports2.useNavigationType = useNavigationType;
      exports2.useOutlet = useOutlet;
      exports2.useOutletContext = useOutletContext;
      exports2.useParams = useParams;
      exports2.useResolvedPath = useResolvedPath;
      exports2.useRoutes = useRoutes;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/react-router/main.js
var require_main2 = __commonJS({
  "node_modules/react-router/main.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_router_production_min();
    } else {
      module2.exports = require_react_router_development();
    }
  }
});

// node_modules/react-router-dom/umd/react-router-dom.production.min.js
var require_react_router_dom_production_min = __commonJS({
  "node_modules/react-router-dom/umd/react-router-dom.production.min.js"(exports, module2) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module2 ? t(exports, require_react(), require_main(), require_main2()) : "function" == typeof define && define.amd ? define(["exports", "react", "history", "react-router"], t) : t((e = e || self).ReactRouterDOM = {}, e.React, e.HistoryLibrary, e.ReactRouter);
    }(exports, function(e, t, r, n) {
      "use strict";
      function a() {
        return a = Object.assign || function(e2) {
          for (var t2 = 1; t2 < arguments.length; t2++) {
            var r2 = arguments[t2];
            for (var n2 in r2)
              Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
          }
          return e2;
        }, a.apply(this, arguments);
      }
      function o(e2, t2) {
        if (null == e2)
          return {};
        var r2, n2, a2 = {}, o2 = Object.keys(e2);
        for (n2 = 0; n2 < o2.length; n2++)
          r2 = o2[n2], t2.indexOf(r2) >= 0 || (a2[r2] = e2[r2]);
        return a2;
      }
      const u = ["onClick", "reloadDocument", "replace", "state", "target", "to"], i = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
      const c = t.forwardRef(function(e2, r2) {
        let { onClick: i2, reloadDocument: c2, replace: s2 = false, state: f2, target: b, to: y } = e2, d = o(e2, u), m = n.useHref(y), p = l(y, { replace: s2, state: f2, target: b });
        return t.createElement("a", a({}, d, { href: m, onClick: function(e3) {
          i2 && i2(e3), e3.defaultPrevented || c2 || p(e3);
        }, ref: r2, target: b }));
      }), s = t.forwardRef(function(e2, r2) {
        let { "aria-current": u2 = "page", caseSensitive: s2 = false, className: l2 = "", end: f2 = false, style: b, to: y, children: d } = e2, m = o(e2, i), p = n.useLocation(), g = n.useResolvedPath(y), h = p.pathname, P = g.pathname;
        s2 || (h = h.toLowerCase(), P = P.toLowerCase());
        let O, v = h === P || !f2 && h.startsWith(P) && "/" === h.charAt(P.length), R = v ? u2 : void 0;
        O = "function" == typeof l2 ? l2({ isActive: v }) : [l2, v ? "active" : null].filter(Boolean).join(" ");
        let j = "function" == typeof b ? b({ isActive: v }) : b;
        return t.createElement(c, a({}, m, { "aria-current": R, className: O, ref: r2, style: j, to: y }), "function" == typeof d ? d({ isActive: v }) : d);
      });
      function l(e2, r2) {
        let { target: a2, replace: o2, state: u2 } = void 0 === r2 ? {} : r2, i2 = n.useNavigate(), c2 = n.useLocation(), s2 = n.useResolvedPath(e2);
        return t.useCallback((t2) => {
          if (!(0 !== t2.button || a2 && "_self" !== a2 || function(e3) {
            return !!(e3.metaKey || e3.altKey || e3.ctrlKey || e3.shiftKey);
          }(t2))) {
            t2.preventDefault();
            let r3 = !!o2 || n.createPath(c2) === n.createPath(s2);
            i2(e2, { replace: r3, state: u2 });
          }
        }, [c2, i2, s2, o2, u2, a2, e2]);
      }
      function f(e2) {
        return void 0 === e2 && (e2 = ""), new URLSearchParams("string" == typeof e2 || Array.isArray(e2) || e2 instanceof URLSearchParams ? e2 : Object.keys(e2).reduce((t2, r2) => {
          let n2 = e2[r2];
          return t2.concat(Array.isArray(n2) ? n2.map((e3) => [r2, e3]) : [[r2, n2]]);
        }, []));
      }
      Object.defineProperty(e, "MemoryRouter", { enumerable: true, get: function() {
        return n.MemoryRouter;
      } }), Object.defineProperty(e, "Navigate", { enumerable: true, get: function() {
        return n.Navigate;
      } }), Object.defineProperty(e, "NavigationType", { enumerable: true, get: function() {
        return n.NavigationType;
      } }), Object.defineProperty(e, "Outlet", { enumerable: true, get: function() {
        return n.Outlet;
      } }), Object.defineProperty(e, "Route", { enumerable: true, get: function() {
        return n.Route;
      } }), Object.defineProperty(e, "Router", { enumerable: true, get: function() {
        return n.Router;
      } }), Object.defineProperty(e, "Routes", { enumerable: true, get: function() {
        return n.Routes;
      } }), Object.defineProperty(e, "UNSAFE_LocationContext", { enumerable: true, get: function() {
        return n.UNSAFE_LocationContext;
      } }), Object.defineProperty(e, "UNSAFE_NavigationContext", { enumerable: true, get: function() {
        return n.UNSAFE_NavigationContext;
      } }), Object.defineProperty(e, "UNSAFE_RouteContext", { enumerable: true, get: function() {
        return n.UNSAFE_RouteContext;
      } }), Object.defineProperty(e, "createPath", { enumerable: true, get: function() {
        return n.createPath;
      } }), Object.defineProperty(e, "createRoutesFromChildren", { enumerable: true, get: function() {
        return n.createRoutesFromChildren;
      } }), Object.defineProperty(e, "generatePath", { enumerable: true, get: function() {
        return n.generatePath;
      } }), Object.defineProperty(e, "matchPath", { enumerable: true, get: function() {
        return n.matchPath;
      } }), Object.defineProperty(e, "matchRoutes", { enumerable: true, get: function() {
        return n.matchRoutes;
      } }), Object.defineProperty(e, "parsePath", { enumerable: true, get: function() {
        return n.parsePath;
      } }), Object.defineProperty(e, "renderMatches", { enumerable: true, get: function() {
        return n.renderMatches;
      } }), Object.defineProperty(e, "resolvePath", { enumerable: true, get: function() {
        return n.resolvePath;
      } }), Object.defineProperty(e, "useHref", { enumerable: true, get: function() {
        return n.useHref;
      } }), Object.defineProperty(e, "useInRouterContext", { enumerable: true, get: function() {
        return n.useInRouterContext;
      } }), Object.defineProperty(e, "useLocation", { enumerable: true, get: function() {
        return n.useLocation;
      } }), Object.defineProperty(e, "useMatch", { enumerable: true, get: function() {
        return n.useMatch;
      } }), Object.defineProperty(e, "useNavigate", { enumerable: true, get: function() {
        return n.useNavigate;
      } }), Object.defineProperty(e, "useNavigationType", { enumerable: true, get: function() {
        return n.useNavigationType;
      } }), Object.defineProperty(e, "useOutlet", { enumerable: true, get: function() {
        return n.useOutlet;
      } }), Object.defineProperty(e, "useOutletContext", { enumerable: true, get: function() {
        return n.useOutletContext;
      } }), Object.defineProperty(e, "useParams", { enumerable: true, get: function() {
        return n.useParams;
      } }), Object.defineProperty(e, "useResolvedPath", { enumerable: true, get: function() {
        return n.useResolvedPath;
      } }), Object.defineProperty(e, "useRoutes", { enumerable: true, get: function() {
        return n.useRoutes;
      } }), e.BrowserRouter = function(e2) {
        let { basename: a2, children: o2, window: u2 } = e2, i2 = t.useRef();
        null == i2.current && (i2.current = r.createBrowserHistory({ window: u2 }));
        let c2 = i2.current, [s2, l2] = t.useState({ action: c2.action, location: c2.location });
        return t.useLayoutEffect(() => c2.listen(l2), [c2]), t.createElement(n.Router, { basename: a2, children: o2, location: s2.location, navigationType: s2.action, navigator: c2 });
      }, e.HashRouter = function(e2) {
        let { basename: a2, children: o2, window: u2 } = e2, i2 = t.useRef();
        null == i2.current && (i2.current = r.createHashHistory({ window: u2 }));
        let c2 = i2.current, [s2, l2] = t.useState({ action: c2.action, location: c2.location });
        return t.useLayoutEffect(() => c2.listen(l2), [c2]), t.createElement(n.Router, { basename: a2, children: o2, location: s2.location, navigationType: s2.action, navigator: c2 });
      }, e.Link = c, e.NavLink = s, e.createSearchParams = f, e.unstable_HistoryRouter = function(e2) {
        let { basename: r2, children: a2, history: o2 } = e2;
        const [u2, i2] = t.useState({ action: o2.action, location: o2.location });
        return t.useLayoutEffect(() => o2.listen(i2), [o2]), t.createElement(n.Router, { basename: r2, children: a2, location: u2.location, navigationType: u2.action, navigator: o2 });
      }, e.useLinkClickHandler = l, e.useSearchParams = function(e2) {
        let r2 = t.useRef(f(e2)), a2 = n.useLocation(), o2 = t.useMemo(() => {
          let e3 = f(a2.search);
          for (let t2 of r2.current.keys())
            e3.has(t2) || r2.current.getAll(t2).forEach((r3) => {
              e3.append(t2, r3);
            });
          return e3;
        }, [a2.search]), u2 = n.useNavigate();
        return [o2, t.useCallback((e3, t2) => {
          u2("?" + f(e3), t2);
        }, [u2])];
      }, Object.defineProperty(e, "__esModule", { value: true });
    });
  }
});

// node_modules/react-router-dom/umd/react-router-dom.development.js
var require_react_router_dom_development = __commonJS({
  "node_modules/react-router-dom/umd/react-router-dom.development.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports, require_react(), require_main(), require_main2()) : typeof define === "function" && define.amd ? define(["exports", "react", "history", "react-router"], factory) : (global = global || self, factory(global.ReactRouterDOM = {}, global.React, global.HistoryLibrary, global.ReactRouter));
    })(exports, function(exports2, React, history, reactRouter) {
      "use strict";
      function _extends() {
        _extends = Object.assign || function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
          return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
          key = sourceKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          target[key] = source[key];
        }
        return target;
      }
      const _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"], _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
      function warning(cond, message) {
        if (!cond) {
          if (typeof console !== "undefined")
            console.warn(message);
          try {
            throw new Error(message);
          } catch (e) {
          }
        }
      }
      function BrowserRouter(_ref) {
        let {
          basename,
          children,
          window
        } = _ref;
        let historyRef = React.useRef();
        if (historyRef.current == null) {
          historyRef.current = history.createBrowserHistory({
            window
          });
        }
        let history$1 = historyRef.current;
        let [state, setState] = React.useState({
          action: history$1.action,
          location: history$1.location
        });
        React.useLayoutEffect(() => history$1.listen(setState), [history$1]);
        return /* @__PURE__ */ React.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history$1
        });
      }
      function HashRouter(_ref2) {
        let {
          basename,
          children,
          window
        } = _ref2;
        let historyRef = React.useRef();
        if (historyRef.current == null) {
          historyRef.current = history.createHashHistory({
            window
          });
        }
        let history$1 = historyRef.current;
        let [state, setState] = React.useState({
          action: history$1.action,
          location: history$1.location
        });
        React.useLayoutEffect(() => history$1.listen(setState), [history$1]);
        return /* @__PURE__ */ React.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history$1
        });
      }
      function HistoryRouter(_ref3) {
        let {
          basename,
          children,
          history: history2
        } = _ref3;
        const [state, setState] = React.useState({
          action: history2.action,
          location: history2.location
        });
        React.useLayoutEffect(() => history2.listen(setState), [history2]);
        return /* @__PURE__ */ React.createElement(reactRouter.Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history2
        });
      }
      {
        HistoryRouter.displayName = "unstable_HistoryRouter";
      }
      function isModifiedEvent(event) {
        return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
      }
      const Link = /* @__PURE__ */ React.forwardRef(function LinkWithRef(_ref4, ref) {
        let {
          onClick,
          reloadDocument,
          replace = false,
          state,
          target,
          to
        } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
        let href = reactRouter.useHref(to);
        let internalOnClick = useLinkClickHandler(to, {
          replace,
          state,
          target
        });
        function handleClick(event) {
          if (onClick)
            onClick(event);
          if (!event.defaultPrevented && !reloadDocument) {
            internalOnClick(event);
          }
        }
        return /* @__PURE__ */ React.createElement("a", _extends({}, rest, {
          href,
          onClick: handleClick,
          ref,
          target
        }));
      });
      {
        Link.displayName = "Link";
      }
      const NavLink = /* @__PURE__ */ React.forwardRef(function NavLinkWithRef(_ref5, ref) {
        let {
          "aria-current": ariaCurrentProp = "page",
          caseSensitive = false,
          className: classNameProp = "",
          end = false,
          style: styleProp,
          to,
          children
        } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
        let location = reactRouter.useLocation();
        let path = reactRouter.useResolvedPath(to);
        let locationPathname = location.pathname;
        let toPathname = path.pathname;
        if (!caseSensitive) {
          locationPathname = locationPathname.toLowerCase();
          toPathname = toPathname.toLowerCase();
        }
        let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
        let ariaCurrent = isActive ? ariaCurrentProp : void 0;
        let className;
        if (typeof classNameProp === "function") {
          className = classNameProp({
            isActive
          });
        } else {
          className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
        }
        let style = typeof styleProp === "function" ? styleProp({
          isActive
        }) : styleProp;
        return /* @__PURE__ */ React.createElement(Link, _extends({}, rest, {
          "aria-current": ariaCurrent,
          className,
          ref,
          style,
          to
        }), typeof children === "function" ? children({
          isActive
        }) : children);
      });
      {
        NavLink.displayName = "NavLink";
      }
      function useLinkClickHandler(to, _temp) {
        let {
          target,
          replace: replaceProp,
          state
        } = _temp === void 0 ? {} : _temp;
        let navigate = reactRouter.useNavigate();
        let location = reactRouter.useLocation();
        let path = reactRouter.useResolvedPath(to);
        return React.useCallback((event) => {
          if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
            event.preventDefault();
            let replace = !!replaceProp || reactRouter.createPath(location) === reactRouter.createPath(path);
            navigate(to, {
              replace,
              state
            });
          }
        }, [location, navigate, path, replaceProp, state, target, to]);
      }
      function useSearchParams(defaultInit) {
        warning(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.");
        let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));
        let location = reactRouter.useLocation();
        let searchParams = React.useMemo(() => {
          let searchParams2 = createSearchParams(location.search);
          for (let key of defaultSearchParamsRef.current.keys()) {
            if (!searchParams2.has(key)) {
              defaultSearchParamsRef.current.getAll(key).forEach((value) => {
                searchParams2.append(key, value);
              });
            }
          }
          return searchParams2;
        }, [location.search]);
        let navigate = reactRouter.useNavigate();
        let setSearchParams = React.useCallback((nextInit, navigateOptions) => {
          navigate("?" + createSearchParams(nextInit), navigateOptions);
        }, [navigate]);
        return [searchParams, setSearchParams];
      }
      function createSearchParams(init) {
        if (init === void 0) {
          init = "";
        }
        return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
          let value = init[key];
          return memo.concat(Array.isArray(value) ? value.map((v) => [key, v]) : [[key, value]]);
        }, []));
      }
      Object.defineProperty(exports2, "MemoryRouter", {
        enumerable: true,
        get: function() {
          return reactRouter.MemoryRouter;
        }
      });
      Object.defineProperty(exports2, "Navigate", {
        enumerable: true,
        get: function() {
          return reactRouter.Navigate;
        }
      });
      Object.defineProperty(exports2, "NavigationType", {
        enumerable: true,
        get: function() {
          return reactRouter.NavigationType;
        }
      });
      Object.defineProperty(exports2, "Outlet", {
        enumerable: true,
        get: function() {
          return reactRouter.Outlet;
        }
      });
      Object.defineProperty(exports2, "Route", {
        enumerable: true,
        get: function() {
          return reactRouter.Route;
        }
      });
      Object.defineProperty(exports2, "Router", {
        enumerable: true,
        get: function() {
          return reactRouter.Router;
        }
      });
      Object.defineProperty(exports2, "Routes", {
        enumerable: true,
        get: function() {
          return reactRouter.Routes;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_LocationContext", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_LocationContext;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_NavigationContext", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_NavigationContext;
        }
      });
      Object.defineProperty(exports2, "UNSAFE_RouteContext", {
        enumerable: true,
        get: function() {
          return reactRouter.UNSAFE_RouteContext;
        }
      });
      Object.defineProperty(exports2, "createPath", {
        enumerable: true,
        get: function() {
          return reactRouter.createPath;
        }
      });
      Object.defineProperty(exports2, "createRoutesFromChildren", {
        enumerable: true,
        get: function() {
          return reactRouter.createRoutesFromChildren;
        }
      });
      Object.defineProperty(exports2, "generatePath", {
        enumerable: true,
        get: function() {
          return reactRouter.generatePath;
        }
      });
      Object.defineProperty(exports2, "matchPath", {
        enumerable: true,
        get: function() {
          return reactRouter.matchPath;
        }
      });
      Object.defineProperty(exports2, "matchRoutes", {
        enumerable: true,
        get: function() {
          return reactRouter.matchRoutes;
        }
      });
      Object.defineProperty(exports2, "parsePath", {
        enumerable: true,
        get: function() {
          return reactRouter.parsePath;
        }
      });
      Object.defineProperty(exports2, "renderMatches", {
        enumerable: true,
        get: function() {
          return reactRouter.renderMatches;
        }
      });
      Object.defineProperty(exports2, "resolvePath", {
        enumerable: true,
        get: function() {
          return reactRouter.resolvePath;
        }
      });
      Object.defineProperty(exports2, "useHref", {
        enumerable: true,
        get: function() {
          return reactRouter.useHref;
        }
      });
      Object.defineProperty(exports2, "useInRouterContext", {
        enumerable: true,
        get: function() {
          return reactRouter.useInRouterContext;
        }
      });
      Object.defineProperty(exports2, "useLocation", {
        enumerable: true,
        get: function() {
          return reactRouter.useLocation;
        }
      });
      Object.defineProperty(exports2, "useMatch", {
        enumerable: true,
        get: function() {
          return reactRouter.useMatch;
        }
      });
      Object.defineProperty(exports2, "useNavigate", {
        enumerable: true,
        get: function() {
          return reactRouter.useNavigate;
        }
      });
      Object.defineProperty(exports2, "useNavigationType", {
        enumerable: true,
        get: function() {
          return reactRouter.useNavigationType;
        }
      });
      Object.defineProperty(exports2, "useOutlet", {
        enumerable: true,
        get: function() {
          return reactRouter.useOutlet;
        }
      });
      Object.defineProperty(exports2, "useOutletContext", {
        enumerable: true,
        get: function() {
          return reactRouter.useOutletContext;
        }
      });
      Object.defineProperty(exports2, "useParams", {
        enumerable: true,
        get: function() {
          return reactRouter.useParams;
        }
      });
      Object.defineProperty(exports2, "useResolvedPath", {
        enumerable: true,
        get: function() {
          return reactRouter.useResolvedPath;
        }
      });
      Object.defineProperty(exports2, "useRoutes", {
        enumerable: true,
        get: function() {
          return reactRouter.useRoutes;
        }
      });
      exports2.BrowserRouter = BrowserRouter;
      exports2.HashRouter = HashRouter;
      exports2.Link = Link;
      exports2.NavLink = NavLink;
      exports2.createSearchParams = createSearchParams;
      exports2.unstable_HistoryRouter = HistoryRouter;
      exports2.useLinkClickHandler = useLinkClickHandler;
      exports2.useSearchParams = useSearchParams;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/react-router-dom/main.js
var require_main3 = __commonJS({
  "node_modules/react-router-dom/main.js"(exports, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_react_router_dom_production_min();
    } else {
      module2.exports = require_react_router_dom_development();
    }
  }
});

// node_modules/@remix-run/server-runtime/dist/routeMatching.js
var require_routeMatching = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/routeMatching.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var reactRouterDom = require_main3();
    function matchServerRoutes(routes, pathname) {
      let matches = reactRouterDom.matchRoutes(routes, pathname);
      if (!matches)
        return null;
      return matches.map((match) => ({
        params: match.params,
        pathname: match.pathname,
        route: match.route
      }));
    }
    exports.matchServerRoutes = matchServerRoutes;
  }
});

// node_modules/@remix-run/server-runtime/dist/routes.js
var require_routes = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function createRoutes(manifest, parentId) {
      return Object.entries(manifest).filter(([, route]) => route.parentId === parentId).map(([id, route]) => ({
        ...route,
        children: createRoutes(manifest, id)
      }));
    }
    exports.createRoutes = createRoutes;
  }
});

// node_modules/@remix-run/server-runtime/dist/markup.js
var require_markup = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/markup.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ESCAPE_LOOKUP = {
      "&": "\\u0026",
      ">": "\\u003e",
      "<": "\\u003c",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    var ESCAPE_REGEX = /[&><\u2028\u2029]/g;
    function escapeHtml(html) {
      return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
    }
    exports.escapeHtml = escapeHtml;
  }
});

// node_modules/@remix-run/server-runtime/dist/serverHandoff.js
var require_serverHandoff = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/serverHandoff.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var markup = require_markup();
    function createServerHandoffString(serverHandoff) {
      return markup.escapeHtml(JSON.stringify(serverHandoff));
    }
    exports.createServerHandoffString = createServerHandoffString;
  }
});

// node_modules/@remix-run/server-runtime/dist/server.js
var require_server = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var data = require_data();
    var entry = require_entry();
    var errors = require_errors();
    var headers = require_headers();
    var mode = require_mode();
    var routeMatching = require_routeMatching();
    var routes = require_routes();
    var responses = require_responses();
    var serverHandoff = require_serverHandoff();
    var createRequestHandler = (build, mode$1) => {
      let routes$1 = routes.createRoutes(build.routes);
      let serverMode = mode.isServerMode(mode$1) ? mode$1 : mode.ServerMode.Production;
      return async function requestHandler(request, loadContext = {}) {
        let url = new URL(request.url);
        let matches = routeMatching.matchServerRoutes(routes$1, url.pathname);
        let response;
        if (url.searchParams.has("_data")) {
          response = await handleDataRequest({
            request,
            loadContext,
            matches,
            handleDataRequest: build.entry.module.handleDataRequest,
            serverMode
          });
        } else if (matches && !matches[matches.length - 1].route.module.default) {
          response = await handleResourceRequest({
            request,
            loadContext,
            matches,
            serverMode
          });
        } else {
          response = await handleDocumentRequest({
            build,
            loadContext,
            matches,
            request,
            routes: routes$1,
            serverMode
          });
        }
        if (request.method === "HEAD") {
          return new Response(null, {
            headers: response.headers,
            status: response.status,
            statusText: response.statusText
          });
        }
        return response;
      };
    };
    async function handleDataRequest({
      handleDataRequest: handleDataRequest2,
      loadContext,
      matches,
      request,
      serverMode
    }) {
      if (!isValidRequestMethod(request)) {
        return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
      }
      let url = new URL(request.url);
      if (!matches) {
        return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
      }
      let response;
      let match;
      try {
        if (isActionRequest(request)) {
          match = getRequestMatch(url, matches);
          response = await data.callRouteAction({
            loadContext,
            match,
            request
          });
        } else {
          let routeId = url.searchParams.get("_data");
          if (!routeId) {
            return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);
          }
          let tempMatch = matches.find((match2) => match2.route.id === routeId);
          if (!tempMatch) {
            return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
          }
          match = tempMatch;
          response = await data.callRouteLoader({
            loadContext,
            match,
            request
          });
        }
        if (responses.isRedirectResponse(response)) {
          let headers2 = new Headers(response.headers);
          headers2.set("X-Remix-Redirect", headers2.get("Location"));
          headers2.delete("Location");
          if (response.headers.get("Set-Cookie") !== null) {
            headers2.set("X-Remix-Revalidate", "yes");
          }
          return new Response(null, {
            status: 204,
            headers: headers2
          });
        }
        if (handleDataRequest2) {
          response = await handleDataRequest2(response, {
            context: loadContext,
            params: match.params,
            request
          });
        }
        return response;
      } catch (error) {
        if (serverMode !== mode.ServerMode.Test) {
          console.error(error);
        }
        if (serverMode === mode.ServerMode.Development && error instanceof Error) {
          return errorBoundaryError(error, 500);
        }
        return errorBoundaryError(new Error("Unexpected Server Error"), 500);
      }
    }
    async function handleDocumentRequest({
      build,
      loadContext,
      matches,
      request,
      routes: routes2,
      serverMode
    }) {
      let url = new URL(request.url);
      let appState = {
        trackBoundaries: true,
        trackCatchBoundaries: true,
        catchBoundaryRouteId: null,
        renderBoundaryRouteId: null,
        loaderBoundaryRouteId: null,
        error: void 0,
        catch: void 0
      };
      if (!isValidRequestMethod(request)) {
        matches = null;
        appState.trackCatchBoundaries = false;
        appState.catch = {
          data: null,
          status: 405,
          statusText: "Method Not Allowed"
        };
      } else if (!matches) {
        appState.trackCatchBoundaries = false;
        appState.catch = {
          data: null,
          status: 404,
          statusText: "Not Found"
        };
      }
      let actionStatus;
      let actionData;
      let actionMatch;
      let actionResponse;
      if (matches && isActionRequest(request)) {
        actionMatch = getRequestMatch(url, matches);
        try {
          actionResponse = await data.callRouteAction({
            loadContext,
            match: actionMatch,
            request
          });
          if (responses.isRedirectResponse(actionResponse)) {
            return actionResponse;
          }
          actionStatus = {
            status: actionResponse.status,
            statusText: actionResponse.statusText
          };
          if (responses.isCatchResponse(actionResponse)) {
            appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
            appState.trackCatchBoundaries = false;
            appState.catch = {
              ...actionStatus,
              data: await data.extractData(actionResponse)
            };
          } else {
            actionData = {
              [actionMatch.route.id]: await data.extractData(actionResponse)
            };
          }
        } catch (error) {
          appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
          appState.trackBoundaries = false;
          appState.error = await errors.serializeError(error);
          if (serverMode !== mode.ServerMode.Test) {
            console.error(`There was an error running the action for route ${actionMatch.route.id}`);
          }
        }
      }
      let routeModules = entry.createEntryRouteModules(build.routes);
      let matchesToLoad = matches || [];
      if (appState.catch) {
        matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad, "CatchBoundary").slice(0, -1);
      } else if (appState.error) {
        matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad, "ErrorBoundary").slice(0, -1);
      }
      let loaderRequest = new Request(request.url, {
        body: null,
        headers: request.headers,
        method: request.method,
        redirect: request.redirect,
        signal: request.signal
      });
      let routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? data.callRouteLoader({
        loadContext,
        match,
        request: loaderRequest
      }) : Promise.resolve(void 0)));
      let actionCatch = appState.catch;
      let actionError = appState.error;
      let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
      let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
      appState.catch = void 0;
      appState.error = void 0;
      let routeLoaderResponses = {};
      let loaderStatusCodes = [];
      let routeData = {};
      for (let index = 0; index < matchesToLoad.length; index++) {
        let match = matchesToLoad[index];
        let result = routeLoaderResults[index];
        let error = result.status === "rejected" ? result.reason : void 0;
        let response = result.status === "fulfilled" ? result.value : void 0;
        let isRedirect = response ? responses.isRedirectResponse(response) : false;
        let isCatch = response ? responses.isCatchResponse(response) : false;
        if (appState.catch || appState.error) {
          break;
        }
        if (!actionCatch && !actionError && response && isRedirect) {
          return response;
        }
        if (match.route.module.CatchBoundary) {
          appState.catchBoundaryRouteId = match.route.id;
        }
        if (match.route.module.ErrorBoundary) {
          appState.loaderBoundaryRouteId = match.route.id;
        }
        if (error) {
          loaderStatusCodes.push(500);
          appState.trackBoundaries = false;
          appState.error = await errors.serializeError(error);
          if (serverMode !== mode.ServerMode.Test) {
            console.error(`There was an error running the data loader for route ${match.route.id}`);
          }
          break;
        } else if (response) {
          routeLoaderResponses[match.route.id] = response;
          loaderStatusCodes.push(response.status);
          if (isCatch) {
            appState.trackCatchBoundaries = false;
            appState.catch = {
              data: await data.extractData(response),
              status: response.status,
              statusText: response.statusText
            };
            break;
          } else {
            routeData[match.route.id] = await data.extractData(response);
          }
        }
      }
      if (!appState.catch) {
        appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
      }
      if (!appState.error) {
        appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
      }
      appState.catch = actionCatch || appState.catch;
      appState.error = actionError || appState.error;
      let renderableMatches = getRenderableMatches(matches, appState);
      if (!renderableMatches) {
        renderableMatches = [];
        let root = routes2[0];
        if (root !== null && root !== void 0 && root.module.CatchBoundary) {
          appState.catchBoundaryRouteId = "root";
          renderableMatches.push({
            params: {},
            pathname: "",
            route: routes2[0]
          });
        }
      }
      let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200);
      let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
      let responseHeaders = headers.getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
      let entryMatches = entry.createEntryMatches(renderableMatches, build.assets.routes);
      let serverHandoff$1 = {
        actionData,
        appState,
        matches: entryMatches,
        routeData
      };
      let entryContext = {
        ...serverHandoff$1,
        manifest: build.assets,
        routeModules,
        serverHandoffString: serverHandoff.createServerHandoffString(serverHandoff$1)
      };
      let handleDocumentRequest2 = build.entry.module.default;
      try {
        return await handleDocumentRequest2(request, responseStatusCode, responseHeaders, entryContext);
      } catch (error) {
        responseStatusCode = 500;
        appState.trackBoundaries = false;
        appState.error = await errors.serializeError(error);
        entryContext.serverHandoffString = serverHandoff.createServerHandoffString(serverHandoff$1);
        try {
          return await handleDocumentRequest2(request, responseStatusCode, responseHeaders, entryContext);
        } catch (error2) {
          if (serverMode !== mode.ServerMode.Test) {
            console.error(error2);
          }
          let message = "Unexpected Server Error";
          if (serverMode === mode.ServerMode.Development) {
            message += `

${String(error2)}`;
          }
          return new Response(message, {
            status: 500,
            headers: {
              "Content-Type": "text/plain"
            }
          });
        }
      }
    }
    async function handleResourceRequest({
      loadContext,
      matches,
      request,
      serverMode
    }) {
      let match = matches.slice(-1)[0];
      try {
        if (isActionRequest(request)) {
          return await data.callRouteAction({
            match,
            loadContext,
            request
          });
        } else {
          return await data.callRouteLoader({
            match,
            loadContext,
            request
          });
        }
      } catch (error) {
        if (serverMode !== mode.ServerMode.Test) {
          console.error(error);
        }
        let message = "Unexpected Server Error";
        if (serverMode === mode.ServerMode.Development) {
          message += `

${String(error)}`;
        }
        return new Response(message, {
          status: 500,
          headers: {
            "Content-Type": "text/plain"
          }
        });
      }
    }
    var validActionMethods = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH", "DELETE"]);
    function isActionRequest({
      method
    }) {
      return validActionMethods.has(method.toUpperCase());
    }
    var validRequestMethods = /* @__PURE__ */ new Set(["GET", "HEAD", ...validActionMethods]);
    function isValidRequestMethod({
      method
    }) {
      return validRequestMethods.has(method.toUpperCase());
    }
    async function errorBoundaryError(error, status) {
      return responses.json(await errors.serializeError(error), {
        status,
        headers: {
          "X-Remix-Error": "yes"
        }
      });
    }
    function isIndexRequestUrl(url) {
      return url.searchParams.getAll("index").some((param) => param === "");
    }
    function getRequestMatch(url, matches) {
      let match = matches.slice(-1)[0];
      if (!isIndexRequestUrl(url) && match.route.id.endsWith("/index")) {
        return matches.slice(-2)[0];
      }
      return match;
    }
    function getDeepestRouteIdWithBoundary(matches, key) {
      let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
      return matched ? matched.route.id : null;
    }
    function getMatchesUpToDeepestBoundary(matches, key) {
      let deepestBoundaryIndex = -1;
      matches.forEach((match, index) => {
        if (match.route.module[key]) {
          deepestBoundaryIndex = index;
        }
      });
      if (deepestBoundaryIndex === -1) {
        return [];
      }
      return matches.slice(0, deepestBoundaryIndex + 1);
    }
    function getRenderableMatches(matches, appState) {
      if (!matches) {
        return null;
      }
      if (!appState.catch && !appState.error) {
        return matches;
      }
      let lastRenderableIndex = -1;
      matches.forEach((match, index) => {
        let id = match.route.id;
        if (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) {
          lastRenderableIndex = index;
        }
      });
      return matches.slice(0, lastRenderableIndex + 1);
    }
    exports.createRequestHandler = createRequestHandler;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions.js
var require_sessions = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var cookies = require_cookies();
    var warnings = require_warnings();
    function flash(name) {
      return `__flash_${name}__`;
    }
    var createSession = (initialData = {}, id = "") => {
      let map = new Map(Object.entries(initialData));
      return {
        get id() {
          return id;
        },
        get data() {
          return Object.fromEntries(map);
        },
        has(name) {
          return map.has(name) || map.has(flash(name));
        },
        get(name) {
          if (map.has(name))
            return map.get(name);
          let flashName = flash(name);
          if (map.has(flashName)) {
            let value = map.get(flashName);
            map.delete(flashName);
            return value;
          }
          return void 0;
        },
        set(name, value) {
          map.set(name, value);
        },
        flash(name, value) {
          map.set(flash(name), value);
        },
        unset(name) {
          map.delete(name);
        }
      };
    };
    var isSession = (object) => {
      return object != null && typeof object.id === "string" && typeof object.data !== "undefined" && typeof object.has === "function" && typeof object.get === "function" && typeof object.set === "function" && typeof object.flash === "function" && typeof object.unset === "function";
    };
    var createSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg,
      createData,
      readData,
      updateData,
      deleteData
    }) => {
      let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || "__session", cookieArg);
      warnOnceAboutSigningSessionCookie(cookie);
      return {
        async getSession(cookieHeader, options) {
          let id = cookieHeader && await cookie.parse(cookieHeader, options);
          let data = id && await readData(id);
          return createSession(data || {}, id || "");
        },
        async commitSession(session, options) {
          let {
            id,
            data
          } = session;
          if (id) {
            await updateData(id, data, cookie.expires);
          } else {
            id = await createData(data, cookie.expires);
          }
          return cookie.serialize(id, options);
        },
        async destroySession(session, options) {
          await deleteData(session.id);
          return cookie.serialize("", {
            ...options,
            expires: new Date(0)
          });
        }
      };
    };
    function warnOnceAboutSigningSessionCookie(cookie) {
      warnings.warnOnce(cookie.isSigned, `The "${cookie.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://remix.run/api/remix#signing-cookies for more information.`);
    }
    exports.createSession = createSession;
    exports.createSessionStorageFactory = createSessionStorageFactory;
    exports.isSession = isSession;
    exports.warnOnceAboutSigningSessionCookie = warnOnceAboutSigningSessionCookie;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js
var require_cookieStorage = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions/cookieStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var cookies = require_cookies();
    var sessions = require_sessions();
    var createCookieSessionStorageFactory = (createCookie) => ({
      cookie: cookieArg
    } = {}) => {
      let cookie = cookies.isCookie(cookieArg) ? cookieArg : createCookie((cookieArg === null || cookieArg === void 0 ? void 0 : cookieArg.name) || "__session", cookieArg);
      sessions.warnOnceAboutSigningSessionCookie(cookie);
      return {
        async getSession(cookieHeader, options) {
          return sessions.createSession(cookieHeader && await cookie.parse(cookieHeader, options) || {});
        },
        async commitSession(session, options) {
          let serializedCookie = await cookie.serialize(session.data, options);
          if (serializedCookie.length > 4096) {
            throw new Error("Cookie length will exceed browser maximum. Length: " + serializedCookie.length);
          }
          return serializedCookie;
        },
        async destroySession(_session, options) {
          return cookie.serialize("", {
            ...options,
            expires: new Date(0)
          });
        }
      };
    };
    exports.createCookieSessionStorageFactory = createCookieSessionStorageFactory;
  }
});

// node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js
var require_memoryStorage = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/sessions/memoryStorage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var createMemorySessionStorageFactory = (createSessionStorage) => ({
      cookie
    } = {}) => {
      let uniqueId = 0;
      let map = /* @__PURE__ */ new Map();
      return createSessionStorage({
        cookie,
        async createData(data, expires) {
          let id = (++uniqueId).toString();
          map.set(id, {
            data,
            expires
          });
          return id;
        },
        async readData(id) {
          if (map.has(id)) {
            let {
              data,
              expires
            } = map.get(id);
            if (!expires || expires > new Date()) {
              return data;
            }
            if (expires)
              map.delete(id);
          }
          return null;
        },
        async updateData(id, data, expires) {
          map.set(id, {
            data,
            expires
          });
        },
        async deleteData(id) {
          map.delete(id);
        }
      });
    };
    exports.createMemorySessionStorageFactory = createMemorySessionStorageFactory;
  }
});

// node_modules/@remix-run/server-runtime/dist/upload/errors.js
var require_errors2 = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/upload/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var MaxPartSizeExceededError = class extends Error {
      constructor(field, maxBytes) {
        super(`Field "${field}" exceeded upload size of ${maxBytes} bytes.`);
        this.field = field;
        this.maxBytes = maxBytes;
      }
    };
    exports.MaxPartSizeExceededError = MaxPartSizeExceededError;
  }
});

// node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js
var require_memoryUploadHandler = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/upload/memoryUploadHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var errors = require_errors2();
    function createMemoryUploadHandler({
      filter,
      maxPartSize = 3e6
    } = {}) {
      return async ({
        filename,
        contentType,
        name,
        data
      }) => {
        if (filter && !await filter({
          filename,
          contentType,
          name
        })) {
          return void 0;
        }
        let size = 0;
        let chunks = [];
        for await (let chunk of data) {
          size += chunk.byteLength;
          if (size > maxPartSize) {
            throw new errors.MaxPartSizeExceededError(name, maxPartSize);
          }
          chunks.push(chunk);
        }
        if (typeof filename === "string") {
          return new File(chunks, filename, {
            type: contentType
          });
        }
        return await new Blob(chunks, {
          type: contentType
        }).text();
      };
    }
    exports.createMemoryUploadHandler = createMemoryUploadHandler;
  }
});

// node_modules/@remix-run/server-runtime/dist/index.js
var require_dist = __commonJS({
  "node_modules/@remix-run/server-runtime/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var cookies = require_cookies();
    var formData = require_formData();
    var responses = require_responses();
    var server = require_server();
    var sessions = require_sessions();
    var cookieStorage = require_cookieStorage();
    var memoryStorage = require_memoryStorage();
    var memoryUploadHandler = require_memoryUploadHandler();
    var errors = require_errors2();
    exports.createCookieFactory = cookies.createCookieFactory;
    exports.isCookie = cookies.isCookie;
    exports.unstable_composeUploadHandlers = formData.composeUploadHandlers;
    exports.unstable_parseMultipartFormData = formData.parseMultipartFormData;
    exports.json = responses.json;
    exports.redirect = responses.redirect;
    exports.createRequestHandler = server.createRequestHandler;
    exports.createSession = sessions.createSession;
    exports.createSessionStorageFactory = sessions.createSessionStorageFactory;
    exports.isSession = sessions.isSession;
    exports.createCookieSessionStorageFactory = cookieStorage.createCookieSessionStorageFactory;
    exports.createMemorySessionStorageFactory = memoryStorage.createMemorySessionStorageFactory;
    exports.unstable_createMemoryUploadHandler = memoryUploadHandler.createMemoryUploadHandler;
    exports.MaxPartSizeExceededError = errors.MaxPartSizeExceededError;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BoolAsString: () => BoolAsString,
  CheckboxAsString: () => CheckboxAsString,
  IntAsString: () => IntAsString,
  NumAsString: () => NumAsString,
  parseForm: () => parseForm,
  parseFormSafe: () => parseFormSafe,
  parseParams: () => parseParams,
  parseParamsSafe: () => parseParamsSafe,
  parseQuery: () => parseQuery,
  parseQuerySafe: () => parseQuerySafe,
  zx: () => zx
});
module.exports = __toCommonJS(src_exports);

// src/parsers.ts
var import_zod = require("zod");

// src/errors.ts
var import_server_runtime = __toESM(require_dist());
var DEFAULT_ERROR_MESSAGE = "Bad Request";
var DEFAULT_ERROR_STATUS = 400;
function createErrorResponse(options = {}) {
  const statusText = (options == null ? void 0 : options.message) || DEFAULT_ERROR_MESSAGE;
  const status = (options == null ? void 0 : options.status) || DEFAULT_ERROR_STATUS;
  return (0, import_server_runtime.json)(statusText, { status, statusText });
}

// src/parsers.ts
function parseParams(params, schema, options) {
  try {
    const finalSchema = schema instanceof import_zod.ZodType ? schema : import_zod.z.object(schema);
    return finalSchema.parse(params);
  } catch (error) {
    throw createErrorResponse(options);
  }
}
function parseParamsSafe(params, schema) {
  const finalSchema = schema instanceof import_zod.ZodType ? schema : import_zod.z.object(schema);
  return finalSchema.safeParse(params);
}
function parseQuery(request, schema, options) {
  try {
    const searchParams = isURLSearchParams(request) ? request : getSearchParamsFromRequest(request);
    const params = parseSearchParams(searchParams, options == null ? void 0 : options.parser);
    const finalSchema = schema instanceof import_zod.ZodType ? schema : import_zod.z.object(schema);
    return finalSchema.parse(params);
  } catch (error) {
    throw createErrorResponse(options);
  }
}
function parseQuerySafe(request, schema, options) {
  const searchParams = isURLSearchParams(request) ? request : getSearchParamsFromRequest(request);
  const params = parseSearchParams(searchParams, options == null ? void 0 : options.parser);
  const finalSchema = schema instanceof import_zod.ZodType ? schema : import_zod.z.object(schema);
  return finalSchema.safeParse(params);
}
async function parseForm(request, schema, options) {
  try {
    const formData = isFormData(request) ? request : await request.clone().formData();
    const data = await parseFormData(formData, options == null ? void 0 : options.parser);
    const finalSchema = schema instanceof import_zod.ZodType ? schema : import_zod.z.object(schema);
    return finalSchema.parseAsync(data);
  } catch (error) {
    throw createErrorResponse(options);
  }
}
async function parseFormSafe(request, schema, options) {
  const formData = isFormData(request) ? request : await request.clone().formData();
  const data = await parseFormData(formData, options == null ? void 0 : options.parser);
  const finalSchema = schema instanceof import_zod.ZodType ? schema : import_zod.z.object(schema);
  return finalSchema.safeParseAsync(data);
}
function isObjectEntry([, value]) {
  return value instanceof Object;
}
function parseFormData(formData, customParser) {
  const objectEntries = [...formData.entries()].filter(isObjectEntry);
  objectEntries.forEach(([key, value]) => {
    formData.set(key, JSON.stringify(value));
  });
  return parseSearchParams(new URLSearchParams(formData), customParser);
}
function parseSearchParams(searchParams, customParser) {
  const parser = customParser || parseSearchParamsDefault;
  return parser(searchParams);
}
var parseSearchParamsDefault = (searchParams) => {
  const values = {};
  for (const [key, value] of searchParams) {
    const currentVal = values[key];
    if (currentVal && Array.isArray(currentVal)) {
      currentVal.push(value);
    } else if (currentVal) {
      values[key] = [currentVal, value];
    } else {
      values[key] = value;
    }
  }
  return values;
};
function getSearchParamsFromRequest(request) {
  const url = new URL(request.url);
  return url.searchParams;
}
function isFormData(value) {
  return getObjectTypeName(value) === "FormData";
}
function isURLSearchParams(value) {
  return getObjectTypeName(value) === "URLSearchParams";
}
function getObjectTypeName(value) {
  return toString.call(value).slice(8, -1);
}

// src/schemas.ts
var import_zod2 = require("zod");
var BoolAsString = import_zod2.z.string().regex(/^(true|false)$/, 'Must be a boolean string ("true" or "false")').transform((value) => value === "true");
var CheckboxAsString = import_zod2.z.literal("on").optional().transform((value) => value === "on");
var IntAsString = import_zod2.z.string().regex(/^-?\d+$/, "Must be an integer string").transform((val) => parseInt(val, 10));
var NumAsString = import_zod2.z.string().regex(/^-?\d*\.?\d+$/, "Must be a number string").transform(Number);

// src/index.ts
var zx = {
  parseParams,
  parseParamsSafe,
  parseQuery,
  parseQuerySafe,
  parseForm,
  parseFormSafe,
  BoolAsString,
  CheckboxAsString,
  IntAsString,
  NumAsString
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BoolAsString,
  CheckboxAsString,
  IntAsString,
  NumAsString,
  parseForm,
  parseFormSafe,
  parseParams,
  parseParamsSafe,
  parseQuery,
  parseQuerySafe,
  zx
});
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @remix-run/server-runtime v1.7.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.3.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
