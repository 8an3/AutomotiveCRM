import {
  usePopoverDisclosure
} from "../__chunks/6O3TZMB4.js";
import "../__chunks/LSTZ5Q72.js";
import "../__chunks/24P2K6AU.js";
import "../__chunks/OQUXG6FE.js";
import {
  SelectArrow
} from "../__chunks/MHR7JFVW.js";
import "../__chunks/TFLZHAF5.js";
import {
  useCompositeTypeahead
} from "../__chunks/KSVEVAMH.js";
import {
  SelectContext
} from "../__chunks/EEVSGAZW.js";
import "../__chunks/6GS36SYX.js";
import "../__chunks/D6NPK2DL.js";
import "../__chunks/4QNHBDVS.js";
import "../__chunks/OXPV2NBK.js";
import "../__chunks/AGWM73EZ.js";
import "../__chunks/BMLNRUFQ.js";
import "../__chunks/Z3X3QN6P.js";
import {
  VisuallyHidden
} from "../__chunks/JQEVJM46.js";
import {
  createComponent,
  createElement,
  createHook
} from "../__chunks/5ETIGB6O.js";
import {
  useBooleanEvent,
  useEvent,
  useForkRef,
  useWrapElement
} from "../__chunks/ASYR66PQ.js";
import "../__chunks/SXC6BPOF.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "../__chunks/4BKCJXBM.js";

// src/select/select.tsx
import { useEffect, useMemo, useRef, useState } from "react";
import { getPopupRole } from "@ariakit/core/utils/dom";
import { queueBeforeEvent } from "@ariakit/core/utils/events";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
function getSelectedValues(select) {
  return Array.from(select.selectedOptions).map((option) => option.value);
}
function nextWithValue(store, next) {
  return () => {
    const nextId = next();
    if (!nextId)
      return;
    let i = 0;
    let nextItem = store.item(nextId);
    const firstItem = nextItem;
    while (nextItem && nextItem.value == null) {
      const nextId2 = next(++i);
      if (!nextId2)
        return;
      nextItem = store.item(nextId2);
      if (nextItem === firstItem)
        break;
    }
    return nextItem == null ? void 0 : nextItem.id;
  };
}
var useSelect = createHook(
  (_a) => {
    var _b = _a, {
      store,
      name,
      form,
      required,
      showOnKeyDown = true,
      moveOnKeyDown = true,
      toggleOnClick = false,
      toggleOnPress = !toggleOnClick
    } = _b, props = __objRest(_b, [
      "store",
      "name",
      "form",
      "required",
      "showOnKeyDown",
      "moveOnKeyDown",
      "toggleOnClick",
      "toggleOnPress"
    ]);
    toggleOnPress = toggleOnClick ? false : toggleOnPress;
    const onKeyDownProp = props.onKeyDown;
    const showOnKeyDownProp = useBooleanEvent(showOnKeyDown);
    const moveOnKeyDownProp = useBooleanEvent(moveOnKeyDown);
    const toggleOnPressProp = useBooleanEvent(toggleOnPress);
    const placement = store.useState("placement");
    const dir = placement.split("-")[0];
    const value = store.useState("value");
    const multiSelectable = Array.isArray(value);
    const onKeyDown = useEvent((event) => {
      var _a2;
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented)
        return;
      const { orientation, items: items2, activeId } = store.getState();
      if (event.key === " " || event.key === "Enter") {
        if (toggleOnPressProp(event)) {
          event.preventDefault();
          store.toggle();
        }
      }
      const isVertical = orientation !== "horizontal";
      const isHorizontal = orientation !== "vertical";
      const isGrid = !!((_a2 = items2.find(
        (item) => !item.disabled && item.value != null
      )) == null ? void 0 : _a2.rowId);
      const moveKeyMap = {
        ArrowUp: (isGrid || isVertical) && nextWithValue(store, store.up),
        ArrowRight: (isGrid || isHorizontal) && nextWithValue(store, store.next),
        ArrowDown: (isGrid || isVertical) && nextWithValue(store, store.down),
        ArrowLeft: (isGrid || isHorizontal) && nextWithValue(store, store.previous)
      };
      const getId = moveKeyMap[event.key];
      if (getId && moveOnKeyDownProp(event)) {
        event.preventDefault();
        store.move(getId());
      }
      const isTopOrBottom = dir === "top" || dir === "bottom";
      const isLeft = dir === "left";
      const isRight = dir === "right";
      const canShowKeyMap = {
        ArrowDown: isTopOrBottom,
        ArrowUp: isTopOrBottom,
        ArrowLeft: isLeft,
        ArrowRight: isRight
      };
      const canShow = canShowKeyMap[event.key];
      if (canShow && showOnKeyDownProp(event)) {
        event.preventDefault();
        store.show();
        store.move(activeId);
      }
    });
    const onMouseDownProp = props.onMouseDown;
    const onMouseDown = useEvent((event) => {
      onMouseDownProp == null ? void 0 : onMouseDownProp(event);
      if (event.defaultPrevented)
        return;
      if (event.button)
        return;
      if (event.ctrlKey)
        return;
      if (!toggleOnPressProp(event))
        return;
      const element = event.currentTarget;
      queueBeforeEvent(element, "focusin", () => {
        store.setDisclosureElement(element);
        store.toggle();
      });
    });
    props = useWrapElement(
      props,
      (element) => /* @__PURE__ */ jsx(SelectContext.Provider, { value: store, children: element }),
      [store]
    );
    const [autofill, setAutofill] = useState(false);
    const nativeSelectChangedRef = useRef(false);
    useEffect(() => {
      const nativeSelectChanged = nativeSelectChangedRef.current;
      nativeSelectChangedRef.current = false;
      if (nativeSelectChanged)
        return;
      setAutofill(false);
    }, [value]);
    const labelId = store.useState((state) => {
      var _a2;
      return (_a2 = state.labelElement) == null ? void 0 : _a2.id;
    });
    const label = props["aria-label"];
    const labelledBy = props["aria-labelledby"] || labelId;
    const items = store.useState("items");
    const values = useMemo(
      // Filter out items without value and duplicate values.
      () => [...new Set(items.map((i) => i.value).filter((v) => v != null))],
      [items]
    );
    props = useWrapElement(
      props,
      (element) => {
        if (!name)
          return element;
        return /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(
            VisuallyHidden,
            {
              as: "select",
              tabIndex: -1,
              "aria-hidden": true,
              "aria-label": label,
              "aria-labelledby": labelledBy,
              name,
              form,
              required,
              value,
              multiple: multiSelectable,
              onFocus: () => {
                var _a2;
                return (_a2 = store.getState().selectElement) == null ? void 0 : _a2.focus();
              },
              onChange: (event) => {
                nativeSelectChangedRef.current = true;
                setAutofill(true);
                store.setValue(
                  multiSelectable ? getSelectedValues(event.target) : event.target.value
                );
              },
              children: values.map((value2) => /* @__PURE__ */ jsx("option", { value: value2, children: value2 }, value2))
            }
          ),
          element
        ] });
      },
      [
        store,
        label,
        labelledBy,
        name,
        form,
        required,
        value,
        multiSelectable,
        values
      ]
    );
    const children = /* @__PURE__ */ jsxs(Fragment, { children: [
      value,
      /* @__PURE__ */ jsx(SelectArrow, {})
    ] });
    const contentElement = store.useState("contentElement");
    props = __spreadProps(__spreadValues({
      role: "combobox",
      "aria-autocomplete": "none",
      "aria-labelledby": labelId,
      "aria-haspopup": getPopupRole(contentElement, "listbox"),
      "data-autofill": autofill ? "" : void 0,
      "data-name": name,
      children
    }, props), {
      ref: useForkRef(store.setSelectElement, props.ref),
      onKeyDown,
      onMouseDown
    });
    props = usePopoverDisclosure(__spreadValues({ store, toggleOnClick }, props));
    props = useCompositeTypeahead(__spreadValues({ store }, props));
    return props;
  }
);
var Select = createComponent((props) => {
  const htmlProps = useSelect(props);
  return createElement("button", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Select.displayName = "Select";
}
export {
  Select,
  useSelect
};
