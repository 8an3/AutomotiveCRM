import {
  useCommand
} from "./4QNHBDVS.js";
import {
  useCollectionItem
} from "./X7UZWWYG.js";
import {
  focusSilently,
  getEnabledItem,
  isItem
} from "./OXPV2NBK.js";
import {
  CompositeContext,
  CompositeItemContext,
  CompositeRowContext
} from "./Z3X3QN6P.js";
import {
  createElement,
  createHook,
  createMemoComponent
} from "./5ETIGB6O.js";
import {
  useStoreState
} from "./AV5WE37O.js";
import {
  useBooleanEvent,
  useEvent,
  useForkRef,
  useId,
  useSafeLayoutEffect,
  useWrapElement
} from "./ASYR66PQ.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./4BKCJXBM.js";

// src/composite/composite-item.tsx
import { useCallback, useContext, useMemo, useRef, useState } from "react";
import {
  getScrollingElement,
  isButton,
  isTextField
} from "@ariakit/core/utils/dom";
import { isPortalEvent, isSelfTarget } from "@ariakit/core/utils/events";
import { jsx } from "react/jsx-runtime";
function isEditableElement(element) {
  if (element.isContentEditable)
    return true;
  if (isTextField(element))
    return true;
  return element.tagName === "INPUT" && !isButton(element);
}
function getNextPageOffset(scrollingElement, pageUp = false) {
  const height = scrollingElement.clientHeight;
  const { top } = scrollingElement.getBoundingClientRect();
  const pageSize = Math.max(height * 0.875, height - 40) * 1.5;
  const pageOffset = pageUp ? height - pageSize + top : pageSize + top;
  if (scrollingElement.tagName === "HTML") {
    return pageOffset + scrollingElement.scrollTop;
  }
  return pageOffset;
}
function getItemOffset(itemElement, pageUp = false) {
  const { top } = itemElement.getBoundingClientRect();
  if (pageUp) {
    return top + itemElement.clientHeight;
  }
  return top;
}
function findNextPageItemId(element, store, next, pageUp = false) {
  var _a;
  if (!store)
    return;
  if (!next)
    return;
  const { renderedItems } = store.getState();
  const scrollingElement = getScrollingElement(element);
  if (!scrollingElement)
    return;
  const nextPageOffset = getNextPageOffset(scrollingElement, pageUp);
  let id;
  let prevDifference;
  for (let i = 0; i < renderedItems.length; i += 1) {
    const previousId = id;
    id = next(i);
    if (!id)
      break;
    if (id === previousId)
      continue;
    const itemElement = (_a = getEnabledItem(store, id)) == null ? void 0 : _a.element;
    if (!itemElement)
      continue;
    const itemOffset = getItemOffset(itemElement, pageUp);
    const difference = itemOffset - nextPageOffset;
    const absDifference = Math.abs(difference);
    if (pageUp && difference <= 0 || !pageUp && difference >= 0) {
      if (prevDifference !== void 0 && prevDifference < absDifference) {
        id = previousId;
      }
      break;
    }
    prevDifference = absDifference;
  }
  return id;
}
function targetIsAnotherItem(event, store) {
  if (isSelfTarget(event))
    return false;
  return isItem(store, event.target);
}
function useRole(ref, props) {
  const roleProp = props.role;
  const [role, setRole] = useState(roleProp);
  useSafeLayoutEffect(() => {
    const element = ref.current;
    if (!element)
      return;
    setRole(element.getAttribute("role") || roleProp);
  }, [roleProp]);
  return role;
}
function requiresAriaSelected(role) {
  return role === "option" || role === "treeitem";
}
function supportsAriaSelected(role) {
  if (role === "option")
    return true;
  if (role === "tab")
    return true;
  if (role === "treeitem")
    return true;
  if (role === "gridcell")
    return true;
  if (role === "row")
    return true;
  if (role === "columnheader")
    return true;
  if (role === "rowheader")
    return true;
  return false;
}
var useCompositeItem = createHook(
  (_a) => {
    var _b = _a, {
      store,
      rowId: rowIdProp,
      preventScrollOnKeyDown = false,
      moveOnKeyPress = true,
      getItem: getItemProp
    } = _b, props = __objRest(_b, [
      "store",
      "rowId",
      "preventScrollOnKeyDown",
      "moveOnKeyPress",
      "getItem"
    ]);
    const context = useContext(CompositeContext);
    store = store || context;
    const id = useId(props.id);
    const ref = useRef(null);
    const row = useContext(CompositeRowContext);
    const rowId = useStoreState(store, (state) => {
      if (rowIdProp)
        return rowIdProp;
      if (!(row == null ? void 0 : row.baseElement))
        return;
      if (row.baseElement !== state.baseElement)
        return;
      return row.id;
    });
    const trulyDisabled = props.disabled && !props.accessibleWhenDisabled;
    const getItem = useCallback(
      (item) => {
        const nextItem = __spreadProps(__spreadValues({}, item), {
          id: id || item.id,
          rowId,
          disabled: !!trulyDisabled
        });
        if (getItemProp) {
          return getItemProp(nextItem);
        }
        return nextItem;
      },
      [id, rowId, trulyDisabled, getItemProp]
    );
    const onFocusProp = props.onFocus;
    const hasFocusedComposite = useRef(false);
    const onFocus = useEvent((event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      if (event.defaultPrevented)
        return;
      if (isPortalEvent(event))
        return;
      if (!id)
        return;
      if (!store)
        return;
      const { activeId, virtualFocus: virtualFocus2, baseElement: baseElement2 } = store.getState();
      if (targetIsAnotherItem(event, store))
        return;
      if (activeId !== id) {
        store.setActiveId(id);
      }
      if (!virtualFocus2)
        return;
      if (!isSelfTarget(event))
        return;
      if (isEditableElement(event.currentTarget))
        return;
      if (!baseElement2)
        return;
      hasFocusedComposite.current = true;
      const fromComposite = event.relatedTarget === baseElement2 || isItem(store, event.relatedTarget);
      if (fromComposite) {
        focusSilently(baseElement2);
      } else {
        baseElement2.focus();
      }
    });
    const onBlurCaptureProp = props.onBlurCapture;
    const onBlurCapture = useEvent((event) => {
      onBlurCaptureProp == null ? void 0 : onBlurCaptureProp(event);
      if (event.defaultPrevented)
        return;
      const state = store == null ? void 0 : store.getState();
      if ((state == null ? void 0 : state.virtualFocus) && hasFocusedComposite.current) {
        hasFocusedComposite.current = false;
        event.preventDefault();
        event.stopPropagation();
      }
    });
    const onKeyDownProp = props.onKeyDown;
    const preventScrollOnKeyDownProp = useBooleanEvent(preventScrollOnKeyDown);
    const moveOnKeyPressProp = useBooleanEvent(moveOnKeyPress);
    const onKeyDown = useEvent((event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented)
        return;
      if (!isSelfTarget(event))
        return;
      if (!store)
        return;
      const { currentTarget } = event;
      const state = store.getState();
      const item = store.item(id);
      const isGrid = !!(item == null ? void 0 : item.rowId);
      const isVertical = state.orientation !== "horizontal";
      const isHorizontal = state.orientation !== "vertical";
      const keyMap = {
        ArrowUp: (isGrid || isVertical) && store.up,
        ArrowRight: (isGrid || isHorizontal) && store.next,
        ArrowDown: (isGrid || isVertical) && store.down,
        ArrowLeft: (isGrid || isHorizontal) && store.previous,
        Home: () => {
          if (!isGrid || event.ctrlKey) {
            return store == null ? void 0 : store.first();
          }
          return store == null ? void 0 : store.previous(-1);
        },
        End: () => {
          if (!isGrid || event.ctrlKey) {
            return store == null ? void 0 : store.last();
          }
          return store == null ? void 0 : store.next(-1);
        },
        PageUp: () => {
          return findNextPageItemId(currentTarget, store, store == null ? void 0 : store.up, true);
        },
        PageDown: () => {
          return findNextPageItemId(currentTarget, store, store == null ? void 0 : store.down);
        }
      };
      const action = keyMap[event.key];
      if (action) {
        const nextId = action();
        if (preventScrollOnKeyDownProp(event) || nextId !== void 0) {
          if (!moveOnKeyPressProp(event))
            return;
          event.preventDefault();
          store.move(nextId);
        }
      }
    });
    const baseElement = useStoreState(
      store,
      (state) => state.baseElement || void 0
    );
    const providerValue = useMemo(
      () => ({ id, baseElement }),
      [id, baseElement]
    );
    props = useWrapElement(
      props,
      (element) => /* @__PURE__ */ jsx(CompositeItemContext.Provider, { value: providerValue, children: element }),
      [providerValue]
    );
    const isActiveItem = useStoreState(store, (state) => state.activeId === id);
    const role = useRole(ref, props);
    const virtualFocus = useStoreState(store, "virtualFocus");
    let ariaSelected;
    if (isActiveItem) {
      if (requiresAriaSelected(role)) {
        ariaSelected = true;
      } else if (virtualFocus && supportsAriaSelected(role)) {
        ariaSelected = true;
      }
    }
    const shouldTabIndex = useStoreState(
      store,
      (state) => !state.virtualFocus && isActiveItem
    );
    props = __spreadProps(__spreadValues({
      id,
      "aria-selected": ariaSelected,
      "data-active-item": isActiveItem ? "" : void 0
    }, props), {
      ref: useForkRef(ref, props.ref),
      tabIndex: shouldTabIndex !== false ? props.tabIndex : -1,
      onFocus,
      onBlurCapture,
      onKeyDown
    });
    props = useCommand(props);
    props = useCollectionItem(__spreadProps(__spreadValues({
      store
    }, props), {
      getItem,
      shouldRegisterItem: !!id ? props.shouldRegisterItem : false
    }));
    return props;
  }
);
var CompositeItem = createMemoComponent(
  (props) => {
    const htmlProps = useCompositeItem(props);
    return createElement("button", htmlProps);
  }
);
if (process.env.NODE_ENV !== "production") {
  CompositeItem.displayName = "CompositeItem";
}

export {
  useCompositeItem,
  CompositeItem
};
