import {
  FocusTrap
} from "./DIO64N2C.js";
import {
  PortalContext
} from "./LDDPB3PY.js";
import {
  createComponent,
  createElement,
  createHook
} from "./5ETIGB6O.js";
import {
  useForkRef,
  useSafeLayoutEffect,
  useWrapElement
} from "./ASYR66PQ.js";
import {
  setRef
} from "./SXC6BPOF.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./4BKCJXBM.js";

// src/portal/portal.tsx
import { useContext, useEffect, useRef, useState } from "react";
import { getDocument } from "@ariakit/core/utils/dom";
import { isFocusEventOutside } from "@ariakit/core/utils/events";
import {
  disableFocusIn,
  getNextTabbable,
  getPreviousTabbable,
  restoreFocusIn
} from "@ariakit/core/utils/focus";
import { createPortal } from "react-dom";
import { Fragment, jsx, jsxs } from "react/jsx-runtime";
function getRootElement(element) {
  return getDocument(element).body;
}
function getPortalElement(element, portalElement) {
  if (!portalElement) {
    return getDocument(element).createElement("div");
  }
  if (typeof portalElement === "function") {
    return portalElement(element);
  }
  return portalElement;
}
function getRandomId(prefix = "id") {
  return `${prefix ? `${prefix}-` : ""}${Math.random().toString(36).substr(2, 6)}`;
}
function queueFocus(element) {
  queueMicrotask(() => {
    element == null ? void 0 : element.focus();
  });
}
var usePortal = createHook(
  (_a) => {
    var _b = _a, { preserveTabOrder, portalElement, portalRef, portal = true } = _b, props = __objRest(_b, ["preserveTabOrder", "portalElement", "portalRef", "portal"]);
    const ref = useRef(null);
    const refProp = useForkRef(ref, props.ref);
    const context = useContext(PortalContext);
    const [portalNode, setPortalNode] = useState(null);
    const beforeOutsideRef = useRef(null);
    const beforeInsideRef = useRef(null);
    const afterInsideRef = useRef(null);
    const afterOutsideRef = useRef(null);
    useSafeLayoutEffect(() => {
      const element = ref.current;
      if (!element || !portal) {
        setPortalNode(null);
        return;
      }
      const portalEl = getPortalElement(element, portalElement);
      if (!portalEl) {
        setPortalNode(null);
        return;
      }
      const isPortalInDocument = portalEl.isConnected;
      if (!isPortalInDocument) {
        const rootElement = context || getRootElement(element);
        rootElement.appendChild(portalEl);
      }
      if (!portalEl.id) {
        portalEl.id = element.id ? `${element.id}-portal` : getRandomId();
      }
      setPortalNode(portalEl);
      setRef(portalRef, portalEl);
      if (isPortalInDocument)
        return;
      return () => {
        portalEl.remove();
        setRef(portalRef, null);
      };
    }, [portal, portalElement, context, portalRef]);
    useEffect(() => {
      if (!portalNode)
        return;
      if (!preserveTabOrder)
        return;
      let raf = 0;
      const onFocus = (event) => {
        if (!isFocusEventOutside(event))
          return;
        const focusing = event.type === "focusin";
        if (focusing)
          return restoreFocusIn(portalNode);
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          disableFocusIn(portalNode, true);
        });
      };
      portalNode.addEventListener("focusin", onFocus, true);
      portalNode.addEventListener("focusout", onFocus, true);
      return () => {
        portalNode.removeEventListener("focusin", onFocus, true);
        portalNode.removeEventListener("focusout", onFocus, true);
      };
    }, [portalNode, preserveTabOrder]);
    props = useWrapElement(
      props,
      (element) => {
        element = // While the portal node is not in the DOM, we need to pass the
        // current context to the portal context, otherwise it's going to
        // reset to the body element on nested portals.
        /* @__PURE__ */ jsx(PortalContext.Provider, { value: portalNode || context, children: element });
        if (!portal)
          return element;
        if (!portalNode) {
          return /* @__PURE__ */ jsx(
            "span",
            {
              ref: refProp,
              id: props.id,
              style: { position: "fixed" },
              hidden: true
            }
          );
        }
        element = /* @__PURE__ */ jsxs(Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ jsx(
            FocusTrap,
            {
              ref: beforeInsideRef,
              onFocus: (event) => {
                if (isFocusEventOutside(event, portalNode)) {
                  queueFocus(getNextTabbable());
                } else {
                  queueFocus(beforeOutsideRef.current);
                }
              }
            }
          ),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ jsx(
            FocusTrap,
            {
              ref: afterInsideRef,
              onFocus: (event) => {
                if (isFocusEventOutside(event, portalNode)) {
                  queueFocus(getPreviousTabbable());
                } else {
                  queueFocus(afterOutsideRef.current);
                }
              }
            }
          )
        ] });
        if (portalNode) {
          element = createPortal(element, portalNode);
        }
        element = /* @__PURE__ */ jsxs(Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ jsx(
            FocusTrap,
            {
              ref: beforeOutsideRef,
              onFocus: (event) => {
                if (isFocusEventOutside(event, portalNode)) {
                  queueFocus(beforeInsideRef.current);
                } else {
                  queueFocus(getPreviousTabbable());
                }
              }
            }
          ),
          preserveTabOrder && // We're using position: fixed here so that the browser doesn't
          // add margin to the element when setting gap on a parent element.
          /* @__PURE__ */ jsx("span", { "aria-owns": portalNode == null ? void 0 : portalNode.id, style: { position: "fixed" } }),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ jsx(
            FocusTrap,
            {
              ref: afterOutsideRef,
              onFocus: (event) => {
                if (isFocusEventOutside(event, portalNode)) {
                  queueFocus(afterInsideRef.current);
                } else {
                  queueFocus(getNextTabbable());
                }
              }
            }
          )
        ] });
        return element;
      },
      [portalNode, context, portal, props.id, preserveTabOrder]
    );
    props = __spreadProps(__spreadValues({}, props), {
      ref: refProp
    });
    return props;
  }
);
var Portal = createComponent((props) => {
  const htmlProps = usePortal(props);
  return createElement("div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Portal.displayName = "Portal";
}

export {
  usePortal,
  Portal
};
