import {
  useSafeLayoutEffect
} from "./ASYR66PQ.js";

// src/dialog/utils/use-nested-dialogs.tsx
import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useState
} from "react";
import { chain } from "@ariakit/core/utils/misc";
import { jsx } from "react/jsx-runtime";
var NestedDialogsContext = createContext({});
function useNestedDialogs(store) {
  const context = useContext(NestedDialogsContext);
  const [dialogs, setDialogs] = useState([]);
  const add = useCallback(
    (dialog) => {
      var _a;
      setDialogs((dialogs2) => [...dialogs2, dialog]);
      return chain((_a = context.add) == null ? void 0 : _a.call(context, dialog), () => {
        setDialogs((dialogs2) => dialogs2.filter((d) => d !== dialog));
      });
    },
    [context]
  );
  useSafeLayoutEffect(() => {
    return store.sync(
      (state) => {
        var _a;
        if (!state.contentElement)
          return;
        return (_a = context.add) == null ? void 0 : _a.call(context, state.contentElement);
      },
      ["contentElement"]
    );
  }, [store, context]);
  useSafeLayoutEffect(() => {
    var _a;
    return (_a = context.store) == null ? void 0 : _a.sync(
      (state) => {
        if (state.open)
          return;
        store.hide();
      },
      ["open"]
    );
  }, [context, store]);
  const providerValue = useMemo(() => ({ store, add }), [store, add]);
  const wrapElement = useCallback(
    (element) => /* @__PURE__ */ jsx(NestedDialogsContext.Provider, { value: providerValue, children: element }),
    [providerValue]
  );
  return { wrapElement, nestedDialogs: dialogs };
}

export {
  useNestedDialogs
};
