"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _C7Y26CUVcjs = require('./C7Y26CUV.cjs');


var _NS56XHXGcjs = require('./NS56XHXG.cjs');




var _7NAIPZYNcjs = require('./7NAIPZYN.cjs');




var _NREUHWTUcjs = require('./NREUHWTU.cjs');


var _2X5K3J7Ycjs = require('./2X5K3J7Y.cjs');




var _6455U47Tcjs = require('./6455U47T.cjs');

// src/portal/portal.tsx
var _react = require('react');
var _dom = require('@ariakit/core/utils/dom');
var _events = require('@ariakit/core/utils/events');





var _focus = require('@ariakit/core/utils/focus');
var _reactdom = require('react-dom');
var _jsxruntime = require('react/jsx-runtime');
function getRootElement(element) {
  return _dom.getDocument.call(void 0, element).body;
}
function getPortalElement(element, portalElement) {
  if (!portalElement) {
    return _dom.getDocument.call(void 0, element).createElement("div");
  }
  if (typeof portalElement === "function") {
    return portalElement(element);
  }
  return portalElement;
}
function getRandomId(prefix = "id") {
  return `${prefix ? `${prefix}-` : ""}${Math.random().toString(36).substr(2, 6)}`;
}
function queueFocus(element) {
  queueMicrotask(() => {
    element == null ? void 0 : element.focus();
  });
}
var usePortal = _7NAIPZYNcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, { preserveTabOrder, portalElement, portalRef, portal = true } = _b, props = _6455U47Tcjs.__objRest.call(void 0, _b, ["preserveTabOrder", "portalElement", "portalRef", "portal"]);
    const ref = _react.useRef.call(void 0, null);
    const refProp = _NREUHWTUcjs.useForkRef.call(void 0, ref, props.ref);
    const context = _react.useContext.call(void 0, _NS56XHXGcjs.PortalContext);
    const [portalNode, setPortalNode] = _react.useState.call(void 0, null);
    const beforeOutsideRef = _react.useRef.call(void 0, null);
    const beforeInsideRef = _react.useRef.call(void 0, null);
    const afterInsideRef = _react.useRef.call(void 0, null);
    const afterOutsideRef = _react.useRef.call(void 0, null);
    _NREUHWTUcjs.useSafeLayoutEffect.call(void 0, () => {
      const element = ref.current;
      if (!element || !portal) {
        setPortalNode(null);
        return;
      }
      const portalEl = getPortalElement(element, portalElement);
      if (!portalEl) {
        setPortalNode(null);
        return;
      }
      const isPortalInDocument = portalEl.isConnected;
      if (!isPortalInDocument) {
        const rootElement = context || getRootElement(element);
        rootElement.appendChild(portalEl);
      }
      if (!portalEl.id) {
        portalEl.id = element.id ? `${element.id}-portal` : getRandomId();
      }
      setPortalNode(portalEl);
      _2X5K3J7Ycjs.setRef.call(void 0, portalRef, portalEl);
      if (isPortalInDocument)
        return;
      return () => {
        portalEl.remove();
        _2X5K3J7Ycjs.setRef.call(void 0, portalRef, null);
      };
    }, [portal, portalElement, context, portalRef]);
    _react.useEffect.call(void 0, () => {
      if (!portalNode)
        return;
      if (!preserveTabOrder)
        return;
      let raf = 0;
      const onFocus = (event) => {
        if (!_events.isFocusEventOutside.call(void 0, event))
          return;
        const focusing = event.type === "focusin";
        if (focusing)
          return _focus.restoreFocusIn.call(void 0, portalNode);
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          _focus.disableFocusIn.call(void 0, portalNode, true);
        });
      };
      portalNode.addEventListener("focusin", onFocus, true);
      portalNode.addEventListener("focusout", onFocus, true);
      return () => {
        portalNode.removeEventListener("focusin", onFocus, true);
        portalNode.removeEventListener("focusout", onFocus, true);
      };
    }, [portalNode, preserveTabOrder]);
    props = _NREUHWTUcjs.useWrapElement.call(void 0, 
      props,
      (element) => {
        element = // While the portal node is not in the DOM, we need to pass the
        // current context to the portal context, otherwise it's going to
        // reset to the body element on nested portals.
        /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _NS56XHXGcjs.PortalContext.Provider, { value: portalNode || context, children: element });
        if (!portal)
          return element;
        if (!portalNode) {
          return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            "span",
            {
              ref: refProp,
              id: props.id,
              style: { position: "fixed" },
              hidden: true
            }
          );
        }
        element = /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _C7Y26CUVcjs.FocusTrap,
            {
              ref: beforeInsideRef,
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(_focus.getNextTabbable.call(void 0, ));
                } else {
                  queueFocus(beforeOutsideRef.current);
                }
              }
            }
          ),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _C7Y26CUVcjs.FocusTrap,
            {
              ref: afterInsideRef,
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(_focus.getPreviousTabbable.call(void 0, ));
                } else {
                  queueFocus(afterOutsideRef.current);
                }
              }
            }
          )
        ] });
        if (portalNode) {
          element = _reactdom.createPortal.call(void 0, element, portalNode);
        }
        element = /* @__PURE__ */ _jsxruntime.jsxs.call(void 0, _jsxruntime.Fragment, { children: [
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _C7Y26CUVcjs.FocusTrap,
            {
              ref: beforeOutsideRef,
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(beforeInsideRef.current);
                } else {
                  queueFocus(_focus.getPreviousTabbable.call(void 0, ));
                }
              }
            }
          ),
          preserveTabOrder && // We're using position: fixed here so that the browser doesn't
          // add margin to the element when setting gap on a parent element.
          /* @__PURE__ */ _jsxruntime.jsx.call(void 0, "span", { "aria-owns": portalNode == null ? void 0 : portalNode.id, style: { position: "fixed" } }),
          element,
          preserveTabOrder && portalNode && /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _C7Y26CUVcjs.FocusTrap,
            {
              ref: afterOutsideRef,
              onFocus: (event) => {
                if (_events.isFocusEventOutside.call(void 0, event, portalNode)) {
                  queueFocus(afterInsideRef.current);
                } else {
                  queueFocus(_focus.getNextTabbable.call(void 0, ));
                }
              }
            }
          )
        ] });
        return element;
      },
      [portalNode, context, portal, props.id, preserveTabOrder]
    );
    props = _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {}, props), {
      ref: refProp
    });
    return props;
  }
);
var Portal = _7NAIPZYNcjs.createComponent.call(void 0, (props) => {
  const htmlProps = usePortal(props);
  return _7NAIPZYNcjs.createElement.call(void 0, "div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Portal.displayName = "Portal";
}




exports.usePortal = usePortal; exports.Portal = Portal;
