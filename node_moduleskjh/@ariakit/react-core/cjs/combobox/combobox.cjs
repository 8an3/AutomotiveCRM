"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _CCVWD45Ycjs = require('../__chunks/CCVWD45Y.cjs');


var _5I6IQHKQcjs = require('../__chunks/5I6IQHKQ.cjs');
require('../__chunks/KLZID3QO.cjs');
require('../__chunks/NVBNDB5B.cjs');
require('../__chunks/LHHW5ZQP.cjs');
require('../__chunks/NVMBKFRB.cjs');




var _7NAIPZYNcjs = require('../__chunks/7NAIPZYN.cjs');









var _NREUHWTUcjs = require('../__chunks/NREUHWTU.cjs');
require('../__chunks/2X5K3J7Y.cjs');




var _6455U47Tcjs = require('../__chunks/6455U47T.cjs');

// src/combobox/combobox.ts
var _react = require('react');
var _dom = require('@ariakit/core/utils/dom');



var _events = require('@ariakit/core/utils/events');
var _misc = require('@ariakit/core/utils/misc');
function isFirstItemAutoSelected(items, activeValue, autoSelect) {
  if (!autoSelect)
    return false;
  const firstItem = items.find((item) => !item.disabled && item.value);
  return (firstItem == null ? void 0 : firstItem.value) === activeValue;
}
function hasCompletionString(value, activeValue) {
  if (!activeValue)
    return false;
  if (value == null)
    return false;
  value = _misc.normalizeString.call(void 0, value);
  return activeValue.length > value.length && activeValue.toLowerCase().indexOf(value.toLowerCase()) === 0;
}
function isInputEvent(event) {
  return event.type === "input";
}
var useCombobox = _7NAIPZYNcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      store,
      focusable = true,
      autoSelect: autoSelectProp = false,
      showOnChange = true,
      setValueOnChange = true,
      showOnMouseDown = true,
      setValueOnClick = true,
      showOnKeyDown = true,
      moveOnKeyPress = true,
      autoComplete = "list"
    } = _b, props = _6455U47Tcjs.__objRest.call(void 0, _b, [
      "store",
      "focusable",
      "autoSelect",
      "showOnChange",
      "setValueOnChange",
      "showOnMouseDown",
      "setValueOnClick",
      "showOnKeyDown",
      "moveOnKeyPress",
      "autoComplete"
    ]);
    const ref = _react.useRef.call(void 0, null);
    const [valueUpdated, forceValueUpdate] = _NREUHWTUcjs.useForceUpdate.call(void 0, );
    const valueChangedRef = _react.useRef.call(void 0, false);
    const composingRef = _react.useRef.call(void 0, false);
    const autoSelect = store.useState(
      (state) => !!autoSelectProp && state.virtualFocus
    );
    const inline = autoComplete === "inline" || autoComplete === "both";
    const [canInline, setCanInline] = _react.useState.call(void 0, inline);
    _NREUHWTUcjs.useUpdateLayoutEffect.call(void 0, () => {
      if (!inline)
        return;
      setCanInline(true);
    }, [inline]);
    const storeValue = store.useState("value");
    const activeValue = store.useState(
      (state) => inline && canInline ? state.activeValue : void 0
    );
    const items = store.useState("renderedItems");
    const open = store.useState("open");
    const value = _react.useMemo.call(void 0, () => {
      if (!inline)
        return storeValue;
      if (!canInline)
        return storeValue;
      const firstItemAutoSelected = isFirstItemAutoSelected(
        items,
        activeValue,
        autoSelect
      );
      if (firstItemAutoSelected) {
        if (hasCompletionString(storeValue, activeValue)) {
          const slice = (activeValue == null ? void 0 : activeValue.slice(storeValue.length)) || "";
          return storeValue + slice;
        }
        return storeValue;
      }
      return activeValue || storeValue;
    }, [inline, canInline, items, activeValue, autoSelect, storeValue]);
    _react.useEffect.call(void 0, () => {
      const element = ref.current;
      if (!element)
        return;
      const onCompositeItemMove = () => setCanInline(true);
      element.addEventListener("combobox-item-move", onCompositeItemMove);
      return () => {
        element.removeEventListener("combobox-item-move", onCompositeItemMove);
      };
    }, []);
    _react.useEffect.call(void 0, () => {
      if (!inline)
        return;
      if (!canInline)
        return;
      if (!activeValue)
        return;
      const firstItemAutoSelected = isFirstItemAutoSelected(
        items,
        activeValue,
        autoSelect
      );
      if (!firstItemAutoSelected)
        return;
      if (!hasCompletionString(storeValue, activeValue))
        return;
      queueMicrotask(() => {
        const element = ref.current;
        if (!element)
          return;
        element.setSelectionRange(storeValue.length, activeValue.length);
      });
    }, [
      valueUpdated,
      inline,
      canInline,
      activeValue,
      items,
      autoSelect,
      storeValue
    ]);
    _NREUHWTUcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!storeValue)
        return;
      if (composingRef.current)
        return;
      valueChangedRef.current = true;
    }, [storeValue]);
    _NREUHWTUcjs.useSafeLayoutEffect.call(void 0, () => {
      if (open)
        return;
      valueChangedRef.current = false;
    }, [open]);
    _NREUHWTUcjs.useUpdateEffect.call(void 0, () => {
      var _a2;
      if (!autoSelect)
        return;
      if (!valueChangedRef.current)
        return;
      store.move((_a2 = store.first()) != null ? _a2 : null);
    }, [store, valueUpdated, storeValue, autoSelect, items]);
    _NREUHWTUcjs.useSafeLayoutEffect.call(void 0, () => {
      if (autoSelect)
        return;
      store.setActiveId(null);
    }, [valueUpdated, autoSelect, store]);
    const contentElement = store.useState("contentElement");
    _react.useEffect.call(void 0, () => {
      if (!inline)
        return;
      const combobox = ref.current;
      if (!combobox)
        return;
      const elements = [combobox, contentElement].filter(Boolean);
      const onBlur2 = (event) => {
        if (elements.every((el) => _events.isFocusEventOutside.call(void 0, event, el))) {
          store.setValue(value);
        }
      };
      elements.forEach((el) => el == null ? void 0 : el.addEventListener("focusout", onBlur2));
      return () => {
        elements.forEach((el) => el == null ? void 0 : el.removeEventListener("focusout", onBlur2));
      };
    }, [inline, contentElement, store, value]);
    const onChangeProp = props.onChange;
    const showOnChangeProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, showOnChange);
    const setValueOnChangeProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, setValueOnChange);
    const onChange = _NREUHWTUcjs.useEvent.call(void 0, (event) => {
      onChangeProp == null ? void 0 : onChangeProp(event);
      if (event.defaultPrevented)
        return;
      const { target } = event;
      const nativeEvent = event.nativeEvent;
      valueChangedRef.current = true;
      if (isInputEvent(nativeEvent)) {
        if (nativeEvent.isComposing) {
          valueChangedRef.current = false;
          composingRef.current = true;
        }
        if (inline) {
          const textInserted = nativeEvent.inputType === "insertText" || nativeEvent.inputType === "insertCompositionText";
          const caretAtEnd = target.selectionStart === target.value.length;
          setCanInline(textInserted && caretAtEnd);
        }
      }
      if (showOnChangeProp(event)) {
        store.show();
      }
      if (setValueOnChangeProp(event)) {
        store.setValue(target.value);
      }
      if (inline && autoSelect) {
        forceValueUpdate();
      }
      if (!autoSelect || !valueChangedRef.current) {
        store.setActiveId(null);
      }
    });
    const onCompositionEndProp = props.onCompositionEnd;
    const onCompositionEnd = _NREUHWTUcjs.useEvent.call(void 0, 
      (event) => {
        onCompositionEndProp == null ? void 0 : onCompositionEndProp(event);
        if (event.defaultPrevented)
          return;
        valueChangedRef.current = true;
        composingRef.current = false;
        if (!autoSelect)
          return;
        forceValueUpdate();
      }
    );
    const onMouseDownProp = props.onMouseDown;
    const setValueOnClickProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, setValueOnClick);
    const showOnMouseDownProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, showOnMouseDown);
    const onMouseDown = _NREUHWTUcjs.useEvent.call(void 0, (event) => {
      onMouseDownProp == null ? void 0 : onMouseDownProp(event);
      if (event.defaultPrevented)
        return;
      if (event.button)
        return;
      if (event.ctrlKey)
        return;
      store.setActiveId(null);
      if (setValueOnClickProp(event)) {
        store.setValue(value);
      }
      if (showOnMouseDownProp(event)) {
        _events.queueBeforeEvent.call(void 0, event.currentTarget, "mouseup", store.show);
      }
    });
    const onKeyDownProp = props.onKeyDown;
    const showOnKeyDownProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, showOnKeyDown);
    const onKeyDown = _NREUHWTUcjs.useEvent.call(void 0, 
      (event) => {
        onKeyDownProp == null ? void 0 : onKeyDownProp(event);
        if (event.defaultPrevented)
          return;
        valueChangedRef.current = false;
        if (event.ctrlKey)
          return;
        if (event.altKey)
          return;
        if (event.shiftKey)
          return;
        if (event.metaKey)
          return;
        const { open: open2, activeId } = store.getState();
        if (open2)
          return;
        if (activeId !== null)
          return;
        if (event.key === "ArrowUp" || event.key === "ArrowDown") {
          if (showOnKeyDownProp(event)) {
            event.preventDefault();
            store.show();
          }
        }
      }
    );
    const onBlurProp = props.onBlur;
    const onBlur = _NREUHWTUcjs.useEvent.call(void 0, (event) => {
      onBlurProp == null ? void 0 : onBlurProp(event);
      if (event.defaultPrevented)
        return;
      valueChangedRef.current = false;
    });
    const id = _NREUHWTUcjs.useId.call(void 0, props.id);
    props = _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {
      id,
      role: "combobox",
      "aria-autocomplete": autoComplete,
      "aria-haspopup": _dom.getPopupRole.call(void 0, contentElement, "listbox"),
      "aria-expanded": open,
      "aria-controls": contentElement == null ? void 0 : contentElement.id,
      value
    }, props), {
      ref: _NREUHWTUcjs.useForkRef.call(void 0, ref, props.ref),
      onChange,
      onCompositionEnd,
      onMouseDown,
      onKeyDown,
      onBlur
    });
    const moveOnKeyPressProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, moveOnKeyPress);
    props = _5I6IQHKQcjs.useComposite.call(void 0, _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {
      store,
      focusable
    }, props), {
      // Enable inline autocomplete when the user moves from the combobox input
      // to an item.
      moveOnKeyPress: (event) => {
        if (!moveOnKeyPressProp(event))
          return false;
        if (inline)
          setCanInline(true);
        return true;
      }
    }));
    props = _CCVWD45Ycjs.usePopoverAnchor.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, { store }, props));
    return _6455U47Tcjs.__spreadValues.call(void 0, { autoComplete: "off" }, props);
  }
);
var Combobox = _7NAIPZYNcjs.createComponent.call(void 0, (props) => {
  const htmlProps = useCombobox(props);
  return _7NAIPZYNcjs.createElement.call(void 0, "input", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Combobox.displayName = "Combobox";
}



exports.Combobox = Combobox; exports.useCombobox = useCombobox;
