import {
  createStore
} from "./BOKMNDR7.js";
import {
  chain,
  defaultValue
} from "./NWU4GBZ6.js";
import {
  getDocument
} from "./N6JW4ITM.js";
import {
  __spreadProps,
  __spreadValues
} from "./4BKCJXBM.js";

// src/collection/collection-store.ts
function isElementPreceding(a, b) {
  return Boolean(
    b.compareDocumentPosition(a) & Node.DOCUMENT_POSITION_PRECEDING
  );
}
function sortBasedOnDOMPosition(items) {
  const pairs = items.map((item, index) => [index, item]);
  let isOrderDifferent = false;
  pairs.sort(([indexA, a], [indexB, b]) => {
    const elementA = a.element;
    const elementB = b.element;
    if (elementA === elementB)
      return 0;
    if (!elementA || !elementB)
      return 0;
    if (isElementPreceding(elementA, elementB)) {
      if (indexA > indexB) {
        isOrderDifferent = true;
      }
      return -1;
    }
    if (indexA < indexB) {
      isOrderDifferent = true;
    }
    return 1;
  });
  if (isOrderDifferent) {
    return pairs.map(([_, item]) => item);
  }
  return items;
}
function getCommonParent(items) {
  var _a;
  const firstItem = items.find((item) => !!item.element);
  const lastItem = [...items].reverse().find((item) => !!item.element);
  let parentElement = (_a = firstItem == null ? void 0 : firstItem.element) == null ? void 0 : _a.parentElement;
  while (parentElement && (lastItem == null ? void 0 : lastItem.element)) {
    const parent = parentElement;
    if (lastItem && parent.contains(lastItem.element)) {
      return parentElement;
    }
    parentElement = parentElement.parentElement;
  }
  return getDocument(parentElement).body;
}
function createCollectionStore(props = {}) {
  var _a;
  const itemsMap = /* @__PURE__ */ new Map();
  const syncState = (_a = props.store) == null ? void 0 : _a.getState();
  const initialState = {
    items: defaultValue(props.items, syncState == null ? void 0 : syncState.items, props.defaultItems, []),
    renderedItems: defaultValue(syncState == null ? void 0 : syncState.renderedItems, [])
  };
  const privateStore = createStore({
    renderedItems: initialState.renderedItems
  });
  const collection = createStore(initialState, props.store);
  const sortItems = () => {
    const state = privateStore.getState();
    const renderedItems = sortBasedOnDOMPosition(state.renderedItems);
    privateStore.setState("renderedItems", renderedItems);
    collection.setState("renderedItems", renderedItems);
  };
  collection.setup(() => {
    return privateStore.syncBatch(
      (state) => {
        let firstRun = true;
        let raf = requestAnimationFrame(sortItems);
        if (typeof IntersectionObserver !== "function")
          return;
        const callback = () => {
          if (firstRun) {
            firstRun = false;
            return;
          }
          cancelAnimationFrame(raf);
          raf = requestAnimationFrame(sortItems);
        };
        const root = getCommonParent(state.renderedItems);
        const observer = new IntersectionObserver(callback, { root });
        state.renderedItems.forEach((item) => {
          if (item.element) {
            observer.observe(item.element);
          }
        });
        return () => {
          cancelAnimationFrame(raf);
          observer.disconnect();
        };
      },
      ["renderedItems"]
    );
  });
  const mergeItem = (item, setItems, canDeleteFromMap = false) => {
    let prevItem;
    setItems((items) => {
      const index = itemsMap.get(item.id) && items.findIndex(({ id }) => id === item.id);
      const nextItems = items.slice();
      if (index && index >= 0) {
        prevItem = items[index];
        const nextItem = __spreadValues(__spreadValues({}, prevItem), item);
        nextItems[index] = nextItem;
        itemsMap.set(item.id, nextItem);
      } else {
        nextItems.push(item);
        itemsMap.set(item.id, item);
      }
      return nextItems;
    });
    const unmergeItem = () => {
      setItems((items) => {
        if (!prevItem) {
          if (canDeleteFromMap) {
            itemsMap.delete(item.id);
          }
          return items.filter(({ id }) => id !== item.id);
        }
        const index = items.findIndex(({ id }) => id === item.id);
        if (index === -1)
          return items;
        const nextItems = items.slice();
        nextItems[index] = prevItem;
        itemsMap.set(item.id, prevItem);
        return nextItems;
      });
    };
    return unmergeItem;
  };
  const registerItem = (item) => mergeItem(item, (getItems) => collection.setState("items", getItems), true);
  return __spreadProps(__spreadValues({}, collection), {
    registerItem,
    renderItem: (item) => chain(
      registerItem(item),
      mergeItem(
        item,
        (getItems) => privateStore.setState("renderedItems", getItems)
      )
    ),
    item: (id) => {
      if (!id)
        return null;
      let item = itemsMap.get(id);
      if (!item) {
        const { items } = collection.getState();
        item = items.find((item2) => item2.id === id);
        if (item) {
          itemsMap.set(id, item);
        }
      }
      return item || null;
    }
  });
}

export {
  createCollectionStore
};
