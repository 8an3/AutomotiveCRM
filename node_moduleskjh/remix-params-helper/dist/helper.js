import { ZodArray, ZodBoolean, ZodDate, ZodDefault, ZodEffects, ZodEnum, ZodLiteral, ZodNativeEnum, ZodNumber, ZodObject, ZodOptional, ZodString, } from 'zod';
function isIterable(maybeIterable) {
    return Symbol.iterator in Object(maybeIterable);
}
function parseParams(o, schema, key, value) {
    var _a;
    // find actual shape definition for this key
    let shape = schema;
    while (shape instanceof ZodObject || shape instanceof ZodEffects) {
        shape =
            shape instanceof ZodObject
                ? shape.shape
                : shape instanceof ZodEffects
                    ? shape._def.schema
                    : null;
        if (shape === null) {
            throw new Error(`Could not find shape for key ${key}`);
        }
    }
    if (key.includes('.')) {
        let [parentProp, ...rest] = key.split('.');
        o[parentProp] = (_a = o[parentProp]) !== null && _a !== void 0 ? _a : {};
        parseParams(o[parentProp], shape[parentProp], rest.join('.'), value);
        return;
    }
    let isArray = false;
    if (key.includes('[]')) {
        isArray = true;
        key = key.replace('[]', '');
    }
    const def = shape[key];
    if (def) {
        processDef(def, o, key, value);
    }
}
function getParamsInternal(params, schema) {
    // @ts-ignore
    let o = {};
    let entries = [];
    if (isIterable(params)) {
        entries = Array.from(params);
    }
    else {
        entries = Object.entries(params);
    }
    for (let [key, value] of entries) {
        // infer an empty param as if it wasn't defined in the first place
        if (value === '') {
            continue;
        }
        parseParams(o, schema, key, value);
    }
    const result = schema.safeParse(o);
    if (result.success) {
        return { success: true, data: result.data, errors: undefined };
    }
    else {
        let errors = {};
        const addError = (key, message) => {
            if (!errors.hasOwnProperty(key)) {
                errors[key] = message;
            }
            else {
                if (!Array.isArray(errors[key])) {
                    errors[key] = [errors[key]];
                }
                errors[key].push(message);
            }
        };
        for (let issue of result.error.issues) {
            const { message, path, code, expected, received } = issue;
            const [key, index] = path;
            let value = o[key];
            let prop = key;
            if (index !== undefined) {
                value = value[index];
                prop = `${key}[${index}]`;
            }
            addError(key, message);
        }
        return { success: false, data: undefined, errors };
    }
}
export function getParams(params, schema) {
    return getParamsInternal(params, schema);
}
export function getSearchParams(request, schema) {
    let url = new URL(request.url);
    return getParamsInternal(url.searchParams, schema);
}
export async function getFormData(request, schema) {
    let data = await request.formData();
    return getParamsInternal(data, schema);
}
export function getParamsOrFail(params, schema) {
    const result = getParamsInternal(params, schema);
    if (!result.success) {
        throw new Error(JSON.stringify(result.errors));
    }
    return result.data;
}
export function getSearchParamsOrFail(request, schema) {
    let url = new URL(request.url);
    const result = getParamsInternal(url.searchParams, schema);
    if (!result.success) {
        throw new Error(JSON.stringify(result.errors));
    }
    return result.data;
}
export async function getFormDataOrFail(request, schema) {
    let data = await request.formData();
    const result = getParamsInternal(data, schema);
    if (!result.success) {
        throw new Error(JSON.stringify(result.errors));
    }
    return result.data;
}
export function useFormInputProps(schema, options = {}) {
    const shape = schema.shape;
    const defaultOptions = options;
    return function props(key, options = {}) {
        options = { ...defaultOptions, ...options };
        const def = shape[key];
        if (!def) {
            throw new Error(`no such key: ${key}`);
        }
        return getInputProps(key, def);
    };
}
function processDef(def, o, key, value) {
    let parsedValue;
    if (def instanceof ZodString || def instanceof ZodLiteral) {
        parsedValue = value;
    }
    else if (def instanceof ZodNumber) {
        const num = Number(value);
        parsedValue = isNaN(num) ? value : num;
    }
    else if (def instanceof ZodDate) {
        const date = Date.parse(value);
        parsedValue = isNaN(date) ? value : new Date(date);
    }
    else if (def instanceof ZodBoolean) {
        parsedValue =
            value === 'true' ? true : value === 'false' ? false : Boolean(value);
    }
    else if (def instanceof ZodNativeEnum || def instanceof ZodEnum) {
        parsedValue = value;
    }
    else if (def instanceof ZodOptional || def instanceof ZodDefault) {
        // def._def.innerType is the same as ZodOptional's .unwrap(), which unfortunately doesn't exist on ZodDefault
        processDef(def._def.innerType, o, key, value);
        // return here to prevent overwriting the result of the recursive call
        return;
    }
    else if (def instanceof ZodArray) {
        if (o[key] === undefined) {
            o[key] = [];
        }
        processDef(def.element, o, key, value);
        // return here since recursive call will add to array
        return;
    }
    else if (def instanceof ZodEffects) {
        processDef(def._def.schema, o, key, value);
        return;
    }
    else {
        throw new Error(`Unexpected type ${def._def.typeName} for key ${key}`);
    }
    if (Array.isArray(o[key])) {
        o[key].push(parsedValue);
    }
    else {
        o[key] = parsedValue;
    }
}
function getInputProps(name, def) {
    var _a, _b, _c, _d;
    let type = 'text';
    let min, max, minlength, maxlength, pattern;
    if (def instanceof ZodString) {
        if (def.isEmail) {
            type = 'email';
        }
        else if (def.isURL) {
            type = 'url';
        }
        minlength = (_a = def.minLength) !== null && _a !== void 0 ? _a : undefined;
        maxlength = (_b = def.maxLength) !== null && _b !== void 0 ? _b : undefined;
        const check = def._def.checks.find(c => c.kind === 'regex');
        pattern = check ? check.regex.source : undefined;
    }
    else if (def instanceof ZodNumber) {
        type = 'number';
        min = (_c = def.minValue) !== null && _c !== void 0 ? _c : undefined;
        max = (_d = def.maxValue) !== null && _d !== void 0 ? _d : undefined;
    }
    else if (def instanceof ZodBoolean) {
        type = 'checkbox';
    }
    else if (def instanceof ZodDate) {
        type = 'date';
    }
    else if (def instanceof ZodArray) {
        return getInputProps(name, def.element);
    }
    else if (def instanceof ZodOptional) {
        return getInputProps(name, def.unwrap());
    }
    let inputProps = {
        name,
        type,
    };
    if (!def.isOptional())
        inputProps.required = true;
    if (min)
        inputProps.min = min;
    if (max)
        inputProps.max = max;
    if (minlength && Number.isFinite(minlength))
        inputProps.minLength = minlength;
    if (maxlength && Number.isFinite(maxlength))
        inputProps.maxLength = maxlength;
    if (pattern)
        inputProps.pattern = pattern;
    return inputProps;
}
