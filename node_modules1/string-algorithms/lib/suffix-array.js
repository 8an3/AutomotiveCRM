'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.sampleToString = sampleToString;
exports.suffixArrayToString = suffixArrayToString;
exports.default = suffixArray;

var _radixSort = require('./radix-sort');

var _radixSort2 = _interopRequireDefault(_radixSort);

var _stringSequence = require('./string-sequence');

var _stringSequence2 = _interopRequireDefault(_stringSequence);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } } /*
                                                                                                                                                                                                     * Linear-time suffix array implementation using the DC3/skew (Difference Cover
                                                                                                                                                                                                     * modulo 3) algorithm.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * For more information about DC3, see the following resources:
                                                                                                                                                                                                     * http://algo2.iti.kit.edu/documents/jacm05-revised.pdf
                                                                                                                                                                                                     * http://web.stanford.edu/class/archive/cs/cs166/cs166.1146/lectures/11/Small11.pdf
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * This implementation is pure ES2015 JavaScript without any other dependencies,
                                                                                                                                                                                                     * meaning it can be run in pretty much any JavaScript interpreter (when transpiled
                                                                                                                                                                                                     * using e.g. babel).
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * While the algorithms provided here is a linear-time implementations,
                                                                                                                                                                                                     * it is still outperformed by readily available C/C++ implementations.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Also note that although these implementations are O(n), linear time does not
                                                                                                                                                                                                     * automatically beat O(n log(n)) all the time. More efficient implementations
                                                                                                                                                                                                     * that are O(n * log(n)) may in fact be faster in practice in many situations.
                                                                                                                                                                                                     * To see that, consider that log<sub>2</sub>(n) grows very slowly. For example
                                                                                                                                                                                                     * log<sub>2</sub>(100,000) is approximately 16.6. The linear-time longest common
                                                                                                                                                                                                     * substring implementation makes many linear passes through the input string,
                                                                                                                                                                                                     * quite possibly more than 16 in total. So if there exists an O(n log(n))
                                                                                                                                                                                                     * implementation that can do everything it needs to do in just one pass through
                                                                                                                                                                                                     * the input, it would already come out ahead of the linear time implementation
                                                                                                                                                                                                     * for n less than or equal to 100,000.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Due to limitations of Node.js, the maximum string size is currently limited too
                                                                                                                                                                                                     * by the maximum heap size which is currently just shy of 2GB--and the actual
                                                                                                                                                                                                     * longest string that can be handled by the multiple longest common substring
                                                                                                                                                                                                     * algorithm will be sevaral factors shorter than the maximum heap size.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * On the other hand, this implememtation supports UTF-16 while the reference DC3
                                                                                                                                                                                                     * implementation expects a byte sized alphabet.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Copyright (C) 2017 Kim Burgaard <kim@burgaard.us>
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * Permission is hereby granted, free of charge, to any person obtaining a copy
                                                                                                                                                                                                     * of this software and associated documentation files (the "Software"), to deal
                                                                                                                                                                                                     * in the Software without restriction, including without limitation the rights
                                                                                                                                                                                                     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
                                                                                                                                                                                                     * copies of the Software, and to permit persons to whom the Software is
                                                                                                                                                                                                     * furnished to do so, subject to the following conditions:
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * The above copyright notice and this permission notice shall be included in
                                                                                                                                                                                                     * all copies or substantial portions of the Software.
                                                                                                                                                                                                     *
                                                                                                                                                                                                     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
                                                                                                                                                                                                     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
                                                                                                                                                                                                     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
                                                                                                                                                                                                     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
                                                                                                                                                                                                     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
                                                                                                                                                                                                     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
                                                                                                                                                                                                     * SOFTWARE.
                                                                                                                                                                                                     */

function createSample(block, offset, sequence) {
  var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 3;

  var suffix = block * 3 + offset;
  return [suffix].concat(_toConsumableArray(sequence.slice(suffix, suffix + length))); // prefix triplet with suffix
}

function sampleSequence(sequence, terminator) {
  var n = sequence.length;
  var remainder = n % 3;
  var blocks = (n - remainder) / 3;

  var b1 = [];
  var b2 = [];

  var i = 0;
  while (i < blocks - 1) {
    b1.push(createSample(i, 1, sequence));
    b2.push(createSample(i, 2, sequence));
    i++;
  }

  var lastB1 = createSample(i, 1, sequence, 2);
  var lastB2 = createSample(i, 2, sequence, 1);

  i++;

  /* eslint-disable default-case */
  switch (remainder) {
    case 2:
      lastB1.push(sequence[i * 3]);
      b1.push(lastB1);
      lastB1 = [i * 3 + 1];
      lastB2.push(sequence[i * 3]);
      break;
    case 1:
      lastB1.push(sequence[i * 3]);
      lastB2.push(sequence[i * 3]);
      break;
    case 0:
      break;
    // default:
    //   throw Error(`Impossible remainder: ${remainder}`);
  }
  /* eslint-enable default-case */

  while (lastB1.length % 4 !== 0) {
    lastB1.push(terminator);
  }

  while (lastB2.length % 4 !== 0) {
    lastB2.push(terminator);
  }

  b1.push(lastB1);
  b2.push(lastB2);

  return b1.concat(b2);
}

function sampleToString(sample) {
  return String.fromCharCode.apply(this, sample);
}

// Converts an array of samples to a sequence with each sample's rank.
function samplesToSequence(unsorted, sorted) {
  // rank sorted samples
  var sampleToRank = {};
  var rank = 0x21; // !
  var unique = true;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = sorted[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var sample = _step.value;

      var sampleString = sampleToString(sample.slice(1));
      if (sampleString in sampleToRank) {
        unique = false;
      } else {
        sampleToRank[sampleString] = rank++;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (unique) {
    return { unique: true };
  }

  // construct new sequence based on the unsorted samples and their ranks
  var samplesSequence = unsorted.map(function (sample) {
    return sampleToRank[sampleToString(sample.slice(1))];
  });

  return { unique: false, samplesSequence: samplesSequence };
}

function rankSortedSamples(n, sortedSamples) {
  var r = n % 3;
  var m = n + (r !== 0 ? 3 - r : 0);
  var result = new Array(m);

  var rank = 1;
  sortedSamples.forEach(function (sample) {
    return result[sample[0]] = rank++;
  });

  switch (r) {
    default:
      break;
    case 2:
      result[n + 2] = 0;
    // fall through
    case 1:
      result[n + 1] = 0;
      break;
  }
  return result;
}

function createNonSampledPairs(sequence, ranks) {
  var n = sequence.length;

  var nonSampledPairs = [];

  var i = 0;
  while (i < n) {
    nonSampledPairs.push([i, sequence[i], ranks[i + 1]]);
    i += 3;
  }

  return nonSampledPairs;
}

function merge(sequence, sortedNonSampledPairs, sortedSamples, ranks) {
  var result = [];

  var a = 0;
  var b = 0;
  while (a < sortedNonSampledPairs.length && b < sortedSamples.length) {
    var i = sortedSamples[b][0];
    var j = sortedNonSampledPairs[a][0];
    // if (j % 3 !== 0) {
    //   throw new Error('Sorted non-samples should only contain offset 0 (mod 3) entries');
    // }

    var d = sequence[i] - sequence[j];
    /* eslint-disable default-case */
    switch (i % 3) {
      case 1:
        if (d === 0) {
          d = ranks[i + 1] - ranks[j + 1];
        }
        break;
      case 2:
        if (d === 0) {
          d = sequence[i + 1] - sequence[j + 1];
          if (d === 0) {
            d = ranks[i + 2] - ranks[j + 2];
          }
        }
        break;
      // default:
      //   throw new Error('Sorted samples should only contain offset != 0 (mod 3) entries');
    }
    /* eslint-enable default-case */

    if (d <= 0) {
      result.push(i);
      b++;
    } else {
      result.push(j);
      a++;
    }
  }

  while (b < sortedSamples.length) {
    result.push(sortedSamples[b++][0]);
  }

  while (a < sortedNonSampledPairs.length) {
    result.push(sortedNonSampledPairs[a++][0]);
  }

  return result;
}

function createSuffixArray(sequence, terminator) {
  var n = sequence.length;

  // handle trivial cases
  switch (n) {
    case 0:
      return [0];
    case 1:
      return [1, 0];
    case 2:
      return sequence[0] < sequence[1] ? [2, 0, 1] : [2, 1, 0];
    default:
      sequence = [].concat(_toConsumableArray(sequence), [terminator]); // add terminator to copy of sequence
      break;
  }

  // calculate the set C = B1 u B2
  var sampledPositions = sampleSequence(sequence, terminator);

  var sortedSamples = (0, _radixSort2.default)(sampledPositions, function (entry) {
    return entry.slice(1);
  });

  var _samplesToSequence = samplesToSequence(sampledPositions, sortedSamples),
      unique = _samplesToSequence.unique,
      samplesSequence = _samplesToSequence.samplesSequence;

  if (!unique) {
    var recursiveSuffixArray = createSuffixArray(samplesSequence, -1);

    sortedSamples = recursiveSuffixArray.map(function (suffix) {
      return sampledPositions[suffix];
    });
    sortedSamples = sortedSamples.slice(1);
  }

  var ranks = rankSortedSamples(n, sortedSamples);

  var sortedNonSampledPairs = (0, _radixSort2.default)(createNonSampledPairs(sequence, ranks), function (entry) {
    return entry.slice(1);
  });

  return merge(sequence, sortedNonSampledPairs, sortedSamples, ranks);
}

function suffixArrayToString(s, sa) {
  var sequence = Array.isArray(s) ? s : (0, _stringSequence2.default)(s);
  return ['['].concat(sa.map(function (i) {
    return '  ' + i + ', // ' + sequence.slice(i).map(function (c) {
      return String.fromCharCode(c);
    }).join('');
  })).concat(']').join('\n');
}

/**
 * Calculates the suffix array for the given string and an optional terminator code
 * which must be negative.
 *
 * @param {number[]|string} s the string or sequence to compute the suffix array for.
 * @param {number} [terminator=-1] an optional negative terminator code.
 * @return {number[]} a suffix array.
 */
function suffixArray(s) {
  var terminator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

  var sequence = Array.isArray(s) ? s : (0, _stringSequence2.default)(s);
  var t = terminator != null ? terminator : -1;
  if (typeof t !== 'number') {
    throw TypeError('the terminator argument is not a number: ' + (typeof terminator === 'undefined' ? 'undefined' : _typeof(terminator)));
  }
  if (t > -1) {
    throw Error('the terminator is not a negative integer: ' + terminator);
  }

  var result = createSuffixArray(sequence, t);

  return result;
}