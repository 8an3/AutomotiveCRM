{"version":3,"sources":["../../src/hooks/use-chat.ts"],"sourcesContent":["import { useRef } from \"react\";\nimport {\n  FunctionCallHandler,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  Action,\n  actionParametersToJsonSchema,\n} from \"@copilotkit/shared\";\nimport {\n  Message,\n  TextMessage,\n  ActionExecutionMessage,\n  ResultMessage,\n  CopilotRuntimeClient,\n  convertMessagesToGqlInput,\n  convertGqlOutputToMessages,\n  MessageStatusCode,\n  MessageRole,\n  Role,\n  CopilotRequestType,\n} from \"@copilotkit/runtime-client-gql\";\n\nimport { CopilotApiConfig } from \"../context\";\n\nexport type UseChatOptions = {\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n  /**\n   * Callback function to be called when a function call is received.\n   * If the function returns a `ChatRequest` object, the request will be sent\n   * automatically to the API and will be used to update the chat.\n   */\n  onFunctionCall?: FunctionCallHandler;\n  /**\n   * Function definitions to be sent to the API.\n   */\n  actions: Action[];\n\n  /**\n   * The CopilotKit API configuration.\n   */\n  copilotConfig: CopilotApiConfig;\n\n  /**\n   * The current list of messages in the chat.\n   */\n  messages: Message[];\n  /**\n   * The setState-powered method to update the chat messages.\n   */\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  /**\n   * A callback to get the latest system message.\n   */\n  makeSystemMessageCallback: () => TextMessage;\n\n  /**\n   * Whether the API request is in progress\n   */\n  isLoading: boolean;\n\n  /**\n   * setState-powered method to update the isChatLoading value\n   */\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n};\n\nexport type UseChatHelpers = {\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   */\n  append: (message: Message) => Promise<void>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: () => Promise<void>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n};\n\nexport function useChat(options: UseChatOptions): UseChatHelpers {\n  const {\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    copilotConfig,\n    setIsLoading,\n    initialMessages,\n    isLoading,\n    actions,\n    onFunctionCall,\n  } = options;\n  const abortControllerRef = useRef<AbortController>();\n  const threadIdRef = useRef<string | null>(null);\n  const runIdRef = useRef<string | null>(null);\n  const publicApiKey = copilotConfig.publicApiKey;\n  const headers = {\n    ...(copilotConfig.headers || {}),\n    ...(publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {}),\n  };\n\n  const runtimeClient = new CopilotRuntimeClient({\n    url: copilotConfig.chatApiEndpoint,\n    publicApiKey: copilotConfig.publicApiKey,\n    headers,\n    credentials: copilotConfig.credentials,\n  });\n\n  const runChatCompletion = async (previousMessages: Message[]): Promise<Message[]> => {\n    setIsLoading(true);\n\n    // this message is just a placeholder. It will disappear once the first real message\n    // is received\n    let newMessages: Message[] = [\n      new TextMessage({\n        content: \"\",\n        role: Role.Assistant,\n      }),\n    ];\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    setMessages([...previousMessages, ...newMessages]);\n\n    const systemMessage = makeSystemMessageCallback();\n\n    const messagesWithContext = [systemMessage, ...(initialMessages || []), ...previousMessages];\n\n    const stream = CopilotRuntimeClient.asStream(\n      runtimeClient.generateCopilotResponse({\n        data: {\n          frontend: {\n            actions: actions.map((action) => ({\n              name: action.name,\n              description: action.description || \"\",\n              jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),\n            })),\n          },\n          threadId: threadIdRef.current,\n          runId: runIdRef.current,\n          messages: convertMessagesToGqlInput(messagesWithContext),\n          ...(copilotConfig.cloud\n            ? {\n                cloud: {\n                  ...(copilotConfig.cloud.guardrails?.input?.restrictToTopic?.enabled\n                    ? {\n                        guardrails: {\n                          inputValidationRules: {\n                            allowList:\n                              copilotConfig.cloud.guardrails.input.restrictToTopic.validTopics,\n                            denyList:\n                              copilotConfig.cloud.guardrails.input.restrictToTopic.invalidTopics,\n                          },\n                        },\n                      }\n                    : {}),\n                },\n              }\n            : {}),\n          metadata: {\n            requestType: CopilotRequestType.Chat,\n          },\n        },\n        properties: copilotConfig.properties,\n        signal: abortControllerRef.current?.signal,\n      }),\n    );\n\n    const guardrailsEnabled =\n      copilotConfig.cloud?.guardrails?.input?.restrictToTopic.enabled || false;\n\n    const reader = stream.getReader();\n\n    let results: { [id: string]: string } = {};\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        if (!value?.generateCopilotResponse) {\n          continue;\n        }\n\n        threadIdRef.current = value.generateCopilotResponse.threadId || null;\n        runIdRef.current = value.generateCopilotResponse.runId || null;\n\n        const messages = convertGqlOutputToMessages(value.generateCopilotResponse.messages);\n\n        if (messages.length === 0) {\n          continue;\n        }\n\n        newMessages = [];\n\n        // request failed, display error message\n        if (\n          value.generateCopilotResponse.status?.__typename === \"FailedResponseStatus\" &&\n          value.generateCopilotResponse.status.reason === \"GUARDRAILS_VALIDATION_FAILED\"\n        ) {\n          newMessages = [\n            new TextMessage({\n              role: MessageRole.Assistant,\n              content: value.generateCopilotResponse.status.details?.guardrailsReason || \"\",\n            }),\n          ];\n        }\n\n        // add messages to the chat\n        else {\n          for (const message of messages) {\n            newMessages.push(message);\n\n            if (\n              message instanceof ActionExecutionMessage &&\n              message.status.code !== MessageStatusCode.Pending &&\n              message.scope === \"client\" &&\n              onFunctionCall\n            ) {\n              if (!(message.id in results)) {\n                // Do not execute a function call if guardrails are enabled but the status is not known\n                if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {\n                  break;\n                }\n                // execute action\n                const result = await onFunctionCall({\n                  messages: previousMessages,\n                  name: message.name,\n                  args: message.arguments,\n                });\n                results[message.id] = result;\n              }\n\n              // add the result message\n              newMessages.push(\n                new ResultMessage({\n                  result: ResultMessage.encodeResult(results[message.id]),\n                  actionExecutionId: message.id,\n                  actionName: message.name,\n                }),\n              );\n            }\n          }\n        }\n\n        if (newMessages.length > 0) {\n          setMessages([...previousMessages, ...newMessages]);\n        }\n      }\n\n      if (\n        // if we have client side results\n        Object.values(results).length ||\n        // or the last message we received is a result\n        (newMessages.length && newMessages[newMessages.length - 1] instanceof ResultMessage)\n      ) {\n        // run the completion again and return the result\n\n        // wait for next tick to make sure all the react state updates\n        // - tried using react-dom's flushSync, but it did not work\n        await new Promise((resolve) => setTimeout(resolve, 10));\n\n        return await runChatCompletion([...previousMessages, ...newMessages]);\n      } else {\n        return newMessages.slice();\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const runChatCompletionAndHandleFunctionCall = async (messages: Message[]): Promise<void> => {\n    await runChatCompletion(messages);\n  };\n\n  const append = async (message: Message): Promise<void> => {\n    if (isLoading) {\n      return;\n    }\n    const newMessages = [...messages, message];\n    setMessages(newMessages);\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const reload = async (): Promise<void> => {\n    if (isLoading || messages.length === 0) {\n      return;\n    }\n    let newMessages = [...messages];\n    const lastMessage = messages[messages.length - 1];\n\n    if (lastMessage instanceof TextMessage && lastMessage.role === \"assistant\") {\n      newMessages = newMessages.slice(0, -1);\n    }\n\n    setMessages(newMessages);\n\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const stop = (): void => {\n    abortControllerRef.current?.abort();\n  };\n\n  return {\n    append,\n    reload,\n    stop,\n  };\n}\n"],"mappings":"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","names":["messages"]}