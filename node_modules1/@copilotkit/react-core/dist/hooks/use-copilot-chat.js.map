{"version":3,"sources":["../../src/hooks/use-copilot-chat.ts","../../src/context/copilot-context.tsx","../../src/hooks/use-chat.ts","../../src/components/copilot-provider/copilotkit.tsx"],"sourcesContent":["/**\n * `useCopilotChat` is a React hook that lets you directly interact with the\n * Copilot instance. Use to implement a fully custom UI (headless UI) or to\n * programmatically interact with the Copilot instance managed by the default\n * UI.\n *\n * ## Usage\n *\n * ### Simple Usage\n *\n * ```tsx\n * import { useCopilotChat } from \"@copilotkit/react-core\";\n * import { Role, TextMessage } from \"@copilotkit/runtime-client-gql\";\n *\n * export function YourComponent() {\n *   const { appendMessage } = useCopilotChat();\n *\n *   appendMessage(\n *     new TextMessage({\n *       content: \"Hello World\",\n *       role: Role.User,\n *     }),\n *   );\n * }\n * ```\n *\n * `useCopilotChat` returns an object with the following properties:\n *\n * ```tsx\n * const {\n *   visibleMessages, // An array of messages that are currently visible in the chat.\n *   appendMessage, // A function to append a message to the chat.\n *   setMessages, // A function to set the messages in the chat.\n *   deleteMessage, // A function to delete a message from the chat.\n *   reloadMessages, // A function to reload the messages from the API.\n *   stopGeneration, // A function to stop the generation of the next message.\n *   isLoading, // A boolean indicating if the chat is loading.\n * } = useCopilotChat();\n * ```\n */\nimport { useContext, useRef, useEffect, useCallback } from \"react\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { Message, Role, TextMessage } from \"@copilotkit/runtime-client-gql\";\nimport { SystemMessageFunction } from \"../types\";\nimport { useChat } from \"./use-chat\";\nimport { defaultCopilotContextCategories } from \"../components\";\nimport { MessageStatusCode } from \"@copilotkit/runtime-client-gql\";\n\nexport interface UseCopilotChatOptions {\n  /**\n   * A unique identifier for the chat. If not provided, a random one will be\n   * generated. When provided, the `useChat` hook with the same `id` will\n   * have shared states across components.\n   */\n  id?: string;\n\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Record<string, string> | Headers;\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n\n  /**\n   * A function to generate the system message. Defaults to `defaultSystemMessage`.\n   */\n  makeSystemMessage?: SystemMessageFunction;\n}\n\nexport interface UseCopilotChatReturn {\n  visibleMessages: Message[];\n  appendMessage: (message: Message) => Promise<void>;\n  setMessages: (messages: Message[]) => void;\n  deleteMessage: (messageId: string) => void;\n  reloadMessages: () => Promise<void>;\n  stopGeneration: () => void;\n  isLoading: boolean;\n}\n\nexport function useCopilotChat({\n  makeSystemMessage,\n  ...options\n}: UseCopilotChatOptions = {}): UseCopilotChatReturn {\n  const {\n    getContextString,\n    getFunctionCallHandler,\n    copilotApiConfig,\n    messages,\n    setMessages,\n    isLoading,\n    setIsLoading,\n    chatInstructions,\n    actions,\n  } = useContext(CopilotContext);\n\n  // We need to ensure that makeSystemMessageCallback always uses the latest\n  // useCopilotReadable data.\n  const latestGetContextString = useUpdatedRef(getContextString);\n  const deleteMessage = useCallback(\n    (messageId: string) => {\n      setMessages((prev) => prev.filter((message) => message.id !== messageId));\n    },\n    [setMessages],\n  );\n\n  const makeSystemMessageCallback = useCallback(() => {\n    const systemMessageMaker = makeSystemMessage || defaultSystemMessage;\n    // this always gets the latest context string\n    const contextString = latestGetContextString.current([], defaultCopilotContextCategories); // TODO: make the context categories configurable\n\n    return new TextMessage({\n      content: systemMessageMaker(contextString, chatInstructions),\n      role: Role.System,\n    });\n  }, [getContextString, makeSystemMessage, chatInstructions]);\n\n  const { append, reload, stop } = useChat({\n    ...options,\n    actions: Object.values(actions),\n    copilotConfig: copilotApiConfig,\n    initialMessages: options.initialMessages || [],\n    onFunctionCall: getFunctionCallHandler(),\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    isLoading,\n    setIsLoading,\n  });\n\n  return {\n    visibleMessages: messages,\n    appendMessage: append,\n    setMessages,\n    reloadMessages: reload,\n    stopGeneration: stop,\n    deleteMessage,\n    isLoading,\n  };\n}\n\n// store `value` in a ref and update\n// it whenever it changes.\nfunction useUpdatedRef<T>(value: T) {\n  const ref = useRef(value);\n\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n\n  return ref;\n}\n\nexport function defaultSystemMessage(\n  contextString: string,\n  additionalInstructions?: string,\n): string {\n  return (\n    `\nPlease act as an efficient, competent, conscientious, and industrious professional assistant.\n\nHelp the user achieve their goals, and you do so in a way that is as efficient as possible, without unnecessary fluff, but also without sacrificing professionalism.\nAlways be polite and respectful, and prefer brevity over verbosity.\n\nThe user has provided you with the following context:\n\\`\\`\\`\n${contextString}\n\\`\\`\\`\n\nThey have also provided you with functions you can call to initiate actions on their behalf, or functions you can call to receive more information.\n\nPlease assist them as best you can.\n\nYou can ask them for clarifying questions if needed, but don't be annoying about it. If you can reasonably 'fill in the blanks' yourself, do so.\n\nIf you would like to call a function, call it without saying anything else.\n` + (additionalInstructions ? `\\n\\n${additionalInstructions}` : \"\")\n  );\n}\n","import { CopilotCloudConfig, FunctionCallHandler } from \"@copilotkit/shared\";\nimport { Message } from \"@copilotkit/runtime-client-gql\";\nimport { ActionRenderProps, FrontendAction } from \"../types/frontend-action\";\nimport React from \"react\";\nimport { TreeNodeId } from \"../hooks/use-tree\";\nimport { DocumentPointer } from \"../types\";\nimport { CopilotChatSuggestionConfiguration } from \"../types/chat-suggestion-configuration\";\n\n/**\n * Interface for the configuration of the Copilot API.\n */\nexport interface CopilotApiConfig {\n  /**\n   * The public API key for Copilot Cloud.\n   */\n  publicApiKey?: string;\n\n  /**\n   * The configuration for Copilot Cloud.\n   */\n  cloud?: CopilotCloudConfig;\n\n  /**\n   * The endpoint for the chat API.\n   */\n  chatApiEndpoint: string;\n\n  /**\n   * The endpoint for the Copilot transcribe audio service.\n   */\n  transcribeAudioUrl?: string;\n\n  /**\n   * The endpoint for the Copilot text to speech service.\n   */\n  textToSpeechUrl?: string;\n\n  /**\n   * additional headers to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'Authorization': 'Bearer your_token_here'\n   * }\n   * ```\n   */\n  headers: Record<string, string>;\n\n  /**\n   * Custom properties to be sent with the request\n   * @default {}\n   * @example\n   * ```\n   * {\n   *   'user_id': 'user_id'\n   * }\n   * ```\n   */\n  properties?: Record<string, any>;\n\n  /**\n   * Indicates whether the user agent should send or receive cookies from the other domain\n   * in the case of cross-origin requests.\n   */\n  credentials?: RequestCredentials;\n}\n\nexport type InChatRenderFunction = (props: ActionRenderProps<any>) => string | JSX.Element;\n\nexport interface CopilotContextParams {\n  // function-calling\n  actions: Record<string, FrontendAction<any>>;\n  setAction: (id: string, action: FrontendAction<any>) => void;\n  removeAction: (id: string) => void;\n  chatComponentsCache: React.RefObject<Record<string, InChatRenderFunction | string>>;\n\n  getFunctionCallHandler: (\n    customEntryPoints?: Record<string, FrontendAction<any>>,\n  ) => FunctionCallHandler;\n\n  // text context\n  addContext: (context: string, parentId?: string, categories?: string[]) => TreeNodeId;\n  removeContext: (id: TreeNodeId) => void;\n  getContextString: (documents: DocumentPointer[], categories: string[]) => string;\n\n  // document context\n  addDocumentContext: (documentPointer: DocumentPointer, categories?: string[]) => TreeNodeId;\n  removeDocumentContext: (documentId: string) => void;\n  getDocumentsContext: (categories: string[]) => DocumentPointer[];\n\n  // chat\n  messages: Message[];\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  isLoading: boolean;\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n\n  chatSuggestionConfiguration: { [key: string]: CopilotChatSuggestionConfiguration };\n  addChatSuggestionConfiguration: (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => void;\n  removeChatSuggestionConfiguration: (id: string) => void;\n\n  chatInstructions: string;\n  setChatInstructions: React.Dispatch<React.SetStateAction<string>>;\n\n  // api endpoints\n  copilotApiConfig: CopilotApiConfig;\n\n  showDevConsole: boolean | \"auto\";\n}\n\nconst emptyCopilotContext: CopilotContextParams = {\n  actions: {},\n  setAction: () => {},\n  removeAction: () => {},\n\n  chatComponentsCache: { current: {} },\n  getContextString: (documents: DocumentPointer[], categories: string[]) =>\n    returnAndThrowInDebug(\"\"),\n  addContext: () => \"\",\n  removeContext: () => {},\n\n  getFunctionCallHandler: () => returnAndThrowInDebug(async () => {}),\n\n  messages: [],\n  setMessages: () => returnAndThrowInDebug([]),\n\n  isLoading: false,\n  setIsLoading: () => returnAndThrowInDebug(false),\n\n  chatInstructions: \"\",\n  setChatInstructions: () => returnAndThrowInDebug(\"\"),\n\n  getDocumentsContext: (categories: string[]) => returnAndThrowInDebug([]),\n  addDocumentContext: () => returnAndThrowInDebug(\"\"),\n  removeDocumentContext: () => {},\n\n  copilotApiConfig: new (class implements CopilotApiConfig {\n    get chatApiEndpoint(): string {\n      throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n    }\n\n    get headers(): Record<string, string> {\n      return {};\n    }\n    get body(): Record<string, any> {\n      return {};\n    }\n  })(),\n\n  chatSuggestionConfiguration: {},\n  addChatSuggestionConfiguration: () => {},\n  removeChatSuggestionConfiguration: () => {},\n  showDevConsole: \"auto\",\n};\n\nexport const CopilotContext = React.createContext<CopilotContextParams>(emptyCopilotContext);\n\nexport function useCopilotContext(): CopilotContextParams {\n  return React.useContext(CopilotContext);\n}\n\nfunction returnAndThrowInDebug<T>(value: T): T {\n  throw new Error(\"Remember to wrap your app in a `<CopilotKit> {...} </CopilotKit>` !!!\");\n  return value;\n}\n","import { useRef } from \"react\";\nimport {\n  FunctionCallHandler,\n  COPILOT_CLOUD_PUBLIC_API_KEY_HEADER,\n  Action,\n  actionParametersToJsonSchema,\n} from \"@copilotkit/shared\";\nimport {\n  Message,\n  TextMessage,\n  ActionExecutionMessage,\n  ResultMessage,\n  CopilotRuntimeClient,\n  convertMessagesToGqlInput,\n  convertGqlOutputToMessages,\n  MessageStatusCode,\n  MessageRole,\n  Role,\n  CopilotRequestType,\n} from \"@copilotkit/runtime-client-gql\";\n\nimport { CopilotApiConfig } from \"../context\";\n\nexport type UseChatOptions = {\n  /**\n   * System messages of the chat. Defaults to an empty array.\n   */\n  initialMessages?: Message[];\n  /**\n   * Callback function to be called when a function call is received.\n   * If the function returns a `ChatRequest` object, the request will be sent\n   * automatically to the API and will be used to update the chat.\n   */\n  onFunctionCall?: FunctionCallHandler;\n  /**\n   * Function definitions to be sent to the API.\n   */\n  actions: Action[];\n\n  /**\n   * The CopilotKit API configuration.\n   */\n  copilotConfig: CopilotApiConfig;\n\n  /**\n   * The current list of messages in the chat.\n   */\n  messages: Message[];\n  /**\n   * The setState-powered method to update the chat messages.\n   */\n  setMessages: React.Dispatch<React.SetStateAction<Message[]>>;\n\n  /**\n   * A callback to get the latest system message.\n   */\n  makeSystemMessageCallback: () => TextMessage;\n\n  /**\n   * Whether the API request is in progress\n   */\n  isLoading: boolean;\n\n  /**\n   * setState-powered method to update the isChatLoading value\n   */\n  setIsLoading: React.Dispatch<React.SetStateAction<boolean>>;\n};\n\nexport type UseChatHelpers = {\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   * @param message The message to append\n   */\n  append: (message: Message) => Promise<void>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: () => Promise<void>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n};\n\nexport function useChat(options: UseChatOptions): UseChatHelpers {\n  const {\n    messages,\n    setMessages,\n    makeSystemMessageCallback,\n    copilotConfig,\n    setIsLoading,\n    initialMessages,\n    isLoading,\n    actions,\n    onFunctionCall,\n  } = options;\n  const abortControllerRef = useRef<AbortController>();\n  const threadIdRef = useRef<string | null>(null);\n  const runIdRef = useRef<string | null>(null);\n  const publicApiKey = copilotConfig.publicApiKey;\n  const headers = {\n    ...(copilotConfig.headers || {}),\n    ...(publicApiKey ? { [COPILOT_CLOUD_PUBLIC_API_KEY_HEADER]: publicApiKey } : {}),\n  };\n\n  const runtimeClient = new CopilotRuntimeClient({\n    url: copilotConfig.chatApiEndpoint,\n    publicApiKey: copilotConfig.publicApiKey,\n    headers,\n    credentials: copilotConfig.credentials,\n  });\n\n  const runChatCompletion = async (previousMessages: Message[]): Promise<Message[]> => {\n    setIsLoading(true);\n\n    // this message is just a placeholder. It will disappear once the first real message\n    // is received\n    let newMessages: Message[] = [\n      new TextMessage({\n        content: \"\",\n        role: Role.Assistant,\n      }),\n    ];\n    const abortController = new AbortController();\n    abortControllerRef.current = abortController;\n\n    setMessages([...previousMessages, ...newMessages]);\n\n    const systemMessage = makeSystemMessageCallback();\n\n    const messagesWithContext = [systemMessage, ...(initialMessages || []), ...previousMessages];\n\n    const stream = CopilotRuntimeClient.asStream(\n      runtimeClient.generateCopilotResponse({\n        data: {\n          frontend: {\n            actions: actions.map((action) => ({\n              name: action.name,\n              description: action.description || \"\",\n              jsonSchema: JSON.stringify(actionParametersToJsonSchema(action.parameters || [])),\n            })),\n          },\n          threadId: threadIdRef.current,\n          runId: runIdRef.current,\n          messages: convertMessagesToGqlInput(messagesWithContext),\n          ...(copilotConfig.cloud\n            ? {\n                cloud: {\n                  ...(copilotConfig.cloud.guardrails?.input?.restrictToTopic?.enabled\n                    ? {\n                        guardrails: {\n                          inputValidationRules: {\n                            allowList:\n                              copilotConfig.cloud.guardrails.input.restrictToTopic.validTopics,\n                            denyList:\n                              copilotConfig.cloud.guardrails.input.restrictToTopic.invalidTopics,\n                          },\n                        },\n                      }\n                    : {}),\n                },\n              }\n            : {}),\n          metadata: {\n            requestType: CopilotRequestType.Chat,\n          },\n        },\n        properties: copilotConfig.properties,\n        signal: abortControllerRef.current?.signal,\n      }),\n    );\n\n    const guardrailsEnabled =\n      copilotConfig.cloud?.guardrails?.input?.restrictToTopic.enabled || false;\n\n    const reader = stream.getReader();\n\n    let results: { [id: string]: string } = {};\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        if (!value?.generateCopilotResponse) {\n          continue;\n        }\n\n        threadIdRef.current = value.generateCopilotResponse.threadId || null;\n        runIdRef.current = value.generateCopilotResponse.runId || null;\n\n        const messages = convertGqlOutputToMessages(value.generateCopilotResponse.messages);\n\n        if (messages.length === 0) {\n          continue;\n        }\n\n        newMessages = [];\n\n        // request failed, display error message\n        if (\n          value.generateCopilotResponse.status?.__typename === \"FailedResponseStatus\" &&\n          value.generateCopilotResponse.status.reason === \"GUARDRAILS_VALIDATION_FAILED\"\n        ) {\n          newMessages = [\n            new TextMessage({\n              role: MessageRole.Assistant,\n              content: value.generateCopilotResponse.status.details?.guardrailsReason || \"\",\n            }),\n          ];\n        }\n\n        // add messages to the chat\n        else {\n          for (const message of messages) {\n            newMessages.push(message);\n\n            if (\n              message instanceof ActionExecutionMessage &&\n              message.status.code !== MessageStatusCode.Pending &&\n              message.scope === \"client\" &&\n              onFunctionCall\n            ) {\n              if (!(message.id in results)) {\n                // Do not execute a function call if guardrails are enabled but the status is not known\n                if (guardrailsEnabled && value.generateCopilotResponse.status === undefined) {\n                  break;\n                }\n                // execute action\n                const result = await onFunctionCall({\n                  messages: previousMessages,\n                  name: message.name,\n                  args: message.arguments,\n                });\n                results[message.id] = result;\n              }\n\n              // add the result message\n              newMessages.push(\n                new ResultMessage({\n                  result: ResultMessage.encodeResult(results[message.id]),\n                  actionExecutionId: message.id,\n                  actionName: message.name,\n                }),\n              );\n            }\n          }\n        }\n\n        if (newMessages.length > 0) {\n          setMessages([...previousMessages, ...newMessages]);\n        }\n      }\n\n      if (\n        // if we have client side results\n        Object.values(results).length ||\n        // or the last message we received is a result\n        (newMessages.length && newMessages[newMessages.length - 1] instanceof ResultMessage)\n      ) {\n        // run the completion again and return the result\n\n        // wait for next tick to make sure all the react state updates\n        // - tried using react-dom's flushSync, but it did not work\n        await new Promise((resolve) => setTimeout(resolve, 10));\n\n        return await runChatCompletion([...previousMessages, ...newMessages]);\n      } else {\n        return newMessages.slice();\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const runChatCompletionAndHandleFunctionCall = async (messages: Message[]): Promise<void> => {\n    await runChatCompletion(messages);\n  };\n\n  const append = async (message: Message): Promise<void> => {\n    if (isLoading) {\n      return;\n    }\n    const newMessages = [...messages, message];\n    setMessages(newMessages);\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const reload = async (): Promise<void> => {\n    if (isLoading || messages.length === 0) {\n      return;\n    }\n    let newMessages = [...messages];\n    const lastMessage = messages[messages.length - 1];\n\n    if (lastMessage instanceof TextMessage && lastMessage.role === \"assistant\") {\n      newMessages = newMessages.slice(0, -1);\n    }\n\n    setMessages(newMessages);\n\n    return runChatCompletionAndHandleFunctionCall(newMessages);\n  };\n\n  const stop = (): void => {\n    abortControllerRef.current?.abort();\n  };\n\n  return {\n    append,\n    reload,\n    stop,\n  };\n}\n","/**\n * This component will typically wrap your entire application (or a sub-tree of your application where you want to have a copilot). It provides the copilot context to all other components and hooks.\n *\n * ## Example\n *\n * <Tabs items={[\"Copilot Cloud (Recommended)\", \"Self-hosted Runtime\"]}>\n *   <Tabs.Tab>\n *\n *     You can get your Copilot Cloud API key for free by <LinkToCopilotCloud>signing up here</LinkToCopilotCloud>.\n *\n *     ```tsx\n *     import { CopilotKit } from \"@copilotkit/react-core\";\n *\n *     <CopilotKit publicApiKey=\"<your-public-api-key>\">\n *       // ... your app ...\n *     </CopilotKit>\n *     ```\n *   </Tabs.Tab>\n *\n *   <Tabs.Tab>\n *     You can find more information about self-hosting CopilotKit [here](/concepts/copilot-runtime).\n *\n *     ```tsx\n *     import { CopilotKit } from \"@copilotkit/react-core\";\n *\n *     <CopilotKit runtimeUrl=\"<your-runtime-url>\">\n *       // ... your app ...\n *     </CopilotKit>\n *     ```\n *   </Tabs.Tab>\n * </Tabs>\n */\nimport { useCallback, useRef, useState } from \"react\";\nimport {\n  CopilotContext,\n  CopilotApiConfig,\n  InChatRenderFunction,\n} from \"../../context/copilot-context\";\nimport useTree from \"../../hooks/use-tree\";\nimport { CopilotChatSuggestionConfiguration, DocumentPointer } from \"../../types\";\nimport { flushSync } from \"react-dom\";\nimport {\n  COPILOT_CLOUD_CHAT_URL,\n  CopilotCloudConfig,\n  FunctionCallHandler,\n} from \"@copilotkit/shared\";\nimport { Message } from \"@copilotkit/runtime-client-gql\";\n\nimport { FrontendAction } from \"../../types/frontend-action\";\nimport useFlatCategoryStore from \"../../hooks/use-flat-category-store\";\nimport { CopilotKitProps } from \"./copilotkit-props\";\n\nexport function CopilotKit({ children, ...props }: CopilotKitProps) {\n  // Compute all the functions and properties that we need to pass\n  // to the CopilotContext.\n\n  if (!props.runtimeUrl && !props.publicApiKey) {\n    throw new Error(\n      \"Please provide either a runtimeUrl or a publicApiKey to the CopilotKit component.\",\n    );\n  }\n\n  const chatApiEndpoint = props.runtimeUrl || COPILOT_CLOUD_CHAT_URL;\n\n  const [actions, setActions] = useState<Record<string, FrontendAction<any>>>({});\n  const chatComponentsCache = useRef<Record<string, InChatRenderFunction | string>>({});\n  const { addElement, removeElement, printTree } = useTree();\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [chatInstructions, setChatInstructions] = useState(\"\");\n\n  const {\n    addElement: addDocument,\n    removeElement: removeDocument,\n    allElements: allDocuments,\n  } = useFlatCategoryStore<DocumentPointer>();\n\n  const setAction = useCallback((id: string, action: FrontendAction<any>) => {\n    setActions((prevPoints) => {\n      return {\n        ...prevPoints,\n        [id]: action,\n      };\n    });\n  }, []);\n\n  const removeAction = useCallback((id: string) => {\n    setActions((prevPoints) => {\n      const newPoints = { ...prevPoints };\n      delete newPoints[id];\n      return newPoints;\n    });\n  }, []);\n\n  const getContextString = useCallback(\n    (documents: DocumentPointer[], categories: string[]) => {\n      const documentsString = documents\n        .map((document) => {\n          return `${document.name} (${document.sourceApplication}):\\n${document.getContents()}`;\n        })\n        .join(\"\\n\\n\");\n\n      const nonDocumentStrings = printTree(categories);\n\n      return `${documentsString}\\n\\n${nonDocumentStrings}`;\n    },\n    [printTree],\n  );\n\n  const addContext = useCallback(\n    (\n      context: string,\n      parentId?: string,\n      categories: string[] = defaultCopilotContextCategories,\n    ) => {\n      return addElement(context, categories, parentId);\n    },\n    [addElement],\n  );\n\n  const removeContext = useCallback(\n    (id: string) => {\n      removeElement(id);\n    },\n    [removeElement],\n  );\n\n  const getFunctionCallHandler = useCallback(\n    (customEntryPoints?: Record<string, FrontendAction<any>>) => {\n      return entryPointsToFunctionCallHandler(Object.values(customEntryPoints || actions));\n    },\n    [actions],\n  );\n\n  const getDocumentsContext = useCallback(\n    (categories: string[]) => {\n      return allDocuments(categories);\n    },\n    [allDocuments],\n  );\n\n  const addDocumentContext = useCallback(\n    (documentPointer: DocumentPointer, categories: string[] = defaultCopilotContextCategories) => {\n      return addDocument(documentPointer, categories);\n    },\n    [addDocument],\n  );\n\n  const removeDocumentContext = useCallback(\n    (documentId: string) => {\n      removeDocument(documentId);\n    },\n    [removeDocument],\n  );\n\n  if (!props.publicApiKey) {\n    if (props.cloudRestrictToTopic) {\n      throw new Error(\n        \"To use the cloudRestrictToTopic feature, please sign up at https://copilotkit.ai and provide a publicApiKey.\",\n      );\n    }\n  }\n\n  let cloud: CopilotCloudConfig | undefined = undefined;\n  if (props.publicApiKey) {\n    cloud = {\n      guardrails: {\n        input: {\n          restrictToTopic: {\n            enabled: props.cloudRestrictToTopic ? true : false,\n            validTopics: props.cloudRestrictToTopic?.validTopics || [],\n            invalidTopics: props.cloudRestrictToTopic?.invalidTopics || [],\n          },\n        },\n      },\n    };\n  }\n\n  // get the appropriate CopilotApiConfig from the props\n  const copilotApiConfig: CopilotApiConfig = {\n    publicApiKey: props.publicApiKey,\n    ...(cloud ? { cloud } : {}),\n    chatApiEndpoint: chatApiEndpoint,\n    headers: props.headers || {},\n    properties: props.properties || {},\n    transcribeAudioUrl: props.transcribeAudioUrl,\n    textToSpeechUrl: props.textToSpeechUrl,\n    credentials: props.credentials,\n  };\n\n  const [chatSuggestionConfiguration, setChatSuggestionConfiguration] = useState<{\n    [key: string]: CopilotChatSuggestionConfiguration;\n  }>({});\n\n  const addChatSuggestionConfiguration = (\n    id: string,\n    suggestion: CopilotChatSuggestionConfiguration,\n  ) => {\n    setChatSuggestionConfiguration((prev) => ({ ...prev, [id]: suggestion }));\n  };\n\n  const removeChatSuggestionConfiguration = (id: string) => {\n    setChatSuggestionConfiguration((prev) => {\n      const { [id]: _, ...rest } = prev;\n      return rest;\n    });\n  };\n\n  return (\n    <CopilotContext.Provider\n      value={{\n        actions,\n        chatComponentsCache,\n        getFunctionCallHandler,\n        setAction,\n        removeAction,\n        getContextString,\n        addContext,\n        removeContext,\n        getDocumentsContext,\n        addDocumentContext,\n        removeDocumentContext,\n        copilotApiConfig: copilotApiConfig,\n        messages,\n        setMessages,\n        isLoading,\n        setIsLoading,\n        chatSuggestionConfiguration,\n        addChatSuggestionConfiguration,\n        removeChatSuggestionConfiguration,\n        chatInstructions,\n        setChatInstructions,\n        showDevConsole: props.showDevConsole === undefined ? \"auto\" : props.showDevConsole,\n      }}\n    >\n      {children}\n    </CopilotContext.Provider>\n  );\n}\n\nexport const defaultCopilotContextCategories = [\"global\"];\n\nfunction entryPointsToFunctionCallHandler(actions: FrontendAction<any>[]): FunctionCallHandler {\n  return async ({ messages, name, args }) => {\n    let actionsByFunctionName: Record<string, FrontendAction<any>> = {};\n    for (let action of actions) {\n      actionsByFunctionName[action.name] = action;\n    }\n\n    const action = actionsByFunctionName[name];\n    let result: any = undefined;\n    if (action) {\n      await new Promise<void>((resolve, reject) => {\n        flushSync(async () => {\n          try {\n            result = await action.handler(args);\n            resolve();\n          } catch (error) {\n            reject(error);\n          }\n        });\n      });\n      await new Promise((resolve) => setTimeout(resolve, 20));\n    }\n    return result;\n  };\n}\n"],"mappings":"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","names":["import_react","React","import_runtime_client_gql","import_react","messages","import_react","import_shared"]}