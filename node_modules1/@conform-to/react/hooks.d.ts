import { type FieldConstraint, type FieldElement, type FieldsetConstraint, type Submission, type KeysOf, type ResolveType, getFormEncType, getFormMethod } from '@conform-to/dom';
import { type FormEvent, type RefObject } from 'react';
export type Primitive = null | undefined | string | number | boolean | Date;
export interface FieldConfig<Schema> extends FieldConstraint<Schema> {
    id?: string;
    name: string;
    defaultValue?: FieldValue<Schema>;
    initialError?: Record<string, string | string[]>;
    form?: string;
    descriptionId?: string;
    errorId?: string;
    /**
     * The frist error of the field
     */
    error?: string;
    /**
     * All of the field errors
     */
    errors?: string[];
}
export type FieldValue<Schema> = Schema extends Primitive ? string : Schema extends File ? File : Schema extends Array<infer InnerType> ? Array<FieldValue<InnerType>> : unknown extends Schema ? any : Record<string, any> extends Schema ? {
    [Key in KeysOf<Schema>]?: FieldValue<ResolveType<Schema, Key>>;
} : any;
export interface FormConfig<Output extends Record<string, any>, Input extends Record<string, any> = Output> {
    /**
     * If the form id is provided, Id for label,
     * input and error elements will be derived.
     */
    id?: string;
    /**
     * A form ref object. Conform will fallback to its own ref object if it is not provided.
     */
    ref?: RefObject<HTMLFormElement>;
    /**
     * @deprecated Use `shouldValidate` and `shouldRevalidate` instead.
     */
    initialReport?: 'onSubmit' | 'onChange' | 'onBlur';
    /**
     * Define when conform should start validation.
     * Support "onSubmit", "onChange", "onBlur".
     *
     * Default to `onSubmit`.
     */
    shouldValidate?: 'onSubmit' | 'onBlur' | 'onInput';
    /**
     * Define when conform should revalidate again.
     * Support "onSubmit", "onChange", "onBlur".
     *
     * Default to `onInput`.
     */
    shouldRevalidate?: 'onSubmit' | 'onBlur' | 'onInput';
    /**
     * An object representing the initial value of the form.
     */
    defaultValue?: FieldValue<Input>;
    /**
     * An object describing the result of the last submission
     */
    lastSubmission?: Submission;
    /**
     * An object describing the constraint of each field
     */
    constraint?: FieldsetConstraint<Input>;
    /**
     * Enable native validation before hydation.
     *
     * Default to `false`.
     */
    fallbackNative?: boolean;
    /**
     * Accept form submission regardless of the form validity.
     *
     * Default to `false`.
     */
    noValidate?: boolean;
    /**
     * A function to be called when the form should be (re)validated.
     */
    onValidate?: ({ form, formData, }: {
        form: HTMLFormElement;
        formData: FormData;
    }) => Submission | Submission<Output>;
    /**
     * The submit event handler of the form. It will be called
     * only when the form is considered valid.
     */
    onSubmit?: (event: FormEvent<HTMLFormElement>, context: {
        formData: FormData;
        submission: Submission;
        action: string;
        encType: ReturnType<typeof getFormEncType>;
        method: ReturnType<typeof getFormMethod>;
    }) => void;
}
/**
 * Properties to be applied to the form element
 */
interface FormProps {
    id?: string;
    ref: RefObject<HTMLFormElement>;
    onSubmit: (event: FormEvent<HTMLFormElement>) => void;
    noValidate: boolean;
    'aria-invalid'?: 'true';
    'aria-describedby'?: string;
}
interface Form {
    id?: string;
    errorId?: string;
    error: string;
    errors: string[];
    ref: RefObject<HTMLFormElement>;
    props: FormProps;
}
/**
 * Returns properties required to hook into form events.
 * Applied custom validation and define when error should be reported.
 *
 * @see https://conform.guide/api/react#useform
 */
export declare function useForm<Output extends Record<string, any>, Input extends Record<string, any> = Output>(config?: FormConfig<Output, Input>): [Form, Fieldset<Input>];
/**
 * A set of field configuration
 */
export type Fieldset<Schema extends Record<string, any> | undefined> = {
    [Key in KeysOf<Schema>]-?: FieldConfig<ResolveType<Schema, Key>>;
};
export interface FieldsetConfig<Schema extends Record<string, any> | undefined> {
    /**
     * The prefix used to generate the name of nested fields.
     */
    name?: string;
    /**
     * An object representing the initial value of the fieldset.
     */
    defaultValue?: FieldValue<Schema>;
    /**
     * An object describing the initial error of each field
     */
    initialError?: Record<string, string | string[]>;
    /**
     * An object describing the constraint of each field
     */
    constraint?: FieldsetConstraint<Schema>;
    /**
     * The id of the form, connecting each field to a form remotely
     */
    form?: string;
}
/**
 * Returns all the information about the fieldset.
 *
 * @see https://conform.guide/api/react#usefieldset
 */
export declare function useFieldset<Schema extends Record<string, any> | undefined>(ref: RefObject<HTMLFormElement | HTMLFieldSetElement>, config: FieldsetConfig<Schema>): Fieldset<Schema>;
export declare function useFieldset<Schema extends Record<string, any> | undefined>(ref: RefObject<HTMLFormElement | HTMLFieldSetElement>, config: FieldConfig<Schema>): Fieldset<Schema>;
/**
 * Returns a list of key and field config.
 *
 * @see https://conform.guide/api/react#usefieldlist
 */
export declare function useFieldList<Schema extends Array<any> | undefined>(ref: RefObject<HTMLFormElement | HTMLFieldSetElement>, config: FieldConfig<Schema>): Array<{
    key: string;
} & FieldConfig<Schema extends Array<infer Item> ? Item : never>>;
interface InputControl {
    change: (eventOrValue: {
        target: {
            value: string;
        };
    } | string) => void;
    focus: () => void;
    blur: () => void;
}
/**
 * Returns a ref object and a set of helpers that dispatch corresponding dom event.
 *
 * @see https://conform.guide/api/react#useinputevent
 */
export declare function useInputEvent<RefShape extends FieldElement = HTMLInputElement>(options?: {
    onSubmit?: (event: SubmitEvent) => void;
    onReset?: (event: Event) => void;
}): [RefObject<RefShape>, InputControl];
export declare function useInputEvent<RefShape extends Exclude<any, FieldElement>>(options: {
    getElement: (ref: RefShape | null) => FieldElement | null | undefined;
    onSubmit?: (event: SubmitEvent) => void;
    onReset?: (event: Event) => void;
}): [RefObject<RefShape>, InputControl];
export declare const VALIDATION_UNDEFINED = "__undefined__";
export declare const VALIDATION_SKIPPED = "__skipped__";
export declare const FORM_ERROR_ELEMENT_NAME = "__form__";
/**
 * Validate the form with the Constraint Validation API
 * @see https://conform.guide/api/react#validateconstraint
 */
export declare function validateConstraint(options: {
    form: HTMLFormElement;
    formData?: FormData;
    constraint?: Record<Lowercase<string>, (value: string, context: {
        formData: FormData;
        attributeValue: string;
    }) => boolean>;
    acceptMultipleErrors?: ({ name, intent, payload, }: {
        name: string;
        intent: string;
        payload: Record<string, any>;
    }) => boolean;
    formatMessages?: ({ name, validity, constraint, defaultErrors, }: {
        name: string;
        validity: ValidityState;
        constraint: Record<string, boolean>;
        defaultErrors: string[];
    }) => string[];
}): Submission;
export declare function reportSubmission(form: HTMLFormElement, submission: Submission): void;
/**
 * Check if the current focus is on a intent button.
 */
export declare function isFocusedOnIntentButton(form: HTMLFormElement, intent: string): boolean;
export {};
