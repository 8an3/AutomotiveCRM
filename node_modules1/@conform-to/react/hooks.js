'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('./_virtual/_rollupPluginBabelHelpers.js');
var dom = require('@conform-to/dom');
var react = require('react');

/**
 * Normalize error to an array of string.
 */
function normalizeError(error) {
  if (!error) {
    // This treat both empty string and undefined as no error.
    return [];
  }
  return [].concat(error);
}
function useNoValidate(defaultNoValidate, validateBeforeHydrate) {
  var [noValidate, setNoValidate] = react.useState(defaultNoValidate || !validateBeforeHydrate);
  react.useEffect(() => {
    setNoValidate(true);
  }, []);
  return noValidate;
}
function useFormRef(userProvidedRef) {
  var formRef = react.useRef(null);
  return userProvidedRef !== null && userProvidedRef !== void 0 ? userProvidedRef : formRef;
}
function useConfigRef(config) {
  var ref = react.useRef(config);
  useSafeLayoutEffect(() => {
    ref.current = config;
  });
  return ref;
}
function useFormReporter(ref, lastSubmission) {
  var [submission, setSubmission] = react.useState(lastSubmission);
  var report = react.useCallback((form, submission) => {
    var event = new CustomEvent('conform', {
      detail: submission.intent
    });
    form.dispatchEvent(event);
    setSubmission(submission);
  }, []);
  react.useEffect(() => {
    var form = ref.current;
    if (!form || !lastSubmission) {
      return;
    }
    report(form, lastSubmission);
  }, [ref, lastSubmission, report]);
  react.useEffect(() => {
    var form = ref.current;
    if (!form || !submission) {
      return;
    }
    reportSubmission(form, submission);
  }, [ref, submission]);
  return report;
}
function useFormError(ref, config) {
  var [error, setError] = react.useState(() => {
    if (!config.initialError) {
      return {};
    }
    var result = {};
    for (var [name, message] of Object.entries(config.initialError)) {
      var paths = dom.getPaths(name);
      if (paths.length === 1) {
        result[paths[0]] = normalizeError(message);
      }
    }
    return result;
  });
  react.useEffect(() => {
    var handleInvalid = event => {
      var form = dom.getFormElement(ref.current);
      var element = event.target;
      if (!dom.isFieldElement(element) || element.form !== form || !element.dataset.conformTouched) {
        return;
      }
      var key = element.name;
      if (config.name) {
        var scopePaths = dom.getPaths(config.name);
        var fieldPaths = dom.getPaths(element.name);
        for (var i = 0; i <= scopePaths.length; i++) {
          var path = fieldPaths[i];
          if (i < scopePaths.length) {
            // Skip if the field is not in the scope
            if (path !== scopePaths[i]) {
              return;
            }
          } else {
            key = path;
          }
        }
      }
      setError(prev => {
        if (element.validationMessage === dom.getValidationMessage(prev[key])) {
          return prev;
        }
        return _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, prev), {}, {
          [key]: dom.getErrors(element.validationMessage)
        });
      });
      event.preventDefault();
    };
    var handleReset = event => {
      var form = dom.getFormElement(ref.current);
      if (form && event.target === form) {
        setError({});
      }
    };
    document.addEventListener('reset', handleReset);
    document.addEventListener('invalid', handleInvalid, true);
    return () => {
      document.removeEventListener('reset', handleReset);
      document.removeEventListener('invalid', handleInvalid, true);
    };
  }, [ref, config.name]);
  return [error, setError];
}

/**
 * Returns properties required to hook into form events.
 * Applied custom validation and define when error should be reported.
 *
 * @see https://conform.guide/api/react#useform
 */
function useForm() {
  var _ref, _config$lastSubmissio2;
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var configRef = useConfigRef(config);
  var ref = useFormRef(config.ref);
  var noValidate = useNoValidate(config.noValidate, config.fallbackNative);
  var report = useFormReporter(ref, config.lastSubmission);
  var [errors, setErrors] = react.useState(() => {
    var _config$lastSubmissio;
    return normalizeError((_config$lastSubmissio = config.lastSubmission) === null || _config$lastSubmissio === void 0 ? void 0 : _config$lastSubmissio.error['']);
  });
  var initialError = react.useMemo(() => {
    var submission = config.lastSubmission;
    if (!submission) {
      return {};
    }
    var scope = dom.getScope(submission.intent);
    return scope === null ? submission.error : {
      [scope]: submission.error[scope]
    };
  }, [config.lastSubmission]);
  var fieldset = useFieldset(ref, {
    defaultValue: (_ref = (_config$lastSubmissio2 = config.lastSubmission) === null || _config$lastSubmissio2 === void 0 ? void 0 : _config$lastSubmissio2.payload) !== null && _ref !== void 0 ? _ref : config.defaultValue,
    initialError,
    constraint: config.constraint,
    form: config.id
  });
  react.useEffect(() => {
    // custom validate handler
    var createValidateHandler = name => event => {
      var field = event.target;
      var form = ref.current;
      var {
        initialReport = 'onSubmit',
        shouldValidate = initialReport === 'onChange' ? 'onInput' : initialReport,
        shouldRevalidate = 'onInput'
      } = configRef.current;
      if (!form || !dom.isFocusableFormControl(field) || field.form !== form || !field.name) {
        return;
      }
      if (field.dataset.conformTouched ? shouldRevalidate === name : shouldValidate === name) {
        dom.requestIntent(form, dom.validate(field.name));
      }
    };
    var handleInvalid = event => {
      var form = ref.current;
      var field = event.target;
      if (!form || !dom.isFieldElement(field) || field.form !== form || field.name !== FORM_ERROR_ELEMENT_NAME) {
        return;
      }
      event.preventDefault();
      if (field.dataset.conformTouched) {
        setErrors(dom.getErrors(field.validationMessage));
      }
    };
    var handleReset = event => {
      var form = ref.current;
      if (!form || event.target !== form) {
        return;
      }

      // Reset all field state
      for (var element of dom.getFormControls(form)) {
        delete element.dataset.conformTouched;
        element.setCustomValidity('');
      }
      setErrors([]);
    };
    var handleInput = createValidateHandler('onInput');
    var handleBlur = createValidateHandler('onBlur');
    document.addEventListener('input', handleInput, true);
    document.addEventListener('blur', handleBlur, true);
    document.addEventListener('invalid', handleInvalid, true);
    document.addEventListener('reset', handleReset);
    return () => {
      document.removeEventListener('input', handleInput, true);
      document.removeEventListener('blur', handleBlur, true);
      document.removeEventListener('invalid', handleInvalid, true);
      document.removeEventListener('reset', handleReset);
    };
  }, [ref, configRef]);
  var form = {
    ref,
    error: errors[0],
    errors,
    props: {
      ref,
      noValidate,
      onSubmit(event) {
        var form = event.currentTarget;
        var nativeEvent = event.nativeEvent;
        var submitter = nativeEvent.submitter;
        if (event.defaultPrevented) {
          return;
        }
        try {
          var _config$onValidate, _config$onValidate2;
          var formData = dom.getFormData(form, submitter);
          var submission = (_config$onValidate = (_config$onValidate2 = config.onValidate) === null || _config$onValidate2 === void 0 ? void 0 : _config$onValidate2.call(config, {
            form,
            formData
          })) !== null && _config$onValidate !== void 0 ? _config$onValidate : dom.parse(formData);
          var messages = Object.entries(submission.error).reduce((messages, _ref2) => {
            var [, message] = _ref2;
            return messages.concat(normalizeError(message));
          }, []);
          var shouldValidate = !config.noValidate && !(submitter !== null && submitter !== void 0 && submitter.formNoValidate);
          var shouldFallbackToServer = messages.includes(VALIDATION_UNDEFINED);
          var hasClientValidation = typeof config.onValidate !== 'undefined';
          var isValid = messages.length === 0;
          if (hasClientValidation && (dom.isSubmitting(submission.intent) ? shouldValidate && !isValid : !shouldFallbackToServer)) {
            report(form, submission);
            event.preventDefault();
          } else {
            var _config$onSubmit;
            (_config$onSubmit = config.onSubmit) === null || _config$onSubmit === void 0 ? void 0 : _config$onSubmit.call(config, event, {
              formData,
              submission,
              action: dom.getFormAction(nativeEvent),
              encType: dom.getFormEncType(nativeEvent),
              method: dom.getFormMethod(nativeEvent)
            });
          }
        } catch (e) {
          console.warn(e);
        }
      }
    }
  };
  if (config.id) {
    form.id = config.id;
    form.errorId = "".concat(config.id, "-error");
    form.props.id = form.id;
  }
  if (form.errorId && form.errors.length > 0) {
    form.props['aria-invalid'] = 'true';
    form.props['aria-describedby'] = form.errorId;
  }
  return [form, fieldset];
}

/**
 * A set of field configuration
 */

function useFieldset(ref, config) {
  var [error] = useFormError(ref, {
    initialError: config.initialError,
    name: config.name
  });

  /**
   * This allows us constructing the field at runtime as we have no information
   * about which fields would be available. The proxy will also help tracking
   * the usage of each field for optimization in the future.
   */
  return new Proxy({}, {
    get(_target, key) {
      var _fieldsetConfig$const, _fieldsetConfig$initi, _fieldsetConfig$defau;
      if (typeof key !== 'string') {
        return;
      }
      var fieldsetConfig = config;
      var constraint = (_fieldsetConfig$const = fieldsetConfig.constraint) === null || _fieldsetConfig$const === void 0 ? void 0 : _fieldsetConfig$const[key];
      var errors = error === null || error === void 0 ? void 0 : error[key];
      var initialError = Object.entries((_fieldsetConfig$initi = fieldsetConfig.initialError) !== null && _fieldsetConfig$initi !== void 0 ? _fieldsetConfig$initi : {}).reduce((result, _ref3) => {
        var [name, message] = _ref3;
        var [field, ...paths] = dom.getPaths(name);
        if (field === key) {
          result[dom.getName(paths)] = message;
        }
        return result;
      }, {});
      var field = _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, constraint), {}, {
        name: fieldsetConfig.name ? "".concat(fieldsetConfig.name, ".").concat(key) : key,
        // @ts-expect-error The FieldValue type might need a rework
        defaultValue: (_fieldsetConfig$defau = fieldsetConfig.defaultValue) === null || _fieldsetConfig$defau === void 0 ? void 0 : _fieldsetConfig$defau[key],
        initialError,
        error: errors === null || errors === void 0 ? void 0 : errors[0],
        errors
      });
      if (fieldsetConfig.form) {
        field.form = fieldsetConfig.form;
        field.id = "".concat(fieldsetConfig.form, "-").concat(field.name);
        field.errorId = "".concat(field.id, "-error");
        field.descriptionId = "".concat(field.id, "-description");
      }
      return field;
    }
  });
}

/**
 * Returns a list of key and field config.
 *
 * @see https://conform.guide/api/react#usefieldlist
 */
function useFieldList(ref, config) {
  var configRef = useConfigRef(config);
  var [error, setError] = useFormError(ref, {
    initialError: config.initialError,
    name: config.name
  });
  var [entries, setEntries] = react.useState(() => {
    var _config$defaultValue;
    return Object.entries((_config$defaultValue = config.defaultValue) !== null && _config$defaultValue !== void 0 ? _config$defaultValue : [undefined]);
  });
  react.useEffect(() => {
    var conformHandler = event => {
      var form = dom.getFormElement(ref.current);
      if (!form || event.target !== form) {
        return;
      }
      var command = dom.parseListCommand(event.detail);
      if ((command === null || command === void 0 ? void 0 : command.scope) !== configRef.current.name) {
        // Ensure the scope of the listener are limited to specific field name
        return;
      }
      setEntries(entries => {
        switch (command.type) {
          case 'append':
          case 'prepend':
          case 'replace':
            return dom.updateList([...(entries !== null && entries !== void 0 ? entries : [])], _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, command), {}, {
              payload: _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, command.payload), {}, {
                defaultValue: ["".concat(Date.now()),
                // @ts-expect-error unknown type as it is sent through network
                command.payload.defaultValue]
              })
            }));
          default:
            {
              return dom.updateList([...(entries !== null && entries !== void 0 ? entries : [])], command);
            }
        }
      });
      setError(error => {
        var errorList = [];
        for (var [key, messages] of Object.entries(error)) {
          if (typeof key === 'number') {
            errorList[key] = messages;
          }
        }
        switch (command.type) {
          case 'append':
          case 'prepend':
          case 'replace':
            errorList = dom.updateList(errorList, _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, command), {}, {
              payload: _rollupPluginBabelHelpers.objectSpread2(_rollupPluginBabelHelpers.objectSpread2({}, command.payload), {}, {
                defaultValue: undefined
              })
            }));
            break;
          default:
            {
              errorList = dom.updateList(errorList, command);
              break;
            }
        }
        return Object.assign({}, errorList);
      });
    };
    var resetHandler = event => {
      var _configRef$current$de;
      var form = dom.getFormElement(ref.current);
      if (!form || event.target !== form) {
        return;
      }
      setEntries(Object.entries((_configRef$current$de = configRef.current.defaultValue) !== null && _configRef$current$de !== void 0 ? _configRef$current$de : [undefined]));
    };

    // @ts-expect-error Custom event: conform
    document.addEventListener('conform', conformHandler, true);
    document.addEventListener('reset', resetHandler);
    return () => {
      // @ts-expect-error Custom event: conform
      document.removeEventListener('conform', conformHandler, true);
      document.removeEventListener('reset', resetHandler);
    };
  }, [ref, configRef, setError]);
  return entries.map((_ref4, index) => {
    var _config$initialError, _config$defaultValue2;
    var [key, defaultValue] = _ref4;
    var errors = error[index];
    var initialError = Object.entries((_config$initialError = config.initialError) !== null && _config$initialError !== void 0 ? _config$initialError : {}).reduce((result, _ref5) => {
      var [name, message] = _ref5;
      var [field, ...paths] = dom.getPaths(name);
      if (field === index) {
        result[dom.getName(paths)] = message;
      }
      return result;
    }, {});
    var fieldConfig = {
      name: "".concat(config.name, "[").concat(index, "]"),
      defaultValue: defaultValue !== null && defaultValue !== void 0 ? defaultValue : (_config$defaultValue2 = config.defaultValue) === null || _config$defaultValue2 === void 0 ? void 0 : _config$defaultValue2[index],
      initialError,
      error: errors === null || errors === void 0 ? void 0 : errors[0],
      errors
    };
    if (config.form) {
      fieldConfig.form = config.form;
      fieldConfig.id = "".concat(config.form, "-").concat(config.name);
      fieldConfig.errorId = "".concat(fieldConfig.id, "-error");
      fieldConfig.descriptionId = "".concat(fieldConfig.id, "-description");
    }
    return _rollupPluginBabelHelpers.objectSpread2({
      key
    }, fieldConfig);
  });
}

/**
 * Triggering react custom change event
 * Solution based on dom-testing-library
 * @see https://github.com/facebook/react/issues/10135#issuecomment-401496776
 * @see https://github.com/testing-library/dom-testing-library/blob/main/src/events.js#L104-L123
 */
function setNativeValue(element, value) {
  if (element.value === value) {
    // It will not trigger a change event if `element.value` is the same as the set value
    return;
  }
  var {
    set: valueSetter
  } = Object.getOwnPropertyDescriptor(element, 'value') || {};
  var prototype = Object.getPrototypeOf(element);
  var {
    set: prototypeValueSetter
  } = Object.getOwnPropertyDescriptor(prototype, 'value') || {};
  if (prototypeValueSetter && valueSetter !== prototypeValueSetter) {
    prototypeValueSetter.call(element, value);
  } else {
    if (valueSetter) {
      valueSetter.call(element, value);
    } else {
      throw new Error('The given element does not have a value setter');
    }
  }
}

/**
 * useLayoutEffect is client-only.
 * This basically makes it a no-op on server
 */
var useSafeLayoutEffect = typeof document === 'undefined' ? react.useEffect : react.useLayoutEffect;
function useInputEvent(options) {
  var ref = react.useRef(null);
  var optionsRef = useConfigRef(options);
  var changeDispatched = react.useRef(false);
  var focusDispatched = react.useRef(false);
  var blurDispatched = react.useRef(false);
  useSafeLayoutEffect(() => {
    var getInputElement = () => {
      var _optionsRef$current$g, _optionsRef$current, _optionsRef$current$g2;
      return (_optionsRef$current$g = (_optionsRef$current = optionsRef.current) === null || _optionsRef$current === void 0 ? void 0 : (_optionsRef$current$g2 = _optionsRef$current.getElement) === null || _optionsRef$current$g2 === void 0 ? void 0 : _optionsRef$current$g2.call(_optionsRef$current, ref.current)) !== null && _optionsRef$current$g !== void 0 ? _optionsRef$current$g : ref.current;
    };
    var inputHandler = event => {
      var input = getInputElement();
      if (input && event.target === input) {
        changeDispatched.current = true;
      }
    };
    var focusHandler = event => {
      var input = getInputElement();
      if (input && event.target === input) {
        focusDispatched.current = true;
      }
    };
    var blurHandler = event => {
      var input = getInputElement();
      if (input && event.target === input) {
        blurDispatched.current = true;
      }
    };
    var submitHandler = event => {
      var input = getInputElement();
      if (input !== null && input !== void 0 && input.form && event.target === input.form) {
        var _optionsRef$current2, _optionsRef$current2$;
        (_optionsRef$current2 = optionsRef.current) === null || _optionsRef$current2 === void 0 ? void 0 : (_optionsRef$current2$ = _optionsRef$current2.onSubmit) === null || _optionsRef$current2$ === void 0 ? void 0 : _optionsRef$current2$.call(_optionsRef$current2, event);
      }
    };
    var resetHandler = event => {
      var input = getInputElement();
      if (input !== null && input !== void 0 && input.form && event.target === input.form) {
        var _optionsRef$current3, _optionsRef$current3$;
        (_optionsRef$current3 = optionsRef.current) === null || _optionsRef$current3 === void 0 ? void 0 : (_optionsRef$current3$ = _optionsRef$current3.onReset) === null || _optionsRef$current3$ === void 0 ? void 0 : _optionsRef$current3$.call(_optionsRef$current3, event);
      }
    };
    document.addEventListener('input', inputHandler, true);
    document.addEventListener('focus', focusHandler, true);
    document.addEventListener('blur', blurHandler, true);
    document.addEventListener('submit', submitHandler);
    document.addEventListener('reset', resetHandler);
    return () => {
      document.removeEventListener('input', inputHandler, true);
      document.removeEventListener('focus', focusHandler, true);
      document.removeEventListener('blur', blurHandler, true);
      document.removeEventListener('submit', submitHandler);
      document.removeEventListener('reset', resetHandler);
    };
  }, []);
  var control = react.useMemo(() => {
    var getInputElement = () => {
      var _optionsRef$current$g3, _optionsRef$current4, _optionsRef$current4$;
      return (_optionsRef$current$g3 = (_optionsRef$current4 = optionsRef.current) === null || _optionsRef$current4 === void 0 ? void 0 : (_optionsRef$current4$ = _optionsRef$current4.getElement) === null || _optionsRef$current4$ === void 0 ? void 0 : _optionsRef$current4$.call(_optionsRef$current4, ref.current)) !== null && _optionsRef$current$g3 !== void 0 ? _optionsRef$current$g3 : ref.current;
    };
    return {
      change(eventOrValue) {
        var input = getInputElement();
        if (!input) {
          console.warn('Missing input ref; No change-related events will be dispatched');
          return;
        }
        if (changeDispatched.current) {
          changeDispatched.current = false;
          return;
        }
        var previousValue = input.value;
        var nextValue = typeof eventOrValue === 'string' ? eventOrValue : eventOrValue.target.value;

        // This make sure no event is dispatched on the first effect run
        if (nextValue === previousValue) {
          return;
        }

        // Dispatch beforeinput event before updating the input value
        input.dispatchEvent(new Event('beforeinput', {
          bubbles: true
        }));
        // Update the input value to trigger a change event
        setNativeValue(input, nextValue);
        // Dispatch input event with the updated input value
        input.dispatchEvent(new InputEvent('input', {
          bubbles: true
        }));
        // Reset the dispatched flag
        changeDispatched.current = false;
      },
      focus() {
        var input = getInputElement();
        if (!input) {
          console.warn('Missing input ref; No focus-related events will be dispatched');
          return;
        }
        if (focusDispatched.current) {
          focusDispatched.current = false;
          return;
        }
        var focusinEvent = new FocusEvent('focusin', {
          bubbles: true
        });
        var focusEvent = new FocusEvent('focus');
        input.dispatchEvent(focusinEvent);
        input.dispatchEvent(focusEvent);

        // Reset the dispatched flag
        focusDispatched.current = false;
      },
      blur() {
        var input = getInputElement();
        if (!input) {
          console.warn('Missing input ref; No blur-related events will be dispatched');
          return;
        }
        if (blurDispatched.current) {
          blurDispatched.current = false;
          return;
        }
        var focusoutEvent = new FocusEvent('focusout', {
          bubbles: true
        });
        var blurEvent = new FocusEvent('blur');
        input.dispatchEvent(focusoutEvent);
        input.dispatchEvent(blurEvent);

        // Reset the dispatched flag
        blurDispatched.current = false;
      }
    };
  }, [optionsRef]);
  return [ref, control];
}
var VALIDATION_UNDEFINED = '__undefined__';
var VALIDATION_SKIPPED = '__skipped__';
var FORM_ERROR_ELEMENT_NAME = '__form__';

/**
 * Validate the form with the Constraint Validation API
 * @see https://conform.guide/api/react#validateconstraint
 */
function validateConstraint(options) {
  var _options$formData, _options$formatMessag;
  var formData = (_options$formData = options === null || options === void 0 ? void 0 : options.formData) !== null && _options$formData !== void 0 ? _options$formData : new FormData(options.form);
  var getDefaultErrors = (validity, result) => {
    var errors = [];
    if (validity.valueMissing) errors.push('required');
    if (validity.typeMismatch || validity.badInput) errors.push('type');
    if (validity.tooShort) errors.push('minLength');
    if (validity.rangeUnderflow) errors.push('min');
    if (validity.stepMismatch) errors.push('step');
    if (validity.tooLong) errors.push('maxLength');
    if (validity.rangeOverflow) errors.push('max');
    if (validity.patternMismatch) errors.push('pattern');
    for (var [constraintName, valid] of Object.entries(result)) {
      if (!valid) {
        errors.push(constraintName);
      }
    }
    return errors;
  };
  var formatMessages = (_options$formatMessag = options === null || options === void 0 ? void 0 : options.formatMessages) !== null && _options$formatMessag !== void 0 ? _options$formatMessag : _ref6 => {
    var {
      defaultErrors
    } = _ref6;
    return defaultErrors;
  };
  return dom.parse(formData, {
    resolve(payload, intent) {
      var error = {};
      var constraintPattern = /^constraint[A-Z][^A-Z]*$/;
      var _loop = function _loop(element) {
        if (dom.isFieldElement(element)) {
          var _options$acceptMultip, _options$acceptMultip2;
          var name = element.name !== FORM_ERROR_ELEMENT_NAME ? element.name : '';
          var constraint = Object.entries(element.dataset).reduce((result, _ref7) => {
            var [name, attributeValue = ''] = _ref7;
            if (constraintPattern.test(name)) {
              var _options$constraint;
              var constraintName = name.slice(10).toLowerCase();
              var _validate = (_options$constraint = options.constraint) === null || _options$constraint === void 0 ? void 0 : _options$constraint[constraintName];
              if (typeof _validate === 'function') {
                result[constraintName] = _validate(element.value, {
                  formData,
                  attributeValue
                });
              } else {
                console.warn("Found an \"".concat(constraintName, "\" constraint with undefined definition; Please specify it on the validateConstraint API."));
              }
            }
            return result;
          }, {});
          var errors = formatMessages({
            name,
            validity: element.validity,
            constraint,
            defaultErrors: getDefaultErrors(element.validity, constraint)
          });
          var shouldAcceptMultipleErrors = (_options$acceptMultip = options === null || options === void 0 ? void 0 : (_options$acceptMultip2 = options.acceptMultipleErrors) === null || _options$acceptMultip2 === void 0 ? void 0 : _options$acceptMultip2.call(options, {
            name,
            payload,
            intent
          })) !== null && _options$acceptMultip !== void 0 ? _options$acceptMultip : false;
          if (errors.length > 0) {
            error[name] = shouldAcceptMultipleErrors ? errors : errors[0];
          }
        }
      };
      for (var element of options.form.elements) {
        _loop(element);
      }
      return {
        error
      };
    }
  });
}
function reportSubmission(form, submission) {
  for (var [name, message] of Object.entries(submission.error)) {
    // There is no need to create a placeholder button if all we want is to reset the error
    if (message === '') {
      continue;
    }

    // We can't use empty string as button name
    // As `form.element.namedItem('')` will always returns null
    var elementName = name ? name : FORM_ERROR_ELEMENT_NAME;
    var item = form.elements.namedItem(elementName);
    if (item instanceof RadioNodeList) {
      for (var field of item) {
        if (field.type !== 'radio') {
          console.warn('Repeated field name is not supported.');
          continue;
        }
      }
    }
    if (item === null) {
      // Create placeholder button to keep the error without contributing to the form data
      var button = document.createElement('button');
      button.name = elementName;
      button.hidden = true;
      button.dataset.conformTouched = 'true';
      form.appendChild(button);
    }
  }
  var scope = dom.getScope(submission.intent);
  for (var element of dom.getFormControls(form)) {
    var _elementName = element.name !== FORM_ERROR_ELEMENT_NAME ? element.name : '';
    var messages = normalizeError(submission.error[_elementName]);
    if (scope === null || scope === _elementName) {
      element.dataset.conformTouched = 'true';
    }
    if (!messages.includes(VALIDATION_SKIPPED) && !messages.includes(VALIDATION_UNDEFINED)) {
      var invalidEvent = new Event('invalid', {
        cancelable: true
      });
      element.setCustomValidity(dom.getValidationMessage(messages));
      element.dispatchEvent(invalidEvent);
    }
  }
  if (dom.isSubmitting(submission.intent) || isFocusedOnIntentButton(form, submission.intent)) {
    if (scope) {
      dom.focusFormControl(form, scope);
    } else {
      dom.focusFirstInvalidControl(form);
    }
  }
}

/**
 * Check if the current focus is on a intent button.
 */
function isFocusedOnIntentButton(form, intent) {
  var element = document.activeElement;
  return dom.isFieldElement(element) && element.type === 'submit' && element.form === form && element.name === dom.INTENT && element.value === intent;
}

exports.FORM_ERROR_ELEMENT_NAME = FORM_ERROR_ELEMENT_NAME;
exports.VALIDATION_SKIPPED = VALIDATION_SKIPPED;
exports.VALIDATION_UNDEFINED = VALIDATION_UNDEFINED;
exports.isFocusedOnIntentButton = isFocusedOnIntentButton;
exports.reportSubmission = reportSubmission;
exports.useFieldList = useFieldList;
exports.useFieldset = useFieldset;
exports.useForm = useForm;
exports.useInputEvent = useInputEvent;
exports.validateConstraint = validateConstraint;
