import { objectSpread2 as _objectSpread2 } from './_virtual/_rollupPluginBabelHelpers.js';
import { parse as parse$1, getName } from '@conform-to/dom';
import * as z from 'zod';

function getFieldsetConstraint(source) {
  function getSchemaShape(schema) {
    if (schema instanceof z.ZodObject) {
      return schema.shape;
    } else if (schema instanceof z.ZodEffects) {
      return getSchemaShape(schema.innerType());
    } else if (schema instanceof z.ZodOptional) {
      return getSchemaShape(schema.unwrap());
    } else if (schema instanceof z.ZodIntersection) {
      return _objectSpread2(_objectSpread2({}, getSchemaShape(schema._def.left)), getSchemaShape(schema._def.right));
    }
    return null;
  }
  function inferConstraint(schema) {
    var constraint = {};
    if (schema instanceof z.ZodEffects) {
      constraint = _objectSpread2({}, inferConstraint(schema.innerType()));
    } else if (schema instanceof z.ZodOptional) {
      constraint = _objectSpread2(_objectSpread2({}, inferConstraint(schema.unwrap())), {}, {
        required: false
      });
    } else if (schema instanceof z.ZodDefault) {
      constraint = _objectSpread2(_objectSpread2({}, inferConstraint(schema.removeDefault())), {}, {
        required: false
      });
    } else if (schema instanceof z.ZodArray) {
      constraint = _objectSpread2(_objectSpread2({}, inferConstraint(schema.element)), {}, {
        multiple: true
      });
    } else if (schema instanceof z.ZodString) {
      for (var check of schema._def.checks) {
        switch (check.kind) {
          case 'min':
            if (!constraint.minLength || constraint.minLength < check.value) {
              constraint.minLength = check.value;
            }
            break;
          case 'max':
            if (!constraint.maxLength || constraint.maxLength > check.value) {
              constraint.maxLength = check.value;
            }
            break;
          case 'regex':
            if (!constraint.pattern) {
              constraint.pattern = check.regex.source;
            }
            break;
        }
      }
    } else if (schema instanceof z.ZodNumber) {
      for (var _check of schema._def.checks) {
        switch (_check.kind) {
          case 'min':
            if (!constraint.min || constraint.min < _check.value) {
              constraint.min = _check.value;
            }
            break;
          case 'max':
            if (!constraint.max || constraint.max > _check.value) {
              constraint.max = _check.value;
            }
            break;
        }
      }
    } else if (schema instanceof z.ZodEnum) {
      constraint.pattern = schema.options.map(option =>
      // To escape unsafe characters on regex
      option.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d')).join('|');
    }
    if (typeof constraint.required === 'undefined') {
      constraint.required = true;
    }
    return constraint;
  }
  var shape = getSchemaShape(source);
  var result = {};
  if (shape) {
    for (var [key, def] of Object.entries(shape)) {
      // @ts-expect-error
      result[key] = inferConstraint(def);
    }
  }
  return result;
}
function parse(payload, config) {
  return parse$1(payload, {
    resolve(payload, intent) {
      var schema = typeof config.schema === 'function' ? config.schema(intent) : config.schema;
      var resolveResult = result => {
        if (result.success) {
          return {
            value: result.data
          };
        }
        return {
          error: result.error.errors.reduce((result, e) => {
            var _config$acceptMultipl;
            var name = getName(e.path);
            if (typeof result[name] === 'undefined') {
              result[name] = e.message;
            } else if ((_config$acceptMultipl = config.acceptMultipleErrors) !== null && _config$acceptMultipl !== void 0 && _config$acceptMultipl.call(config, {
              name,
              intent,
              payload
            })) {
              result[name] = [].concat(result[name], e.message);
            }
            return result;
          }, {})
        };
      };
      return config.async ? schema.safeParseAsync(payload).then(resolveResult) : resolveResult(schema.safeParse(payload));
    }
  });
}
function ifNonEmptyString(fn) {
  return value => {
    if (typeof value !== 'string') {
      return value;
    }
    if (value === '') {
      return undefined;
    }
    return fn(value);
  };
}

export { getFieldsetConstraint, ifNonEmptyString, parse };
