/**
 * A ponyfill-like helper to get the form data with the submitter value.
 * It does not respect the tree order nor handles the image input.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData#parameters
 */

function getFormData(form, submitter) {
  var payload = new FormData(form);
  if (submitter && submitter.type === 'submit' && submitter.name !== '') {
    payload.append(submitter.name, submitter.value);
  }
  return payload;
}

/**
 * Returns the paths from a name based on the JS syntax convention
 * @example
 * ```js
 * const paths = getPaths('todos[0].content'); // ['todos', 0, 'content']
 * ```
 */
function getPaths(name) {
  var pattern = /(\w*)\[(\d+)\]/;
  if (!name) {
    return [];
  }
  return name.split('.').flatMap(key => {
    var matches = pattern.exec(key);
    if (!matches) {
      return key;
    }
    if (matches[1] === '') {
      return Number(matches[2]);
    }
    return [matches[1], Number(matches[2])];
  });
}

/**
 * Returns a formatted name from the paths based on the JS syntax convention
 * @example
 * ```js
 * const name = formatPaths(['todos', 0, 'content']); // "todos[0].content"
 * ```
 */
function formatPaths(paths) {
  return paths.reduce((name, path) => {
    if (typeof path === 'number') {
      return "".concat(name, "[").concat(path, "]");
    }
    if (name === '' || path === '') {
      return [name, path].join('');
    }
    return [name, path].join('.');
  }, '');
}

/**
 * Assign a value to a target object by following the paths on the name
 */
function setValue(target, name, valueFn) {
  var paths = getPaths(name);
  var length = paths.length;
  var lastIndex = length - 1;
  var index = -1;
  var pointer = target;
  while (pointer != null && ++index < length) {
    var _pointer$key;
    var key = paths[index];
    var next = paths[index + 1];
    var newValue = index != lastIndex ? (_pointer$key = pointer[key]) !== null && _pointer$key !== void 0 ? _pointer$key : typeof next === 'number' ? [] : {} : valueFn(pointer[key]);
    pointer[key] = newValue;
    pointer = pointer[key];
  }
}

/**
 * Resolves the payload into a plain object based on the JS syntax convention
 */
function resolve(payload) {
  var data = {};
  var _loop = function _loop(value) {
    setValue(data, name, prev => {
      if (!prev) {
        return value;
      } else if (Array.isArray(prev)) {
        return prev.concat(value);
      } else {
        return [prev, value];
      }
    });
  };
  for (var [name, value] of payload.entries()) {
    _loop(value);
  }
  return data;
}

/**
 * Format the error messages into a validation message
 */
function getValidationMessage(errors) {
  return [].concat(errors !== null && errors !== void 0 ? errors : []).join(String.fromCharCode(31));
}

/**
 * Retrieve the error messages from the validation message
 */
function getErrors(validationMessage) {
  if (!validationMessage) {
    return [];
  }
  return validationMessage.split(String.fromCharCode(31));
}

export { formatPaths, getErrors, getFormData, getPaths, getValidationMessage, resolve, setValue };
