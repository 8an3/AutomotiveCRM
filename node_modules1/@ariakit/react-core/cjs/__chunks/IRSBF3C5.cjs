"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _OMM6PC3Acjs = require('./OMM6PC3A.cjs');


var _O45IXGJWcjs = require('./O45IXGJW.cjs');


var _TVZPJJTXcjs = require('./TVZPJJTX.cjs');


var _QRAQT522cjs = require('./QRAQT522.cjs');


var _NZYGNCZLcjs = require('./NZYGNCZL.cjs');


var _E5VOJWDRcjs = require('./E5VOJWDR.cjs');


var _W32FX7DMcjs = require('./W32FX7DM.cjs');


var _CARNFZQTcjs = require('./CARNFZQT.cjs');


var _GHWBKA6Hcjs = require('./GHWBKA6H.cjs');


var _SOPRUU56cjs = require('./SOPRUU56.cjs');




var _N2VCZZLPcjs = require('./N2VCZZLP.cjs');


var _NVBNDB5Bcjs = require('./NVBNDB5B.cjs');


var _PFD4TS6Bcjs = require('./PFD4TS6B.cjs');


var _EM2PMFEWcjs = require('./EM2PMFEW.cjs');




var _7NAIPZYNcjs = require('./7NAIPZYN.cjs');








var _NREUHWTUcjs = require('./NREUHWTU.cjs');




var _6455U47Tcjs = require('./6455U47T.cjs');

// src/dialog/dialog.tsx
var _react = require('react');






var _dom = require('@ariakit/core/utils/dom');



var _events = require('@ariakit/core/utils/events');




var _focus = require('@ariakit/core/utils/focus');
var _misc = require('@ariakit/core/utils/misc');
var _platform = require('@ariakit/core/utils/platform');
var _jsxruntime = require('react/jsx-runtime');
var isSafariBrowser = _platform.isSafari.call(void 0, );
function isAlreadyFocusingAnotherElement(dialog) {
  const activeElement = _dom.getActiveElement.call(void 0, );
  if (!activeElement)
    return false;
  if (_dom.contains.call(void 0, dialog, activeElement))
    return false;
  if (activeElement.hasAttribute("data-dialog"))
    return false;
  if (_focus.isFocusable.call(void 0, activeElement))
    return true;
  return false;
}
function getElementFromProp(prop, focusable = false) {
  if (!prop)
    return null;
  const element = "current" in prop ? prop.current : prop;
  if (!element)
    return null;
  if (focusable)
    return _focus.isFocusable.call(void 0, element) ? element : null;
  return element;
}
var useDialog = _7NAIPZYNcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      store,
      focusable = true,
      modal = true,
      portal = !!modal,
      backdrop = !!modal,
      backdropProps,
      hideOnEscape = true,
      hideOnInteractOutside = true,
      getPersistentElements,
      preventBodyScroll = !!modal,
      autoFocusOnShow = true,
      autoFocusOnHide = true,
      initialFocus,
      finalFocus
    } = _b, props = _6455U47Tcjs.__objRest.call(void 0, _b, [
      "store",
      "focusable",
      "modal",
      "portal",
      "backdrop",
      "backdropProps",
      "hideOnEscape",
      "hideOnInteractOutside",
      "getPersistentElements",
      "preventBodyScroll",
      "autoFocusOnShow",
      "autoFocusOnHide",
      "initialFocus",
      "finalFocus"
    ]);
    const ref = _react.useRef.call(void 0, null);
    const { portalRef, portalNode, domReady } = _NREUHWTUcjs.usePortalRef.call(void 0, 
      portal,
      props.portalRef
    );
    const preserveTabOrderProp = props.preserveTabOrder;
    const preserveTabOrder = store.useState(
      (state) => preserveTabOrderProp && !modal && state.mounted
    );
    const id = _NREUHWTUcjs.useId.call(void 0, props.id);
    const open = store.useState("open");
    const mounted = store.useState("mounted");
    const contentElement = store.useState("contentElement");
    _QRAQT522cjs.usePreventBodyScroll.call(void 0, store, mounted && preventBodyScroll);
    _E5VOJWDRcjs.useHideOnInteractOutside.call(void 0, store, hideOnInteractOutside);
    const { wrapElement, nestedDialogs } = _NZYGNCZLcjs.useNestedDialogs.call(void 0, store);
    props = _NREUHWTUcjs.useWrapElement.call(void 0, props, wrapElement, [wrapElement]);
    _NREUHWTUcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!open)
        return;
      const dialog = ref.current;
      const activeElement = _dom.getActiveElement.call(void 0, dialog, true);
      if (!activeElement)
        return;
      if (activeElement.tagName === "BODY")
        return;
      if (dialog && _dom.contains.call(void 0, dialog, activeElement))
        return;
      store.setDisclosureElement(activeElement);
    }, [open]);
    if (isSafariBrowser) {
      _react.useEffect.call(void 0, () => {
        if (!mounted)
          return;
        const { disclosureElement } = store.getState();
        if (!disclosureElement)
          return;
        if (!_dom.isButton.call(void 0, disclosureElement))
          return;
        const onMouseDown = () => {
          let receivedFocus = false;
          const onFocus = () => {
            receivedFocus = true;
          };
          const options = { capture: true, once: true };
          disclosureElement.addEventListener("focusin", onFocus, options);
          _events.queueBeforeEvent.call(void 0, disclosureElement, "mouseup", () => {
            disclosureElement.removeEventListener("focusin", onFocus, true);
            if (receivedFocus)
              return;
            _focus.focusIfNeeded.call(void 0, disclosureElement);
          });
        };
        disclosureElement.addEventListener("mousedown", onMouseDown);
        return () => {
          disclosureElement.removeEventListener("mousedown", onMouseDown);
        };
      }, [mounted]);
    }
    const shouldDisableAccessibilityTree = modal || // Usually, we only want to disable the accessibility tree outside if the
    // dialog is a modal. But the Portal component can't preserve the tab
    // order on Safari/VoiceOver. By allowing only the dialog/portal to be
    // accessible, we provide a similar tab order flow. We don't need to
    // disable pointer events because it's just for screen readers.
    portal && preserveTabOrder && _platform.isSafari.call(void 0, );
    _react.useEffect.call(void 0, () => {
      if (!mounted)
        return;
      if (!domReady)
        return;
      const dialog = ref.current;
      if (!dialog)
        return;
      if (!shouldDisableAccessibilityTree)
        return;
      const existingDismiss = dialog.querySelector("[data-dialog-dismiss]");
      if (existingDismiss)
        return;
      return _W32FX7DMcjs.prependHiddenDismiss.call(void 0, dialog, store.hide);
    }, [mounted, domReady, shouldDisableAccessibilityTree]);
    const getPersistentElementsProp = _NREUHWTUcjs.useEvent.call(void 0, getPersistentElements);
    _NREUHWTUcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!id)
        return;
      if (!open)
        return;
      const { disclosureElement } = store.getState();
      const element = portal ? portalNode : ref.current;
      const persistentElements = getPersistentElementsProp() || [];
      const allElements = [element, ...nestedDialogs, ...persistentElements];
      if (!shouldDisableAccessibilityTree) {
        return _CARNFZQTcjs.markTreeOutside.call(void 0, id, disclosureElement, ...allElements);
      }
      if (modal) {
        return _misc.chain.call(void 0, 
          _CARNFZQTcjs.markTreeOutside.call(void 0, id, ...allElements),
          _O45IXGJWcjs.disableTreeOutside.call(void 0, ...allElements)
        );
      }
      return _misc.chain.call(void 0, 
        _CARNFZQTcjs.markTreeOutside.call(void 0, id, disclosureElement, ...allElements),
        _TVZPJJTXcjs.disableAccessibilityTreeOutside.call(void 0, ...allElements)
      );
    }, [
      id,
      open,
      store,
      portal,
      portalNode,
      nestedDialogs,
      getPersistentElementsProp,
      shouldDisableAccessibilityTree,
      modal
    ]);
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const autoFocusOnShowProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, autoFocusOnShow);
    const [autoFocusEnabled, setAutoFocusEnabled] = _react.useState.call(void 0, false);
    _react.useEffect.call(void 0, () => {
      if (!open)
        return;
      if (!mayAutoFocusOnShow)
        return;
      if (!domReady)
        return;
      if (!(contentElement == null ? void 0 : contentElement.isConnected))
        return;
      const element = getElementFromProp(initialFocus, true) || // If no initial focus is specified, we try to focus the first element
      // with the autofocus attribute. If it's an Ariakit component, the
      // Focusable component will consume the autoFocus prop and add the
      // data-autofocus attribute to the element instead.
      contentElement.querySelector(
        "[data-autofocus=true],[autofocus]"
      ) || // We have to fallback to the first focusable element otherwise portaled
      // dialogs with preserveTabOrder set to true will not receive focus
      // properly because the elements aren't tabbable until the dialog
      // receives focus.
      _focus.getFirstTabbableIn.call(void 0, contentElement, true, portal && preserveTabOrder) || // Finally, we fallback to the dialog element itself.
      contentElement;
      const isElementFocusable = _focus.isFocusable.call(void 0, element);
      if (!autoFocusOnShowProp(isElementFocusable ? element : null))
        return;
      setAutoFocusEnabled(true);
      element.focus();
    }, [
      open,
      mayAutoFocusOnShow,
      domReady,
      contentElement,
      initialFocus,
      portal,
      preserveTabOrder,
      autoFocusOnShowProp
    ]);
    const mayAutoFocusOnHide = !!autoFocusOnHide;
    const autoFocusOnHideProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, autoFocusOnHide);
    const [hasOpened, setHasOpened] = _react.useState.call(void 0, false);
    _react.useEffect.call(void 0, () => {
      if (!open)
        return;
      setHasOpened(true);
      return () => setHasOpened(false);
    }, [open]);
    _NREUHWTUcjs.useSafeLayoutEffect.call(void 0, () => {
      if (!hasOpened)
        return;
      if (!mayAutoFocusOnHide)
        return;
      const dialog = ref.current;
      const focusOnHide = (retry = true) => {
        if (!dialog)
          return;
        if (isAlreadyFocusingAnotherElement(dialog))
          return;
        const { disclosureElement } = store.getState();
        let element = getElementFromProp(finalFocus) || disclosureElement;
        if (element == null ? void 0 : element.id) {
          const doc = _dom.getDocument.call(void 0, element);
          const selector = `[aria-activedescendant="${element.id}"]`;
          const composite = doc.querySelector(selector);
          if (composite) {
            element = composite;
          }
        }
        if (element && !_focus.isFocusable.call(void 0, element)) {
          const maybeParentDialog = _dom.closest.call(void 0, element, "[data-dialog]");
          if (maybeParentDialog && maybeParentDialog.id) {
            const doc = _dom.getDocument.call(void 0, maybeParentDialog);
            const selector = `[aria-controls~="${maybeParentDialog.id}"]`;
            const control = doc.querySelector(selector);
            if (control) {
              element = control;
            }
          }
        }
        const isElementFocusable = element && _focus.isFocusable.call(void 0, element);
        if (!isElementFocusable && retry) {
          requestAnimationFrame(() => focusOnHide(false));
          return;
        }
        if (!autoFocusOnHideProp(isElementFocusable ? element : null))
          return;
        if (!isElementFocusable)
          return;
        element == null ? void 0 : element.focus();
      };
      if (!open) {
        return focusOnHide();
      }
      return focusOnHide;
    }, [hasOpened, open, mayAutoFocusOnHide, finalFocus, autoFocusOnHideProp]);
    const hideOnEscapeProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, hideOnEscape);
    _react.useEffect.call(void 0, () => {
      if (!domReady)
        return;
      if (!mounted)
        return;
      const onKeyDown = (event) => {
        if (event.key !== "Escape")
          return;
        if (event.defaultPrevented)
          return;
        const dialog = ref.current;
        if (!dialog)
          return;
        const target = event.target;
        if (!target)
          return;
        const { disclosureElement } = store.getState();
        const isValidTarget = () => {
          if (target.tagName === "BODY")
            return true;
          if (_dom.contains.call(void 0, dialog, target))
            return true;
          if (!disclosureElement)
            return false;
          if (_dom.contains.call(void 0, disclosureElement, target))
            return true;
          return false;
        };
        if (!isValidTarget())
          return;
        if (!hideOnEscapeProp(event))
          return;
        event.stopImmediatePropagation();
        store.hide();
      };
      return _events.addGlobalEventListener.call(void 0, "keydown", onKeyDown);
    }, [mounted, domReady, hideOnEscapeProp]);
    props = _NREUHWTUcjs.useWrapElement.call(void 0, 
      props,
      (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _SOPRUU56cjs.HeadingLevel, { level: modal ? 1 : void 0, children: element }),
      [modal]
    );
    const hiddenProp = props.hidden;
    props = _NREUHWTUcjs.useWrapElement.call(void 0, 
      props,
      (element) => {
        if (backdrop) {
          return /* @__PURE__ */ _jsxruntime.jsx.call(void 0, 
            _OMM6PC3Acjs.DialogBackdrop,
            {
              store,
              backdrop,
              backdropProps,
              hidden: hiddenProp,
              children: element
            }
          );
        }
        return element;
      },
      [store, backdrop, backdropProps, hiddenProp]
    );
    const [headingId, setHeadingId] = _react.useState.call(void 0, );
    const [descriptionId, setDescriptionId] = _react.useState.call(void 0, );
    props = _NREUHWTUcjs.useWrapElement.call(void 0, 
      props,
      (element) => /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _N2VCZZLPcjs.DialogContext.Provider, { value: store, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _N2VCZZLPcjs.DialogHeadingContext.Provider, { value: setHeadingId, children: /* @__PURE__ */ _jsxruntime.jsx.call(void 0, _N2VCZZLPcjs.DialogDescriptionContext.Provider, { value: setDescriptionId, children: element }) }) }),
      [store]
    );
    props = _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {
      id,
      "data-dialog": "",
      role: "dialog",
      tabIndex: focusable ? -1 : void 0,
      "aria-labelledby": headingId,
      "aria-describedby": descriptionId
    }, props), {
      ref: _NREUHWTUcjs.useForkRef.call(void 0, ref, props.ref)
    });
    props = _GHWBKA6Hcjs.useFocusableContainer.call(void 0, _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {}, props), {
      autoFocusOnShow: autoFocusEnabled
    }));
    props = _EM2PMFEWcjs.useDisclosureContent.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, { store }, props));
    props = _NVBNDB5Bcjs.useFocusable.call(void 0, _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {}, props), { focusable }));
    props = _PFD4TS6Bcjs.usePortal.call(void 0, _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, { portal }, props), { portalRef, preserveTabOrder }));
    return props;
  }
);
var Dialog = _7NAIPZYNcjs.createComponent.call(void 0, (props) => {
  const htmlProps = useDialog(props);
  return _7NAIPZYNcjs.createElement.call(void 0, "div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Dialog.displayName = "Dialog";
}




exports.useDialog = useDialog; exports.Dialog = Dialog;
