"use strict";Object.defineProperty(exports, "__esModule", {value: true});

var _YYKQBWQQcjs = require('../__chunks/YYKQBWQQ.cjs');
require('../__chunks/OLGMV24U.cjs');


var _RHO5OVPEcjs = require('../__chunks/RHO5OVPE.cjs');



var _MPFAD3UKcjs = require('../__chunks/MPFAD3UK.cjs');
require('../__chunks/JZRGYPLK.cjs');
require('../__chunks/IRSBF3C5.cjs');
require('../__chunks/OMM6PC3A.cjs');
require('../__chunks/O45IXGJW.cjs');
require('../__chunks/TVZPJJTX.cjs');
require('../__chunks/QRAQT522.cjs');
require('../__chunks/NZYGNCZL.cjs');
require('../__chunks/E5VOJWDR.cjs');
require('../__chunks/56NPFF7P.cjs');
require('../__chunks/W32FX7DM.cjs');
require('../__chunks/CARNFZQT.cjs');
require('../__chunks/NR3SJH64.cjs');
require('../__chunks/GHWBKA6H.cjs');
require('../__chunks/EE6OIU6X.cjs');
require('../__chunks/X2GXTE3P.cjs');
require('../__chunks/SOPRUU56.cjs');
require('../__chunks/CQSUIL2D.cjs');
require('../__chunks/N2VCZZLP.cjs');
require('../__chunks/HVQRVCAS.cjs');
require('../__chunks/W5PBA4D6.cjs');
require('../__chunks/5I6IQHKQ.cjs');
require('../__chunks/KLZID3QO.cjs');
require('../__chunks/NVBNDB5B.cjs');
require('../__chunks/LHHW5ZQP.cjs');
require('../__chunks/NVMBKFRB.cjs');
require('../__chunks/PFD4TS6B.cjs');
require('../__chunks/C7Y26CUV.cjs');
require('../__chunks/NS56XHXG.cjs');
require('../__chunks/EM2PMFEW.cjs');
require('../__chunks/QTPUX3NM.cjs');




var _7NAIPZYNcjs = require('../__chunks/7NAIPZYN.cjs');
require('../__chunks/F7HVNVHQ.cjs');




var _NREUHWTUcjs = require('../__chunks/NREUHWTU.cjs');
require('../__chunks/2X5K3J7Y.cjs');




var _6455U47Tcjs = require('../__chunks/6455U47T.cjs');

// src/menu/menu.ts
var _react = require('react');
var _focus = require('@ariakit/core/utils/focus');
var useMenu = _7NAIPZYNcjs.createHook.call(void 0, 
  (_a) => {
    var _b = _a, {
      store,
      hideOnEscape = true,
      autoFocusOnShow = true,
      hideOnHoverOutside
    } = _b, props = _6455U47Tcjs.__objRest.call(void 0, _b, [
      "store",
      "hideOnEscape",
      "autoFocusOnShow",
      "hideOnHoverOutside"
    ]);
    const ref = _react.useRef.call(void 0, null);
    const parentMenu = _react.useContext.call(void 0, _MPFAD3UKcjs.MenuContext);
    const parentMenuBar = _react.useContext.call(void 0, _MPFAD3UKcjs.MenuBarContext);
    const hasParentMenu = !!parentMenu;
    const parentIsMenuBar = !!parentMenuBar && !hasParentMenu;
    const onKeyDownProp = props.onKeyDown;
    const hideOnEscapeProp = _NREUHWTUcjs.useBooleanEvent.call(void 0, hideOnEscape);
    const onKeyDown = _NREUHWTUcjs.useEvent.call(void 0, (event) => {
      onKeyDownProp == null ? void 0 : onKeyDownProp(event);
      if (event.defaultPrevented)
        return;
      if (event.key === "Escape") {
        if (!hideOnEscapeProp(event))
          return;
        if (!hasParentMenu) {
          event.stopPropagation();
        }
        return store.hide();
      }
    });
    props = _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {}, props), {
      ref: _NREUHWTUcjs.useForkRef.call(void 0, ref, props.ref),
      onKeyDown
    });
    const _a2 = _RHO5OVPEcjs.useMenuList.call(void 0, 
      _6455U47Tcjs.__spreadValues.call(void 0, { store }, props)
    ), { "aria-labelledby": ariaLabelledBy } = _a2, menuListProps = _6455U47Tcjs.__objRest.call(void 0, _a2, ["aria-labelledby"]);
    props = menuListProps;
    const [initialFocusRef, setInitialFocusRef] = _react.useState.call(void 0, );
    const autoFocusOnShowState = store.useState("autoFocusOnShow");
    const initialFocus = store.useState("initialFocus");
    const baseElement = store.useState("baseElement");
    const items = store.useState("items");
    _react.useEffect.call(void 0, () => {
      let cleaning = false;
      setInitialFocusRef((prevInitialFocusRef) => {
        var _a3, _b2, _c;
        if (cleaning)
          return;
        if (!autoFocusOnShowState)
          return;
        if ((_a3 = prevInitialFocusRef == null ? void 0 : prevInitialFocusRef.current) == null ? void 0 : _a3.isConnected)
          return prevInitialFocusRef;
        const ref2 = _react.createRef.call(void 0, );
        switch (initialFocus) {
          case "first":
            ref2.current = ((_b2 = items.find((item) => !item.disabled && item.element)) == null ? void 0 : _b2.element) || null;
            break;
          case "last":
            ref2.current = ((_c = [...items].reverse().find((item) => !item.disabled && item.element)) == null ? void 0 : _c.element) || null;
            break;
          default:
            ref2.current = baseElement;
        }
        if (!ref2.current)
          return;
        return ref2;
      });
      return () => {
        cleaning = true;
      };
    }, [store, autoFocusOnShowState, initialFocus, items, baseElement]);
    const mayAutoFocusOnShow = !!autoFocusOnShow;
    const canAutoFocusOnShow = !!initialFocusRef || !!props.initialFocus || !!props.modal;
    props = _YYKQBWQQcjs.useHovercard.call(void 0, _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {
      store,
      initialFocus: initialFocusRef,
      autoFocusOnShow: mayAutoFocusOnShow ? canAutoFocusOnShow && autoFocusOnShow : autoFocusOnShowState || !!props.modal
    }, props), {
      hideOnHoverOutside: (event) => {
        if (typeof hideOnHoverOutside === "function") {
          return hideOnHoverOutside(event);
        }
        if (hideOnHoverOutside != null)
          return hideOnHoverOutside;
        if (hasParentMenu) {
          parentMenu.setActiveId(null);
          return true;
        }
        if (!parentIsMenuBar)
          return false;
        const { disclosureElement } = store.getState();
        const disclosure = disclosureElement;
        if (!disclosure)
          return true;
        if (_focus.hasFocusWithin.call(void 0, disclosure))
          return false;
        return true;
      },
      // If it's a submenu, it shouldn't behave like a modal dialog, nor display
      // a backdrop.
      modal: hasParentMenu ? false : props.modal,
      backdrop: hasParentMenu ? false : props.backdrop,
      // If it's a submenu, hide on esc will be handled differently. That is,
      // event.stopPropagation() won't be called, so the parent menus will also
      // be closed.
      hideOnEscape: hasParentMenu ? false : hideOnEscape
    }));
    props = _6455U47Tcjs.__spreadValues.call(void 0, {
      "aria-labelledby": ariaLabelledBy
    }, props);
    return props;
  }
);
var Menu = _7NAIPZYNcjs.createComponent.call(void 0, (props) => {
  const htmlProps = useMenu(props);
  return _7NAIPZYNcjs.createElement.call(void 0, "div", htmlProps);
});
if (process.env.NODE_ENV !== "production") {
  Menu.displayName = "Menu";
}



exports.Menu = Menu; exports.useMenu = useMenu;
