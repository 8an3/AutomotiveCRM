"use strict";Object.defineProperty(exports, "__esModule", {value: true});







var _M6ZA7XUPcjs = require('./M6ZA7XUP.cjs');



var _6455U47Tcjs = require('./6455U47T.cjs');

// src/utils/store.ts
function createStore(initialState, ...stores) {
  let state = initialState;
  let prevStateBatch = state;
  let lastUpdate = Symbol();
  let updating = false;
  let initialized = false;
  const updatedKeys = /* @__PURE__ */ new Set();
  const setups = /* @__PURE__ */ new Set();
  const listeners = /* @__PURE__ */ new Set();
  const listenersBatch = /* @__PURE__ */ new Set();
  const disposables = /* @__PURE__ */ new WeakMap();
  const listenerKeys = /* @__PURE__ */ new WeakMap();
  const setup = (callback) => {
    setups.add(callback);
    return () => setups.delete(callback);
  };
  const init = () => {
    if (initialized)
      return _M6ZA7XUPcjs.noop;
    if (!stores.length)
      return _M6ZA7XUPcjs.noop;
    initialized = true;
    const desyncs = _M6ZA7XUPcjs.getKeys.call(void 0, state).map(
      (key) => _M6ZA7XUPcjs.chain.call(void 0, 
        ...stores.map((store) => {
          var _a, _b;
          const storeState = (_a = store == null ? void 0 : store.getState) == null ? void 0 : _a.call(store);
          if (!storeState)
            return;
          if (!_M6ZA7XUPcjs.hasOwnProperty.call(void 0, storeState, key))
            return;
          return (_b = store == null ? void 0 : store.sync) == null ? void 0 : _b.call(store, (state2) => setState(key, state2[key]), [key]);
        })
      )
    );
    const teardowns = [];
    setups.forEach((setup2) => teardowns.push(setup2()));
    const cleanups = stores.map((store) => {
      var _a;
      return (_a = store == null ? void 0 : store.init) == null ? void 0 : _a.call(store);
    });
    return _M6ZA7XUPcjs.chain.call(void 0, ...desyncs, ...teardowns, ...cleanups, () => {
      initialized = false;
    });
  };
  const sub = (listener, keys, batch = false) => {
    const set = batch ? listenersBatch : listeners;
    set.add(listener);
    listenerKeys.set(listener, keys);
    return () => {
      var _a;
      (_a = disposables.get(listener)) == null ? void 0 : _a();
      disposables.delete(listener);
      listenerKeys.delete(listener);
      set.delete(listener);
    };
  };
  const subscribe = (listener, keys) => sub(listener, keys);
  const sync = (listener, keys) => {
    disposables.set(listener, listener(state, state));
    return sub(listener, keys);
  };
  const syncBatch = (listener, keys) => {
    if (!updating) {
      disposables.set(listener, listener(state, prevStateBatch));
    }
    return sub(listener, keys, true);
  };
  const getState = () => state;
  const setState = (key, value) => {
    if (!_M6ZA7XUPcjs.hasOwnProperty.call(void 0, state, key))
      return;
    const nextValue = _M6ZA7XUPcjs.applyState.call(void 0, value, state[key]);
    if (nextValue === state[key])
      return;
    stores.forEach((store) => {
      var _a;
      (_a = store == null ? void 0 : store.setState) == null ? void 0 : _a.call(store, key, nextValue);
    });
    const prevState = state;
    state = _6455U47Tcjs.__spreadProps.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {}, state), { [key]: nextValue });
    const thisUpdate = Symbol();
    lastUpdate = thisUpdate;
    updating = true;
    updatedKeys.add(key);
    const run = (listener, prev, uKeys) => {
      var _a;
      const keys = listenerKeys.get(listener);
      const updated = (k) => uKeys ? uKeys.has(k) : k === key;
      if (!keys || keys.some(updated)) {
        (_a = disposables.get(listener)) == null ? void 0 : _a();
        disposables.set(listener, listener(state, prev));
      }
    };
    listeners.forEach((listener) => run(listener, prevState));
    queueMicrotask(() => {
      if (lastUpdate !== thisUpdate)
        return;
      updating = false;
      const snapshot = state;
      listenersBatch.forEach((listener) => {
        run(listener, prevStateBatch, updatedKeys);
      });
      prevStateBatch = snapshot;
      queueMicrotask(() => {
        updatedKeys.clear();
      });
    });
  };
  const pick2 = (...keys) => createStore(_M6ZA7XUPcjs.pick.call(void 0, state, keys), finalStore);
  const omit2 = (...keys) => createStore(_M6ZA7XUPcjs.omit.call(void 0, state, keys), finalStore);
  const finalStore = {
    setup,
    init,
    subscribe,
    sync,
    syncBatch,
    getState,
    setState,
    pick: pick2,
    omit: omit2
  };
  return finalStore;
}
function mergeStore(...stores) {
  const initialState = stores.reduce((state, store2) => {
    var _a;
    const nextState = (_a = store2 == null ? void 0 : store2.getState) == null ? void 0 : _a.call(store2);
    if (!nextState)
      return state;
    return _6455U47Tcjs.__spreadValues.call(void 0, _6455U47Tcjs.__spreadValues.call(void 0, {}, state), nextState);
  }, {});
  const store = createStore(initialState, ...stores);
  return store;
}




exports.createStore = createStore; exports.mergeStore = mergeStore;
